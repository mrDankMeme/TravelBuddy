//
//  TravelBuddyUITestsLaunchTests.swift
//  TravelBuddyUITests
//
//  Created by Niiaz Khasanov on 10/1/25.
//

import XCTest

final class TravelBuddyUITestsLaunchTests: XCTestCase {

    override class var runsForEachTargetApplicationUIConfiguration: Bool {
        true
    }

    override func setUpWithError() throws {
        continueAfterFailure = false
    }

    @MainActor
    func testLaunch() throws {
        let app = XCUIApplication()
        app.launch()

        // Insert steps here to perform after app launch but before taking a screenshot,
        // such as logging into a test account or navigating somewhere in the app

        let attachment = XCTAttachment(screenshot: app.screenshot())
        attachment.name = "Launch Screen"
        attachment.lifetime = .keepAlways
        add(attachment)
    }
}
//
//  SnapshotHelper.swift
//  Example
//
//  Created by Felix Krause on 10/8/15.
//

// -----------------------------------------------------
// IMPORTANT: When modifying this file, make sure to
//            increment the version number at the very
//            bottom of the file to notify users about
//            the new SnapshotHelper.swift
// -----------------------------------------------------

import Foundation
import XCTest

@MainActor
func setupSnapshot(_ app: XCUIApplication, waitForAnimations: Bool = true) {
    Snapshot.setupSnapshot(app, waitForAnimations: waitForAnimations)
}

@MainActor
func snapshot(_ name: String, waitForLoadingIndicator: Bool) {
    if waitForLoadingIndicator {
        Snapshot.snapshot(name)
    } else {
        Snapshot.snapshot(name, timeWaitingForIdle: 0)
    }
}

/// - Parameters:
///   - name: The name of the snapshot
///   - timeout: Amount of seconds to wait until the network loading indicator disappears. Pass `0` if you don't want to wait.
@MainActor
func snapshot(_ name: String, timeWaitingForIdle timeout: TimeInterval = 20) {
    Snapshot.snapshot(name, timeWaitingForIdle: timeout)
}

enum SnapshotError: Error, CustomDebugStringConvertible {
    case cannotFindSimulatorHomeDirectory
    case cannotRunOnPhysicalDevice

    var debugDescription: String {
        switch self {
        case .cannotFindSimulatorHomeDirectory:
            return "Couldn't find simulator home location. Please, check SIMULATOR_HOST_HOME env variable."
        case .cannotRunOnPhysicalDevice:
            return "Can't use Snapshot on a physical device."
        }
    }
}

@objcMembers
@MainActor
open class Snapshot: NSObject {
    static var app: XCUIApplication?
    static var waitForAnimations = true
    static var cacheDirectory: URL?
    static var screenshotsDirectory: URL? {
        return cacheDirectory?.appendingPathComponent("screenshots", isDirectory: true)
    }
    static var deviceLanguage = ""
    static var currentLocale = ""

    open class func setupSnapshot(_ app: XCUIApplication, waitForAnimations: Bool = true) {

        Snapshot.app = app
        Snapshot.waitForAnimations = waitForAnimations

        do {
            let cacheDir = try getCacheDirectory()
            Snapshot.cacheDirectory = cacheDir
            setLanguage(app)
            setLocale(app)
            setLaunchArguments(app)
        } catch let error {
            NSLog(error.localizedDescription)
        }
    }

    class func setLanguage(_ app: XCUIApplication) {
        guard let cacheDirectory = self.cacheDirectory else {
            NSLog("CacheDirectory is not set - probably running on a physical device?")
            return
        }

        let path = cacheDirectory.appendingPathComponent("language.txt")

        do {
            let trimCharacterSet = CharacterSet.whitespacesAndNewlines
            deviceLanguage = try String(contentsOf: path, encoding: .utf8).trimmingCharacters(in: trimCharacterSet)
            app.launchArguments += ["-AppleLanguages", "(\(deviceLanguage))"]
        } catch {
            NSLog("Couldn't detect/set language...")
        }
    }

    class func setLocale(_ app: XCUIApplication) {
        guard let cacheDirectory = self.cacheDirectory else {
            NSLog("CacheDirectory is not set - probably running on a physical device?")
            return
        }

        let path = cacheDirectory.appendingPathComponent("locale.txt")

        do {
            let trimCharacterSet = CharacterSet.whitespacesAndNewlines
            currentLocale = try String(contentsOf: path, encoding: .utf8).trimmingCharacters(in: trimCharacterSet)
        } catch {
            NSLog("Couldn't detect/set locale...")
        }

        if currentLocale.isEmpty && !deviceLanguage.isEmpty {
            currentLocale = Locale(identifier: deviceLanguage).identifier
        }

        if !currentLocale.isEmpty {
            app.launchArguments += ["-AppleLocale", "\"\(currentLocale)\""]
        }
    }

    class func setLaunchArguments(_ app: XCUIApplication) {
        guard let cacheDirectory = self.cacheDirectory else {
            NSLog("CacheDirectory is not set - probably running on a physical device?")
            return
        }

        let path = cacheDirectory.appendingPathComponent("snapshot-launch_arguments.txt")
        app.launchArguments += ["-FASTLANE_SNAPSHOT", "YES", "-ui_testing"]

        do {
            let launchArguments = try String(contentsOf: path, encoding: String.Encoding.utf8)
            let regex = try NSRegularExpression(pattern: "(\\\".+?\\\"|\\S+)", options: [])
            let matches = regex.matches(in: launchArguments, options: [], range: NSRange(location: 0, length: launchArguments.count))
            let results = matches.map { result -> String in
                (launchArguments as NSString).substring(with: result.range)
            }
            app.launchArguments += results
        } catch {
            NSLog("Couldn't detect/set launch_arguments...")
        }
    }

    open class func snapshot(_ name: String, timeWaitingForIdle timeout: TimeInterval = 20) {
        if timeout > 0 {
            waitForLoadingIndicatorToDisappear(within: timeout)
        }

        NSLog("snapshot: \(name)") // more information about this, check out https://docs.fastlane.tools/actions/snapshot/#how-does-it-work

        if Snapshot.waitForAnimations {
            sleep(1) // Waiting for the animation to be finished (kind of)
        }

        #if os(OSX)
            guard let app = self.app else {
                NSLog("XCUIApplication is not set. Please call setupSnapshot(app) before snapshot().")
                return
            }

            app.typeKey(XCUIKeyboardKeySecondaryFn, modifierFlags: [])
        #else

            guard self.app != nil else {
                NSLog("XCUIApplication is not set. Please call setupSnapshot(app) before snapshot().")
                return
            }

            let screenshot = XCUIScreen.main.screenshot()
            #if os(iOS) && !targetEnvironment(macCatalyst)
            let image = XCUIDevice.shared.orientation.isLandscape ?  fixLandscapeOrientation(image: screenshot.image) : screenshot.image
            #else
            let image = screenshot.image
            #endif

            guard var simulator = ProcessInfo().environment["SIMULATOR_DEVICE_NAME"], let screenshotsDir = screenshotsDirectory else { return }

            do {
                // The simulator name contains "Clone X of " inside the screenshot file when running parallelized UI Tests on concurrent devices
                let regex = try NSRegularExpression(pattern: "Clone [0-9]+ of ")
                let range = NSRange(location: 0, length: simulator.count)
                simulator = regex.stringByReplacingMatches(in: simulator, range: range, withTemplate: "")

                let path = screenshotsDir.appendingPathComponent("\(simulator)-\(name).png")
                #if swift(<5.0)
                    try UIImagePNGRepresentation(image)?.write(to: path, options: .atomic)
                #else
                    try image.pngData()?.write(to: path, options: .atomic)
                #endif
            } catch let error {
                NSLog("Problem writing screenshot: \(name) to \(screenshotsDir)/\(simulator)-\(name).png")
                NSLog(error.localizedDescription)
            }
        #endif
    }

    class func fixLandscapeOrientation(image: UIImage) -> UIImage {
        #if os(watchOS)
            return image
        #else
            if #available(iOS 10.0, *) {
                let format = UIGraphicsImageRendererFormat()
                format.scale = image.scale
                let renderer = UIGraphicsImageRenderer(size: image.size, format: format)
                return renderer.image { context in
                    image.draw(in: CGRect(x: 0, y: 0, width: image.size.width, height: image.size.height))
                }
            } else {
                return image
            }
        #endif
    }

    class func waitForLoadingIndicatorToDisappear(within timeout: TimeInterval) {
        #if os(tvOS)
            return
        #endif

        guard let app = self.app else {
            NSLog("XCUIApplication is not set. Please call setupSnapshot(app) before snapshot().")
            return
        }

        let networkLoadingIndicator = app.otherElements.deviceStatusBars.networkLoadingIndicators.element
        let networkLoadingIndicatorDisappeared = XCTNSPredicateExpectation(predicate: NSPredicate(format: "exists == false"), object: networkLoadingIndicator)
        _ = XCTWaiter.wait(for: [networkLoadingIndicatorDisappeared], timeout: timeout)
    }

    class func getCacheDirectory() throws -> URL {
        let cachePath = "Library/Caches/tools.fastlane"
        // on OSX config is stored in /Users/<username>/Library
        // and on iOS/tvOS/WatchOS it's in simulator's home dir
        #if os(OSX)
            let homeDir = URL(fileURLWithPath: NSHomeDirectory())
            return homeDir.appendingPathComponent(cachePath)
        #elseif arch(i386) || arch(x86_64) || arch(arm64)
            guard let simulatorHostHome = ProcessInfo().environment["SIMULATOR_HOST_HOME"] else {
                throw SnapshotError.cannotFindSimulatorHomeDirectory
            }
            let homeDir = URL(fileURLWithPath: simulatorHostHome)
            return homeDir.appendingPathComponent(cachePath)
        #else
            throw SnapshotError.cannotRunOnPhysicalDevice
        #endif
    }
}

private extension XCUIElementAttributes {
    var isNetworkLoadingIndicator: Bool {
        if hasAllowListedIdentifier { return false }

        let hasOldLoadingIndicatorSize = frame.size == CGSize(width: 10, height: 20)
        let hasNewLoadingIndicatorSize = frame.size.width.isBetween(46, and: 47) && frame.size.height.isBetween(2, and: 3)

        return hasOldLoadingIndicatorSize || hasNewLoadingIndicatorSize
    }

    var hasAllowListedIdentifier: Bool {
        let allowListedIdentifiers = ["GeofenceLocationTrackingOn", "StandardLocationTrackingOn"]

        return allowListedIdentifiers.contains(identifier)
    }

    func isStatusBar(_ deviceWidth: CGFloat) -> Bool {
        if elementType == .statusBar { return true }
        guard frame.origin == .zero else { return false }

        let oldStatusBarSize = CGSize(width: deviceWidth, height: 20)
        let newStatusBarSize = CGSize(width: deviceWidth, height: 44)

        return [oldStatusBarSize, newStatusBarSize].contains(frame.size)
    }
}

private extension XCUIElementQuery {
    var networkLoadingIndicators: XCUIElementQuery {
        let isNetworkLoadingIndicator = NSPredicate { (evaluatedObject, _) in
            guard let element = evaluatedObject as? XCUIElementAttributes else { return false }

            return element.isNetworkLoadingIndicator
        }

        return self.containing(isNetworkLoadingIndicator)
    }

    @MainActor
    var deviceStatusBars: XCUIElementQuery {
        guard let app = Snapshot.app else {
            fatalError("XCUIApplication is not set. Please call setupSnapshot(app) before snapshot().")
        }

        let deviceWidth = app.windows.firstMatch.frame.width

        let isStatusBar = NSPredicate { (evaluatedObject, _) in
            guard let element = evaluatedObject as? XCUIElementAttributes else { return false }

            return element.isStatusBar(deviceWidth)
        }

        return self.containing(isStatusBar)
    }
}

private extension CGFloat {
    func isBetween(_ numberA: CGFloat, and numberB: CGFloat) -> Bool {
        return numberA...numberB ~= self
    }
}

// Please don't remove the lines below
// They are used to detect outdated configuration files
// SnapshotHelperVersion [1.30]
//
//  TravelBuddySnapshotUITests.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 10/1/25.
//



import XCTest

@MainActor
final class TravelBuddySnapshotUITests: XCTestCase {

    private var app: XCUIApplication!

    override func setUp() {
        super.setUp()
        continueAfterFailure = false

        app = XCUIApplication()

        // Если используете fastlane snapshot, setupSnapshot(app) уже добавит свои аргументы/локаль.
        // Если у вас подключен SnapshotHelper.swift — раскомментируйте:
         setupSnapshot(app)

        // Рекомендовано пробрасывать флаги (опционально, если поддержаны приложением):
        // app.launchArguments += ["-uiTesting", "1", "-uiMockData", "1", "-uiPremium", "locked", "-skipOnboarding", "YES"]

        app.launch()
    }

    // MARK: - Главный сценарий скриншотов

     func testSnapshot_Onboarding_List_Map_Settings() {
        // --- 01: Onboarding page 1 ---
        // Ждем появления кнопки онбординга (id или текст), чтобы не сделать снимок "раньше времени"
        let onboardingNext = app.buttons["onboarding.next"]
        let onboardingNextText = app.buttons["Next"]
        XCTAssertTrue(
            onboardingNext.waitForExistence(timeout: 5) || onboardingNextText.waitForExistence(timeout: 5),
            "Onboarding page 1 did not appear"
        )
        snapshot("01-Onboarding-Page1")

        // Переходим на 2 страницу
        tapIfExists(onboardingNext, fallback: onboardingNextText)

        // Переходим на 3 страницу
        let onboardingNext2 = app.buttons["onboarding.next"]
        let onboardingNextText2 = app.buttons["Next"]
        tapIfExists(onboardingNext2, fallback: onboardingNextText2)

        // Завершаем онбординг
        let getStarted = app.buttons["onboarding.get_started"]
        let getStartedText = app.buttons["Get Started"]
        tapIfExists(getStarted, fallback: getStartedText)

        // --- 02: Places list ---
        // Убедимся, что мы на экране Places/Места
        let navPlaces = app.navigationBars["Places"]
        let navPlacesRu = app.navigationBars["Места"]
        XCTAssertTrue(navPlaces.waitForExistence(timeout: 5) || navPlacesRu.waitForExistence(timeout: 5),
                      "Places screen did not appear")

        // Ждем таблицу и первую ячейку (это убирает "ромашку" на снимке)
        let table = app.tables.firstMatch
        XCTAssertTrue(table.waitForExistence(timeout: 10), "Places table did not appear")

        let firstCell = table.cells.element(boundBy: 0)
        XCTAssertTrue(firstCell.waitForExistence(timeout: 20),
                      "Places first cell did not appear (waited for remote->fallback local)")

        snapshot("02-Places-List")

        // --- 03: POI Detail ---
        firstCell.tap()

        // Ждем появления элемента на экране детали:
        // используем кнопку закрытия, которая у тебя есть ("xmark.circle.fill").
        let closeButton = app.buttons["xmark.circle.fill"]
        XCTAssertTrue(closeButton.waitForExistence(timeout: 5), "POI Detail did not open")

        // Если есть доступный стабильный элемент (заголовок/кнопка share) — можно ждать его:
        // let share = app.buttons["detail.share"] // если в App выставлен identifier
        // _ = share.waitForExistence(timeout: 2)

        snapshot("03-POI-Detail")

        closeButton.tap()

        // --- 04: Map ---
        tapTab(labelEn: "Map", labelRu: "Карта")

        // Ждем устойчивый системный элемент карты внизу (Legal / Правовые документы)
        let legal = app.staticTexts["Legal"]
        let legalRu = app.staticTexts["Правовые документы"]
        XCTAssertTrue(legal.waitForExistence(timeout: 10) || legalRu.waitForExistence(timeout: 10),
                      "Map did not load 'Legal' label")

        snapshot("04-Map")

        // --- 05: Settings ---
        tapTab(labelEn: "Settings", labelRu: "Настройки")

        let settingsTitle = app.staticTexts["Settings"]
        let settingsTitleRu = app.staticTexts["Настройки"]
        XCTAssertTrue(settingsTitle.waitForExistence(timeout: 5) || settingsTitleRu.waitForExistence(timeout: 5),
                      "Settings screen did not appear")

        snapshot("05-Settings")
    }

    // MARK: - Helpers

    /// Тапаем element, если он существует; иначе — fallback.
    private func tapIfExists(_ element: XCUIElement, fallback: XCUIElement? = nil, timeout: TimeInterval = 2) {
        if element.waitForExistence(timeout: timeout) {
            element.tap()
        } else if let fb = fallback, fb.waitForExistence(timeout: timeout) {
            fb.tap()
        } else {
            XCTFail("Neither main element nor fallback existed for tap")
        }
    }

    /// Переход по табу. Сначала пытаемся по айдишникам (если добавишь их в приложении),
    /// затем по локализованным текстам, затем по первому табу.
    private func tapTab(labelEn: String, labelRu: String) {
        let tabBar = app.tabBars.firstMatch

        // 1) Попытка по identifier (добавь в приложении, если захочешь):
        let idCandidates = ["tab.places", "tab.map", "tab.settings"]
        for id in idCandidates {
            let btn = tabBar.buttons[id]
            if btn.exists {
                btn.tap()
                return
            }
        }

        // 2) По текстовым лейблам (как сейчас)
        let en = tabBar.buttons[labelEn]
        let ru = tabBar.buttons[labelRu]
        if en.exists { en.tap(); return }
        if ru.exists { ru.tap(); return }

        // 3) Фолбэк — любой первый таб
        if tabBar.buttons.count > 0 {
            tabBar.buttons.element(boundBy: 0).tap()
        } else {
            XCTFail("No tabs found")
        }
    }
}

 
//
//  TravelBuddyUITests.swift
//  TravelBuddyUITests
//
//  Created by Niiaz Khasanov on 10/1/25.
//

import XCTest

final class TravelBuddyUITests: XCTestCase {

    override func setUpWithError() throws {
        // Put setup code here. This method is called before the invocation of each test method in the class.

        // In UI tests it is usually best to stop immediately when a failure occurs.
        continueAfterFailure = false

        // In UI tests it’s important to set the initial state - such as interface orientation - required for your tests before they run. The setUp method is a good place to do this.
    }

    override func tearDownWithError() throws {
        // Put teardown code here. This method is called after the invocation of each test method in the class.
    }

    @MainActor
    func testExample() throws {
        // UI tests must launch the application that they test.
        let app = XCUIApplication()
        app.launch()

        // Use XCTAssert and related functions to verify your tests produce the correct results.
    }

    @MainActor
    func testLaunchPerformance() throws {
        // This measures how long it takes to launch your application.
        measure(metrics: [XCTApplicationLaunchMetric()]) {
            XCUIApplication().launch()
        }
    }
}
excluded:
  - Carthage
  - Pods
  - build
  - fastlane
  - TravelBuddy/Generated
  - TravelBuddy/**/Generated

disabled_rules:
  - force_cast
  - force_unwrapping
  - implicit_optional_initialization
  - vertical_whitespace
  - trailing_newline
  - vertical_parameter_alignment
  - opening_brace
  - operator_usage_whitespace
  - comma
  - colon
  - comment_spacing
  - identifier_name
  - line_length
  - trailing_whitespace

included:
  - TravelBuddy
  
opt_in_rules:
  - empty_count
  - closure_end_indentation
  - redundant_nil_coalescing
  - operator_usage_whitespace
  - force_unwrapping

reporter: "xcode"

cyclomatic_complexity:
  warning: 15
  error: 20

type_body_length:
  warning: 400
  error: 600

file_length:
  warning: 800
  error: 1200

function_body_length:
  warning: 80
  error: 120

//
//  DesignTokens.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/20/25.
//

import UIKit

public enum DesignTokens {
    // MARK: Colors
    public static let colorPrimary = UIColor(hex: "#0055FF")!
    public static let colorBackground = UIColor { trait in
        trait.userInterfaceStyle == .dark
        ? UIColor(hex: "#000000")!
        : UIColor(hex: "#FFFFFF")!
    }
    
    // MARK: Typography
    public static let fontHeadline = UIFont.systemFont(ofSize: 24.scale, weight: .bold)
    public static let fontBody     = UIFont.systemFont(ofSize: 16.scale, weight: .regular)
    
    // MARK: Spacing
    public static let spacingSmall  = 8.scale
    public static let spacingMedium = 16.scale
    
}
//
//  L10n.swift
//  TravelBuddy
//

import Foundation

enum L10n {

    // MARK: - Internal helpers

    /// Возвращает локализованную строку по первому существующему ключу.
    private static func pick(_ keys: [String], _ comment: String) -> String {
        for k in keys {
            let v = NSLocalizedString(k, comment: comment)
            if v != k { return v } // ключ найден в .strings
        }
        // если ничего не нашли — вернём первую как есть (видно будет в UI)
        return NSLocalizedString(keys.first ?? "", comment: comment)
    }

    /// Формат для plural/параметров с фолбэком по нескольким ключам.
    private static func pickFormat(_ keys: [String], _ comment: String, _ args: CVarArg...) -> String {
        for k in keys {
            let fmt = NSLocalizedString(k, comment: comment)
            if fmt != k { return String(format: fmt, locale: .current, arguments: args) }
        }
        let fallback = NSLocalizedString(keys.first ?? "", comment: comment)
        return String(format: fallback, locale: .current, arguments: args)
    }

    // MARK: - Common
    static var alertOk: String { pick(["alert.ok"], "OK button") }
    static var alertErrorTitle: String { pick(["alert.error.title"], "Generic error alert title") }
    static var commonRetry: String { pick(["common.retry","list.retry"], "Retry") }
    static var commonClose: String { pick(["common.close"], "Close") }

    // MARK: - Tabs / Navigation titles
    static var tabPlaces: String { pick(["tab.places"], "Tab: Places") }
    static var tabMap: String { pick(["tab.map"], "Tab: Map") }
    static var tabSettings: String { pick(["tab.settings"], "Tab: Settings") }

    static var navPlacesTitle: String {
        pick(["nav.places.title","places.title","tab.places"], "Navigation title: Places")
    }
    static var navSettingsTitle: String {
        pick(["nav.settings.title","settings.title","tab.settings"], "Navigation title: Settings")
    }

    // MARK: - Settings
    static var settingsDarkMode: String {
        pick(["settings.darkmode","settings.dark_mode"], "Settings: Dark Mode")
    }
    static var settingsNotifications: String {
        pick(["settings.notifications"], "Settings: Notifications")
    }
    static var settingsPremiumUnlock: String {
        pick(["settings.premium.unlock"], "Settings: Unlock Premium")
    }
    static var settingsPremiumUnlocked: String {
        pick(["settings.premium.unlocked"], "Settings: Premium unlocked label")
    }

    // MARK: - List screen
    static var listCategoryTitle: String {
        pick(["list.category.title","places.category"], "Category picker title")
    }

    // Категории — поддерживаем обе схемы ключей
    static var catAll: String { pick(["category.all","places.category.all"], "Category: All") }
    static var catMonument: String { pick(["category.monument","places.category.monument"], "Category: Monument") }
    static var catMuseum: String { pick(["category.museum","places.category.museum"], "Category: Museum") }
    static var catCafe: String { pick(["category.cafe","places.category.cafe"], "Category: Cafe") }

    /// Плюралы «N places»
    static func listPlacesCount(_ n: Int) -> String {
        pickFormat(["list.places.count"], "Pluralized places count", n)
    }

    // MARK: - POI Detail / Snippet / Image
    static var detailLoadingAddress: String {
        pick(["detail.loading.address","poi.loading_address"], "Loading address…")
    }
    static var detailShare: String {
        pick(["detail.share","poi.share"], "Share button")
    }
    static var detailOpenInMaps: String {
        pick(["detail.openinmaps","poi.open_in_maps"], "Open in Maps")
    }

    static var snippetDetails: String { pick(["snippet.details","poi.details"], "Map snippet: Details") }
    static var snippetRoute: String { pick(["snippet.route","poi.route"], "Map snippet: Route") }

    static var imageNoImage: String { pick(["image.noimage","poi.image.none"], "No image placeholder") }
    static func imageInvalidPath(_ path: String) -> String {
        pickFormat(["image.invalid.path","poi.image.invalid_path"], "Invalid path", path)
    }
    static func imageMissingNamed(_ name: String) -> String {
        pickFormat(["poi.image.missing_named"], "Missing named image", name)
    }
    static func imagePath(_ path: String) -> String {
        pickFormat(["poi.image.path"], "Path label", path)
    }

    // MARK: - Onboarding (поддержка двух нейминг-схем)
    static var onboardingNext: String { pick(["onboarding.next","onb.next"], "Onboarding: Next") }
    static var onboardingBack: String { pick(["onboarding.back","onb.back"], "Onboarding: Back") }
    static var onboardingGetStarted: String { pick(["onboarding.get_started","onb.getstarted"], "Onboarding: Get Started") }

    static var onboardingTitle1: String { pick(["onboarding.title1","onb.p1.title"], "Onb page1 title") }
    static var onboardingDesc1: String  { pick(["onboarding.desc1","onb.p1.desc"], "Onb page1 desc") }
    static var onboardingTitle2: String { pick(["onboarding.title2","onb.p2.title"], "Onb page2 title") }
    static var onboardingDesc2: String  { pick(["onboarding.desc2","onb.p2.desc"], "Onb page2 desc") }
    static var onboardingTitle3: String { pick(["onboarding.title3","onb.p3.title"], "Onb page3 title") }
    static var onboardingDesc3: String  { pick(["onboarding.desc3","onb.p3.desc"], "Onb page3 desc") }

    // Для кода, который уже использует onb.*
    static var onbNext: String { onboardingNext }
    static var onbBack: String { onboardingBack }
    static var onbGetStarted: String { onboardingGetStarted }
    static var onbPage1Title: String { onboardingTitle1 }
    static var onbPage1Desc: String { onboardingDesc1 }
    static var onbPage2Title: String { onboardingTitle2 }
    static var onbPage2Desc: String { onboardingDesc2 }
    static var onbPage3Title: String { onboardingTitle3 }
    static var onbPage3Desc: String { onboardingDesc3 }

    // MARK: - DeepLink parsing errors
    static var deeplinkUnknownHost: String { pick(["deeplink.unknown_host"], "Unsupported link host") }
    static var deeplinkInvalidCoords: String { pick(["deeplink.invalid_coords"], "Invalid coordinates in deeplink") }
    static var deeplinkUnsupportedScheme: String { pick(["deeplink.unsupported_scheme"], "Unsupported url scheme") }

    // MARK: - DeepLink business errors
    static func deeplinkPoiNotFound(_ id: Int) -> String {
        pickFormat(["deeplink.poi.not_found"], "POI not found by ID", id)
    }
}
//
//  AppConfig.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 9/19/25.
//


import Foundation
import CoreLocation

public struct AppConfig {
    // MARK: — Network
    public let apiBaseURL: URL
    public let httpTimeout: TimeInterval

    // MARK: — Repository / Cache
    public let poiCacheTTL: TimeInterval

    // MARK: — IAP
    public struct IAP {
        public let premiumProductID: String
    }
    public let iap: IAP

    // MARK: — Local data / mocks
    public let localPOIJSONName: String

    // MARK: — Map defaults
    public let defaultRegionMeters: CLLocationDistance

    // MARK: — Feature Flags
    public struct Flags {
        public let enableDebugLogs: Bool
        public let useAlamofireClient: Bool  // на будущее
        public let showBLETab: Bool          // на будущее
        public let enableAudioGuide: Bool    // на будущее
    }
    public let flags: Flags
}


public extension AppConfig {
    static func makeDefault() -> AppConfig {
        #if DEBUG
        return AppConfig(
            apiBaseURL: URL(string: "https://api.example.com")!,
            httpTimeout: 0.15 ,
            poiCacheTTL: 300,
            iap: .init(premiumProductID: "com.travelbuddy.premium"),
            localPOIJSONName: "mock_pois_local",
            defaultRegionMeters: 4000,
            flags: .init(
                enableDebugLogs: true,
                useAlamofireClient: false,
                showBLETab: false,
                enableAudioGuide: false
            )
        )
        #else
        return AppConfig(
            apiBaseURL: URL(string: "https://api.example.com")!,
            httpTimeout: 15,
            poiCacheTTL: 300,
            iap: .init(premiumProductID: "com.travelbuddy.premium"),
            localPOIJSONName: "mock_pois_local",
            defaultRegionMeters: 4000,
            flags: .init(
                enableDebugLogs: false,
                useAlamofireClient: false,
                showBLETab: false,
                enableAudioGuide: false
            )
        )
        #endif
    }
}
//
//  AppRouter.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 9/12/25.
//


import Combine

@MainActor
public final class AppRouter: ObservableObject {
    public let events = PassthroughSubject<AppRoute, Never>()
    public init() {}
    public func send(_ route: AppRoute) { events.send(route) }
}
//
//  AppRoute.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 9/12/25.
//


import Foundation

public enum AppRoute: Equatable {
    case openPOIDetail(POI)
    case openMapWithPOI(POI.ID)
    case openSettings
}
//
//  Scalable.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/26/25.
//

import UIKit

protocol Scalable {
    var scale: Self { get }
}

extension CGFloat: Scalable {
    var scale: CGFloat {
        let designScreenWidth: CGFloat = 375
        let currentScreenWidth = UIScreen.main.bounds.size.width
        return self * currentScreenWidth / designScreenWidth
    }
   
}

extension Int {
    var scale: CGFloat {
        CGFloat(self).scale
    }
}

extension Double {
    var scale: CGFloat {
        CGFloat(self).scale
    }
}

extension CGPoint: Scalable {
    var scale: CGPoint {
        CGPoint(x: x.scale, y: y.scale)
    }
}

extension CGSize: Scalable {
    var scale: CGSize {
        CGSize(width: width.scale, height: height.scale)
    }
}

extension CGRect: Scalable {
    var scale: CGRect {
        CGRect(origin: origin.scale, size: size.scale)
    }
}

extension UIFont {
    var scale: UIFont {
        UIFont(name: fontName, size: pointSize.scale) ?? UIFont.systemFont(ofSize: pointSize.scale)
    }
}

extension UIEdgeInsets: Scalable {
    var scale: UIEdgeInsets {
        UIEdgeInsets(top: top.scale, left: left.scale, bottom: bottom.scale, right: right.scale)
    }
}
//
//  ScreenSize.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/26/25.
//


import UIKit

enum ScreenSize {
    static let bounds: CGRect = (UIScreen.main.bounds)
    static let width: CGFloat = (bounds.width)
    static let height: CGFloat = (bounds.height)
    static let maxLength: CGFloat = (max(width, height))
    static let minLength: CGFloat = (min(width, height))
    
    static let isIphone = UIDevice.current.userInterfaceIdiom == .phone
    static let isRetina = (UIScreen.main.scale >= 2.0)
    static let isIphoneXFamily = (isIphone && maxLength / minLength > 2.0)
}
//
//  UIColor+Hex.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/20/25.
//

import UIKit

public extension UIColor {
  convenience init?(hex: String) {
    var hexSanitized = hex.trimmingCharacters(in: .whitespacesAndNewlines)
    hexSanitized = hexSanitized.replacingOccurrences(of: "#", with: "")
    var rgb: UInt64 = 0
    guard Scanner(string: hexSanitized).scanHexInt64(&rgb) else { return nil }
    let r = CGFloat((rgb & 0xFF0000) >> 16) / 255
    let g = CGFloat((rgb & 0x00FF00) >> 8) / 255
    let b = CGFloat(rgb & 0x0000FF) / 255
    self.init(red: r, green: g, blue: b, alpha: 1)
  }
}
//
//  Publisher+Extensions.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/20/25.
//

import Combine

public extension Publisher {
  func logError(_ tag: String) -> AnyPublisher<Output, Failure> {
    handleEvents(receiveCompletion: { completion in
      if case let .failure(error) = completion {
          Swift.print("[\(tag)] Error:", error)
      }
    })
    .eraseToAnyPublisher()
  }
}
//
//  UserDefaults+AppStorage.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/26/25.
//

import Foundation

extension UserDefaults {
  // MARK: — Ключи
  private enum Keys {
    static let hasCompletedOnboarding = "hasCompletedOnboarding"
    // в будущем сюда можно добавлять другие ключи
  }

  // MARK: — Свойства
  var hasCompletedOnboarding: Bool {
    get { bool(forKey: Keys.hasCompletedOnboarding) }
    set { set(newValue, forKey: Keys.hasCompletedOnboarding) }
  }
}
//
//  UITabBarController+Alert.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 9/28/25.
//


import UIKit

extension UITabBarController {
    func presentAlert(title: String, message: String, okTitle: String) {
        let alert = UIAlertController(title: title, message: message, preferredStyle: .alert)
        alert.addAction(UIAlertAction(title: okTitle, style: .default))
        (selectedViewController ?? presentedViewController ?? self).present(alert, animated: true)
    }
}
//
//  AppCoordinator.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/26/25.
//

import UIKit
import SwiftUI
import Combine
import Swinject
import CoreLocation

protocol Coordinator {
    func start()
}

@MainActor
final class AppCoordinator: Coordinator {
    // MARK: - Dependencies
    private let window: UIWindow
    private let container: DIContainer

    // IAP
    private let iapObserver: IAPObserver
    private let iapService: IAPServiceProtocol

    // MARK: - UI State
    private let tabBar = UITabBarController()
    private var cancellables = Set<AnyCancellable>()

    // Навигация/роутеры, доступные из разных обработчиков
    private var appRouter: AppRouter!
    private var mapRouter: MapRouter!      // общий экземпляр для вкладки "Map"

    // MARK: - Init
    init(window: UIWindow, container: DIContainer? = nil) {
        self.window = window
        self.container = container ?? DIContainer.shared

        guard
            let observer = self.container.resolver.resolve(IAPObserver.self),
            let iapSvc   = self.container.resolver.resolve(IAPServiceProtocol.self)
        else {
            preconditionFailure("Swinject: IAPObserver/IAPServiceProtocol не зарегистрированы")
        }
        self.iapObserver = observer
        self.iapService  = iapSvc
    }

    // MARK: - Start
    func start() {
        window.makeKeyAndVisible()

        if UserDefaults.standard.hasCompletedOnboarding {
            showMainInterface()
        } else {
            showOnboarding()
        }
    }

    // MARK: - Onboarding
    private func showOnboarding() {
        guard let onboardingVM = container.resolver.resolve(AnyOnboardingViewModel.self) else {
            preconditionFailure("Swinject: AnyOnboardingViewModel не зарегистрирован")
        }

        let onboardingHost = UIHostingController(rootView: OnboardingView(vm: onboardingVM))
        window.rootViewController = onboardingHost

        onboardingVM.$hasCompletedOnboarding
            .filter { $0 }
            .first()
            .receive(on: DispatchQueue.main)
            .sink { [weak self] _ in
                self?.showMainInterface()
            }
            .store(in: &cancellables)
    }

    // MARK: - Main UI
    private func showMainInterface() {
        // AppRouter — один на все табы
        guard let appRouter = container.resolver.resolve(AppRouter.self) else {
            preconditionFailure("Swinject: AppRouter не зарегистрирован")
        }
        self.appRouter = appRouter

        // --- Places tab
        guard
            let poiListVM     = container.resolver.resolve(AnyPOIListViewModel.self),
            let poiListRouter = container.resolver.resolve(POIListRouter.self)
        else {
            preconditionFailure("Swinject: нет регистрации AnyPOIListViewModel или POIListRouter")
        }
        let poiListCoord = POIListCoordinator(viewModel: poiListVM, router: poiListRouter)
        let placesVC = UIHostingController(
            rootView: poiListCoord.rootView().environmentObject(appRouter)
        )
        placesVC.tabBarItem = UITabBarItem(title: L10n.tabPlaces, image: UIImage(systemName: "map"), tag: 0)

        // --- Map tab
        guard
            let mapVM     = container.resolver.resolve(AnyPOIMapViewModel.self),
            let mapRouter = container.resolver.resolve(MapRouter.self)
        else {
            preconditionFailure("Swinject: нет регистрации AnyPOIMapViewModel или MapRouter")
        }
        self.mapRouter = mapRouter // <— сохраняем ссылку для диплинков/роутинга
        let mapCoord = MapCoordinator(vm: mapVM, router: mapRouter)
        let mapVC = UIHostingController(
            rootView: mapCoord.rootView().environmentObject(appRouter)
        )
        mapVC.tabBarItem    = UITabBarItem(title: L10n.tabMap, image: UIImage(systemName: "map.fill"), tag: 1)
        
        // --- Settings tab
        guard let settingsVM = container.resolver.resolve(AnySettingsViewModel.self) else {
            preconditionFailure("Swinject: AnySettingsViewModel не зарегистрирован")
        }
        let settingsVC = UIHostingController(
            rootView: SettingsView(vm: settingsVM).environmentObject(appRouter)
        )
        settingsVC.tabBarItem = UITabBarItem(title: L10n.tabSettings, image: UIImage(systemName: "gearshape"), tag: 2)

        // --- Assemble
        tabBar.viewControllers = [placesVC, mapVC, settingsVC]
        window.rootViewController = tabBar

        // --- Bindings
        bindAppRouter(appRouter)
        bindDeepLinks()

        // --- IAP
        iapObserver.start()
        iapService.readCurrentPremiumEntitlement()
            .receive(on: DispatchQueue.main)
            .sink { _ in }
            .store(in: &cancellables)
    }

    // MARK: - Bind AppRouter
    private func bindAppRouter(_ appRouter: AppRouter) {
        appRouter.events
            .receive(on: DispatchQueue.main)
            .sink { [weak self] route in
                self?.handle(route)
            }
            .store(in: &cancellables)
    }

    // MARK: - Bind Deep Links
    private func bindDeepLinks() {
        guard let deeplinkService = container.resolver.resolve(DeepLinkHandling.self) else { return }

        // Успех — маршрутизируем в карту/табы
        deeplinkService
            .events
            .receive(on: DispatchQueue.main)
            .sink { [weak self] link in
                self?.handleDeepLink(link)
            }
            .store(in: &cancellables)

        // Ошибки парсинга/валидации диплинков — показываем глобальный алерт
        deeplinkService
            .errors
            .receive(on: DispatchQueue.main)
            .sink { [weak self] err in
                self?.presentDeepLinkError(err)
            }
            .store(in: &cancellables)
    }

    // MARK: - Show errors (GLOBAL)
    /// Глобальные ошибки диплинков (scheme/host/coords) — вне контекста Map-сцены.
    private func presentDeepLinkError(_ error: DeepLinkError) {
        let message: String
        switch error {
        case .unsupportedScheme:
            message = L10n.deeplinkUnsupportedScheme
        case .unknownHost:
            message = L10n.deeplinkUnknownHost
        case .invalidCoordinates:
            message = L10n.deeplinkInvalidCoords
        }

        tabBar.presentAlert(
            title: L10n.alertErrorTitle,
            message: message,
            okTitle: L10n.alertOk
        )
    }

    // MARK: - Handle AppRoute (из списков/настроек и т.п.)
    private func handle(_ route: AppRoute) {
        switch route {
        case .openPOIDetail:
            tabBar.selectedIndex = 0

        case .openMapWithPOI(let id):
            tabBar.selectedIndex = 1
            mapRouter?.focusPOI(id)

        case .openSettings:
            tabBar.selectedIndex = 2
        }
    }

    // MARK: - Handle Deep Link (SUCCESS)
    private func handleDeepLink(_ deeplink: DeepLink) {
        switch deeplink {
        case .mapCenter(let coord):
            tabBar.selectedIndex = 1
            mapRouter?.center(on: coord)

        case .poi(let id):
            tabBar.selectedIndex = 1
            // если такого POI в итоге нет — MapContainer сам покажет локализованный алерт
            // через router.showError(.poiNotFound(id)) по таймауту
            mapRouter?.focusPOI(id)
        }
    }
}
//
//  DIContainer.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/23/25.
//

import Foundation
import Swinject
import UIKit
import SwiftUI
import UserNotifications

@MainActor
public final class DIContainer {
    public static let shared = DIContainer()
    let container = Container()

    private init() {
        // 0) AppConfig —
        let config = AppConfig.makeDefault()
        container.register(AppConfig.self) { _ in config }
            .inObjectScope(.container)
      
        // DeepLink
        container.register(DeepLinkHandling.self) { _ in
            DeepLinkService()
        }.inObjectScope(.container)

        // 1) Core
        container.register(HTTPClientProtocol.self) { r in
            HTTPClient(timeout: r.resolve(AppConfig.self)!.httpTimeout)
        }.inObjectScope(.container)

        // 2) Services
        container.register(AnalyticsServiceProtocol.self) { _ in AnalyticsService() }
            .inObjectScope(.container)

        container.register(IAPServiceProtocol.self) { r in
            IAPService(config: r.resolve(AppConfig.self)!)
        }.inObjectScope(.container)

        container.register(IAPObserver.self) { r in
            IAPObserver(iap: r.resolve(IAPServiceProtocol.self)!)
        }.inObjectScope(.container)

        container.register(NotificationServiceProtocol.self) { _ in NotificationService() }
            .inObjectScope(.container)

        // 3) POI data stack
        container.register(RemotePOIService.self) { r in
            RemotePOIService(
                httpClient: r.resolve(HTTPClientProtocol.self)!,
                config: r.resolve(AppConfig.self)!
            )
        } // scope по умолчанию .graph — норм

        container.register(LocalPOIService.self) { r in
            LocalPOIService(config: r.resolve(AppConfig.self)!)
        }

        container.register(POICacheProtocol.self) { _ in RealmPOICache() }

        container.register(POIServiceProtocol.self) { r in
            POIRepository(
                remote: r.resolve(RemotePOIService.self)!,
                local:  r.resolve(LocalPOIService.self)!,
                cache:  r.resolve(POICacheProtocol.self)!,
                ttl:    r.resolve(AppConfig.self)!.poiCacheTTL
            )
        }.inObjectScope(.container)

        // 4) Onboarding
        container.register((any OnboardingViewModelProtocol).self) { _ in OnboardingViewModel() }
        container.register(AnyOnboardingViewModel.self) { r in
            AnyOnboardingViewModel(r.resolve((any OnboardingViewModelProtocol).self)!)
        }.inObjectScope(.graph)

        // 5) POIList scene
        container.register((any POIListViewModelProtocol).self) { r in
            POIListViewModel(repository: r.resolve(POIServiceProtocol.self)!)
        }.inObjectScope(.graph)

        container.register(AnyPOIListViewModel.self) { r in
            AnyPOIListViewModel(r.resolve((any POIListViewModelProtocol).self)!)
        }.inObjectScope(.graph)

        container.register(POIListRouter.self) { _ in POIListRouter() }
            .inObjectScope(.graph)

        // 6) Map scene
        container.register((any POIMapViewModelProtocol).self) { r in
            POIMapViewModel(
                service: r.resolve(POIServiceProtocol.self)!,
                factory: DefaultAnnotationFactory()
            )
        }.inObjectScope(.graph)

        container.register(AnyPOIMapViewModel.self) { r in
            AnyPOIMapViewModel(r.resolve((any POIMapViewModelProtocol).self)!)
        }.inObjectScope(.graph)

        container.register(MapRouter.self) { _ in MapRouter() }
            .inObjectScope(.graph)

        // 7) Settings scene
        container.register((any SettingsViewModelProtocol).self) { r in
            SettingsViewModel(
                iapService:   r.resolve(IAPServiceProtocol.self)!,
                analytics:    r.resolve(AnalyticsServiceProtocol.self)!,
                notification: r.resolve(NotificationServiceProtocol.self)!,
                push:         r.resolve(PushServiceProtocol.self) // <— передали зависимость
            )
        }
        .inObjectScope(.graph)


        container.register(AnySettingsViewModel.self) { r in
            AnySettingsViewModel(r.resolve((any SettingsViewModelProtocol).self)!)
        }.inObjectScope(.graph)

        // 8) AppRouter и Detail
        container.register(AppRouter.self) { _ in AppRouter() }
            .inObjectScope(.container)

        container.register(POIDetailViewModel.self) { _, poi in
            POIDetailViewModel(poi: poi)
        }
        container.register(POIDetailCoordinator.self) { r, poi in
            POIDetailCoordinator(poi: poi, resolver: r)
        }.inObjectScope(.graph)
        
        //MARK: Push
        container.register(PushServiceProtocol.self) { _ in
            PushService()
        }
        .inObjectScope(.container)

        container.registerUITestOverridesIfNeeded()

    }

    public var resolver: Resolver { container.synchronize() }
}

@MainActor
private extension Container {
    /// Вызывать ПОСЛЕ базовых регистраций, чтобы в режиме UI-тестов переопределить сервисы.
    func registerUITestOverridesIfNeeded() {
        let useLocalOnly = AppFlags.isUITesting || AppFlags.useMockData
        guard useLocalOnly else { return }

        // Локальный сервис вместо сети/кэша
        self.register(POIServiceProtocol.self) { r in
            // Если у тебя LocalPOIService требует конфиг — разрезолвим его
            let config = r.resolve(AppConfig.self)!
            return LocalPOIService(config: config)
        }
        .inObjectScope(.container)

        
        self.register(PushServiceProtocol.self) { _ in
            NoopPushService()
        }
        .inObjectScope(.container)

    }
}
//
//  AppDelegate.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/19/25.
//

import UIKit
import UserNotifications

@main
class AppDelegate: UIResponder, UIApplicationDelegate {
    var pushService: PushServiceProtocol?

    func application(_ application: UIApplication,
                     didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {

        // resolve
        pushService = DIContainer.shared.resolver.resolve(PushServiceProtocol.self)

        // назначаем делегата и регистрируем категории ТУТ
        if let svc = pushService as? UNUserNotificationCenterDelegate {
            UNUserNotificationCenter.current().delegate = svc
        }
        pushService?.registerCategories()

        return true
    }

    func application(_ application: UIApplication,
                     didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
        pushService?.setDeviceToken(deviceToken)
    }

    func application(_ application: UIApplication,
                     didFailToRegisterForRemoteNotificationsWithError error: Error) {
        print("APNs registration failed:", error)
    }
}
//
//  AppFlags.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 10/04/25.
//

import Foundation

/// Флаги, которые управляют режимом работы приложения (например, UI-тесты, мок-данные и т.п.)
enum AppFlags {
    static var isUITesting: Bool {
        ProcessInfo.processInfo.arguments.contains("-uiTesting")
    }

    static var useMockData: Bool {
        ProcessInfo.processInfo.arguments.contains("-uiMockData")
    }
}
//
//  DeepLinkParser.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/17/25.
//


import CoreLocation

public enum DeepLink {
    case mapCenter(CLLocationCoordinate2D)
    case poi(id: Int)
}

public enum DeepLinkError: Error {
    case unsupportedScheme
    case unknownHost
    case invalidCoordinates
}



public struct DeepLinkParser {
    public init() {}

    public func parse(url: URL) -> Result<DeepLink, DeepLinkError> {
        let scheme = url.scheme?.lowercased()
        if scheme == "travelbuddy" {
            return parseCustomScheme(url)
        }
        return .failure(.unsupportedScheme)
    }

    private func parseCustomScheme(_ url: URL) -> Result<DeepLink, DeepLinkError> {
        switch url.host?.lowercased() {
        case "map":
            return parseMap(url)
        case "poi":
            guard let id = Int(url.lastPathComponent) else {
                return .failure(.unknownHost)
            }
            return .success(.poi(id: id))
        default:
            return .failure(.unknownHost)
        }
    }

    private func parseMap(_ url: URL) -> Result<DeepLink, DeepLinkError> {
        guard
            let comps = URLComponents(url: url, resolvingAgainstBaseURL: false),
            let latStr = comps.queryItems?.first(where: { $0.name == "lat" })?.value,
            let lonStr = comps.queryItems?.first(where: { $0.name == "lon" })?.value,
            let lat = Double(latStr),
            let lon = Double(lonStr)
        else {
            return .failure(.invalidCoordinates)
        }
        return .success(.mapCenter(.init(latitude: lat, longitude: lon)))
    }
}
//
//  DeepLinkService.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/7/25.
//

import Foundation
import CoreLocation
import Combine

public protocol DeepLinkHandling {
    func handle(url: URL)
    var events: AnyPublisher<DeepLink, Never> { get }
    var errors: AnyPublisher<DeepLinkError, Never> { get }
}

public final class DeepLinkService: DeepLinkHandling {
    private let parser = DeepLinkParser()

    private let successSubject = CurrentValueSubject<DeepLink?, Never>(nil)
    private let errorSubject = PassthroughSubject<DeepLinkError, Never>()

    public init() {}

    public func handle(url: URL) {
        switch parser.parse(url: url) {
        case .success(let dl):
            successSubject.value = dl
        case .failure(let err):
            errorSubject.send(err)
        }
    }

    public var events: AnyPublisher<DeepLink, Never> {
        successSubject.compactMap { $0 }.eraseToAnyPublisher()
    }

    public var errors: AnyPublisher<DeepLinkError, Never> {
        errorSubject.eraseToAnyPublisher()
    }
}
//
//  SceneDelegate.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/19/25.
//

import UIKit

class SceneDelegate: UIResponder, UIWindowSceneDelegate {
    var window: UIWindow?
    var coordinator: AppCoordinator?

    func scene(_ scene: UIScene,
               willConnectTo session: UISceneSession,
               options connectionOptions: UIScene.ConnectionOptions) {
        guard let ws = (scene as? UIWindowScene) else { return }
        let window = UIWindow(windowScene: ws)
        self.window = window

        coordinator = AppCoordinator(window: window)
        coordinator?.start()

        // 🔗 обрабатываем диплинк при холодном старте
        if let url = connectionOptions.urlContexts.first?.url {
            DIContainer.shared.resolver
                .resolve(DeepLinkHandling.self)?
                .handle(url: url)
        }
    }

    // 🔗 диплинки в уже запущенное приложение
    func scene(_ scene: UIScene, openURLContexts URLContexts: Set<UIOpenURLContext>) {
        guard let url = URLContexts.first?.url else { return }
        DIContainer.shared.resolver
            .resolve(DeepLinkHandling.self)?
            .handle(url: url)
    }
}


# 🧭 TravelBuddy

iOS-приложение с картой, списком точек интереса и экраном настроек.  
Проект демонстрирует архитектуру с чётким разделением слоёв, реактивный UI и интеграцию системных фреймворков iOS.

---

## Архитектура

TravelBuddy построен по принципам **Clean Architecture** и **MVVM** с внедрением зависимостей через **Swinject**.  
Потоки данных однонаправленные (Combine + async/await).  
Навигация управляется координаторами, а бизнес-логика отделена от инфраструктуры.

App/
├─ Presentation/ → View + ViewModel (Combine/async, Router/Coordinator)
├─ Domain/ → контракты и модели (чистая логика)
├─ Infrastructure/ → реализация контрактов (сеть, кэш, IAP, Push, Analytics)
├─ Core/ → утилиты, DesignTokens, L10n, экстеншены
└─ Resources/ → локализация, моки, ассеты


### Поток данных
User → View → ViewModel → UseCase/Repository → Data Source → ViewModel (state) → View


### Domain и Infrastructure

- **Domain** описывает *что нужно сделать* — контракты (`POIServiceProtocol`, `POICacheProtocol`) и модели (`POI`, `POICategoryFilter`, `OnboardingPage`).
- **Infrastructure** реализует *как это делается* — `HTTPClient`, `RemotePOIService`, `LocalPOIService`, `POIRepository`, `RealmPOICache`, `IAPService`, `NotificationService`, `AnalyticsService`.

`POIRepository` объединяет источники и реализует политику:
- cache-then-refresh;
- TTL для «свежести» данных;
- дедупликацию параллельных запросов.

---

## Навигация и координаторы

- Корневой `AppCoordinator` создаёт таб-интерфейс: **Places**, **Map**, **Settings**.  
- Для каждой вкладки — свой координатор (`POIListCoordinator`, `MapCoordinator`, `SettingsCoordinator`).
- Навигационные команды передаются через Router (Combine-publisher), ViewModel не знает о UIKit.

---

## Данные и кэш

HTTPClient (URLSession)
↓
RemotePOIService / LocalPOIService
↓
POIRepository (TTL, cache-then-refresh, dedup)
↓
RealmPOICache


Кэширование выполняется локально через Realm, отметка свежести хранится в `UserDefaults`.

---

## Основные модули

### Map
SwiftUI + `MapViewRepresentable` (мост на MKMapView).  
Поддерживает аннотации, кластеризацию, переход к деталям и диплинки с координатами.

### POI List
Список точек с фильтрацией по категориям.  
Работает через `POIListViewModel` и `POIRepository`.  
Переход в деталь — через `POIListRouter`.

### POI Detail
Показ информации о месте, открытие в Apple Maps, шаринг, обработка ошибок.

### Settings
Настройки темы, уведомлений и Premium-доступа (StoreKit 2).  
Реализованы:
- запрос разрешения на уведомления (`UNUserNotificationCenter`),
- наблюдение транзакций и покупок (`IAPService`, `IAPObserver`),
- состояние Premium.

---

## Диплинки

Поддерживаются ссылки:
- `travelbuddy://map?lat=<lat>&lon=<lon>` — центрировать карту;
- `travelbuddy://poi/<id>` — открыть деталь точки.

Парсинг выполняет `DeepLinkParser`, бизнес-обработка — `DeepLinkService`.  
Работает при холодном и горячем запуске приложения.

### Центр карты
- `travelbuddy://map?lat=48.8584&lon=2.2945` — центр на Eiffel Tower  
- `travelbuddy://map?lat=48.8606&lon=2.3376` — центр на Louvre Museum  
- `travelbuddy://map?lat=48.8867&lon=2.3431` — центр на Sacré-Cœur Basilica  

### Открыть POI
- `travelbuddy://poi/1` — Eiffel Tower (Monument)  
- `travelbuddy://poi/2` — Louvre Museum (Museum)  
- `travelbuddy://poi/3` — Cafe de Flore (Cafe)  
- `travelbuddy://poi/18` — Café Marly (последний элемент списка)  

### Невалидные
- `travelbuddy://poi/999` — несуществующий POI  
- `travelbuddy://map?lat=abc&lon=123` — некорректные координаты  
- `travelbuddy://unknown` — неизвестный хост  


---

## Локализация и дизайн

- **L10n** — типобезопасный хелпер для `NSLocalizedString`, поддерживает формат с параметрами.  
- **DesignTokens** — цвета, шрифты и отступы с учётом Dark Mode и масштабирования.

---

## Тесты и CI

- **UI Snapshot-тесты**: `TravelBuddySnapshotUITests` с `SnapshotHelper.swift` (Onboarding → Places → Detail → Map → Settings).  
- **UI Launch-тесты**: `TravelBuddyUITests`, `TravelBuddyUITestsLaunchTests`.  
- **CI**: GitHub Actions — сборка, юнит-тесты, снапшоты через fastlane.

Базовое покрытие тестами ≈ 28 %. Критичные модули (Repository, ViewModel) — до 60 %.

---

## Фича-флаги

Настраиваются в `AppConfig.makeDefault()`:

| Флаг | Назначение | По умолчанию |
|------|-------------|--------------|
| `enableDebugLogs` | логирование отладочных событий | false |
| `useAlamofireClient` | альтернативный сетевой клиент (POC) | false |
| `showBLETab` | вкладка со сканером BLE-устройств | false |
| `enableAudioGuide` | экспериментальный аудиогид (AVFoundation) | false |

---

## Запуск проекта

1. Открыть `TravelBuddy.xcodeproj` в Xcode 15+.
2. Выбрать схему **TravelBuddy**, запустить на симуляторе.
3. Для проверки диплинков:  
   `xcrun simctl openurl booted "travelbuddy://map?lat=55.75&lon=37.61"`
4. Чтобы пересмотреть онбординг — удалить приложение или сбросить ключ `hasCompletedOnboarding` в `UserDefaults`.

---

## Структура проекта

TravelBuddy/
├─ App/
│ ├─ AppCoordinator, AppRouter, SceneDelegate, AppDelegate
│ ├─ DeepLinkService / DeepLinkParser
│ ├─ DIContainer (Swinject)
│ └─ AppConfig
│
├─ Presentation/
│ ├─ POIList/
│ ├─ POIDetail/
│ ├─ POIMap/
│ ├─ Onboarding/
│ ├─ Settings/
│ ├─ MapContainer / MapViewRepresentable
│ └─ общие компоненты UI
│
├─ Domain/
│ ├─ POI.swift
│ ├─ POICategoryFilter.swift
│ ├─ POIServiceProtocol.swift
│ └─ POICacheProtocol.swift
│
├─ Infrastructure/
│ ├─ HTTPClient.swift
│ ├─ RemotePOIService.swift / LocalPOIService.swift
│ ├─ POIRepository.swift / RealmPOICache.swift
│ ├─ IAPService.swift / IAPObserver.swift
│ ├─ NotificationService.swift / AnalyticsService.swift
│ └─ вспомогательные источники данных
│
├─ Core/
│ ├─ DesignTokens.swift
│ ├─ L10n.swift
│ └─ расширения и утилиты
│
├─ Resources/
│ ├─ Localizable.strings
│ ├─ Assets.xcassets
│ └─ Mocks/
│
└─ Tests/
├─ TravelBuddySnapshotUITests/
├─ TravelBuddyUITests/
└─ SnapshotHelper.swift


---

## Автор

**Niiaz Khasanov**  
iOS Developer  
Swift 5 | Combine | SwiftUI | UIKit | Swinject | Clean Architecture  
//
//  HTTPClient.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/28/25.
//

// Infrastructure/Networking/HTTPClient.swift
import Foundation
import Combine

public final class HTTPClient: HTTPClientProtocol {
    private let timeout: TimeInterval
    private let decoder: JSONDecoder

    public init(timeout: TimeInterval = 15,
                decoder: JSONDecoder = .init()) {
        self.timeout = timeout
        self.decoder = decoder
    }

    public func send<T: Decodable>(_ requestIn: URLRequest) -> AnyPublisher<T, Error> {
        var request = requestIn
        // если у запроса не задан таймаут – подставим дефолт из клиента
        if request.timeoutInterval == 0 {
            request.timeoutInterval = timeout
        }

        return URLSession.shared.dataTaskPublisher(for: request)
            .tryMap { output -> Data in
                // маппим network-ошибки и статусы
                if let http = output.response as? HTTPURLResponse,
                   !(200...299).contains(http.statusCode) {
                    throw URLError(.badServerResponse)
                }
                return output.data
            }
            .decode(type: T.self, decoder: decoder)
            .eraseToAnyPublisher()
    }
}
//
//  HTTPClientProtocol.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/20/25.
//


import Foundation
import Combine

public protocol HTTPClientProtocol {
  func send<T: Decodable>(_ request: URLRequest) -> AnyPublisher<T, Error>
}

//
//  POIRepository.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/1/25.
//


import Combine
import Foundation

public final class POIRepository: POIServiceProtocol {
    private let remote: POIServiceProtocol
    private let local: POIServiceProtocol
    private let cache: POICacheProtocol
    private let ttl: TimeInterval

    // in-flight общий publisher для дедупликации конкурентных запросов
    private let stateQueue = DispatchQueue(label: "poi.repo.state")
    private var inFlight: AnyPublisher<[POI], Error>?

    // хранение времени последнего успешного remote save (не меняем протокол кэша)
    private let lastRefreshKey = "poi.cache.lastRefreshAt"

    public init(remote: POIServiceProtocol,
                 local: POIServiceProtocol,
                 cache: POICacheProtocol,
                 ttl: TimeInterval) {
         self.remote = remote
         self.local  = local
         self.cache  = cache
         self.ttl    = ttl
     }

    public func fetchPOIs() -> AnyPublisher<[POI], Error> {
        let cached = loadCacheAsync()

        // если кэш свежий — отдаём его и выходим
        if isFresh() {
            return cached
        }

        // иначе: сразу отдаём содержимое кэша (если есть) и затем — обновление из сети
        // (если in-flight уже идёт — переиспользуем)
        let refresh = remoteOnceShared()
            .catch { [weak self] _ -> AnyPublisher<[POI], Error> in
                guard let self else {
                    return Fail(error: URLError(.unknown)).eraseToAnyPublisher()
                }
                // fallback: локальный JSON (и одновременно обновим кэш)
                return self.local.fetchPOIs()
                    .handleEvents(receiveOutput: { [weak self] pois in
                        self?.saveToCache(pois)
                    })
                    .eraseToAnyPublisher()
            }

        // cacheThenRefresh: сначала кэш, затем сеть
        return cached
            .filter { !$0.isEmpty }
            .append(refresh)
            .eraseToAnyPublisher()
    }

    // MARK: - Helpers

    private func loadCacheAsync() -> AnyPublisher<[POI], Error> {
        Deferred {
            Future<[POI], Error> { [weak self] promise in
                guard let self else {
                    promise(.failure(URLError(.unknown))); return
                }
                DispatchQueue.global(qos: .userInitiated).async {
                    let pois = self.cache.load()
                    promise(.success(pois))
                }
            }
        }
        .eraseToAnyPublisher()
    }

    private func remoteOnceShared() -> AnyPublisher<[POI], Error> {
        // 1) если уже есть общий in-flight, вернём его
        if let shared = stateQueue.sync(execute: { inFlight }) {
            return shared
        }

        // 2) создаём новый, сохраняем в inFlight и шарим
        let publisher = remote.fetchPOIs()
            .handleEvents(receiveOutput: { [weak self] pois in
                self?.saveToCache(pois)
                self?.setLastRefresh(Date())
            }, receiveCompletion: { [weak self] _ in
                self?.stateQueue.async { self?.inFlight = nil }
            }, receiveCancel: { [weak self] in
                self?.stateQueue.async { self?.inFlight = nil }
            })
            .share()
            .eraseToAnyPublisher()

        stateQueue.async { [weak self] in self?.inFlight = publisher }
        return publisher
    }

    private func saveToCache(_ pois: [POI]) {
        // запись синхронная внутри реализаций; если будет дисковая — они уже у тебя в autoreleasepool
        cache.save(pois)
    }

    // MARK: - TTL

    private func isFresh(now: Date = Date()) -> Bool {
        guard let last = getLastRefresh() else { return false }
        return now.timeIntervalSince(last) < ttl
    }

    private func getLastRefresh() -> Date? {
        let t = UserDefaults.standard.double(forKey: lastRefreshKey)
        return t > 0 ? Date(timeIntervalSince1970: t) : nil
    }

    private func setLastRefresh(_ date: Date) {
        UserDefaults.standard.set(date.timeIntervalSince1970, forKey: lastRefreshKey)
    }
}
//
//  RealmPOICache.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/30/25.
//

import Foundation
import RealmSwift

public final class RealmPOICache: POICacheProtocol {
    public func save(_ pois: [POI]) {
        autoreleasepool {
            do {
                let realm = try Realm()
                let objects = pois.map { RealmPOI(poi: $0) }
                try realm.write { realm.add(objects, update: .modified) }
            } catch { /* лог при желании */ }
        }
    }

    public func load() -> [POI] {
        autoreleasepool {
            (try? Realm()).map { Array($0.objects(RealmPOI.self)).map { $0.toPOI() } } ?? []
        }
    }
}

public final class RealmPOI: Object {
    @objc dynamic var id = 0
    @objc dynamic var name = ""
    @objc dynamic var latitude = 0.0
    @objc dynamic var longitude = 0.0
    @objc dynamic var category: String? = nil
    @objc dynamic var descriptionText: String? = nil
    @objc dynamic var imageURLString: String? = nil

    public override static func primaryKey() -> String? { "id" }

    convenience init(poi: POI) {
        self.init()
        id = poi.id; name = poi.name
        latitude = poi.latitude; longitude = poi.longitude
        category = poi.category
        descriptionText = poi.description
        imageURLString = poi.imageURL?.absoluteString
    }

    func toPOI() -> POI {
        POI(
          id: id, name: name,
          latitude: latitude, longitude: longitude,
          category: category,
          description: descriptionText,
          imageURL: imageURLString.flatMap(URL.init)
        )
    }
}

//
//  RemotePOIService.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/28/25.
//

import Foundation
import Combine

public final class RemotePOIService: POIServiceProtocol {
    private let httpClient: HTTPClientProtocol
    private let baseURL: URL

    public init(httpClient: HTTPClientProtocol, config: AppConfig) {
        self.httpClient = httpClient
        self.baseURL = config.apiBaseURL
    }

    public func fetchPOIs() -> AnyPublisher<[POI], Error> {
        let url = baseURL.appendingPathComponent("pois")
        return httpClient.send(URLRequest(url: url))
    }
}
//
//  LocalPOIService.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/28/25.
//

import Foundation
import Combine

public final class LocalPOIService: POIServiceProtocol {
    private let jsonName: String
    
    public init(config: AppConfig) {
        self.jsonName = config.localPOIJSONName
    }
    
    
    public func fetchPOIs() -> AnyPublisher<[POI], Error> {
        Deferred {
            Future<[POI], Error> { promise in
                DispatchQueue.global(qos: .background).async {
                    do {
                        guard let url = Bundle.main.url(forResource: self.jsonName, withExtension: "json") else {
                            promise(.failure(URLError(.fileDoesNotExist)))
                            return
                        }
                        let data = try Data(contentsOf: url)
                        let pois = try JSONDecoder().decode([POI].self, from: data)
                        //Thread.sleep(forTimeInterval: 0)
                        promise(.success(pois))
                    } catch {
                        promise(.failure(error))
                    }
                }
            }
        }
        .eraseToAnyPublisher()
    }
}
//
//  PushService.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 10/6/25.
//


import UIKit
import UserNotifications

@MainActor
public final class PushService: NSObject, PushServiceProtocol {
    private let center = UNUserNotificationCenter.current()
    private(set) public var apnsDeviceTokenHex: String?
    public var presentInForeground: Bool = true

    // MARK: Permissions

    public func getPermissionStatus() async -> PushPermissionStatus {
        let settings = await center.notificationSettings()
        switch settings.authorizationStatus {
        case .notDetermined: return .notDetermined
        case .denied:        return .denied
        case .authorized:    return .authorized
        case .provisional:   return .provisional
        case .ephemeral:     return .ephemeral
        @unknown default:    return .notDetermined
        }
    }

    public func requestPermission(options: PushOptions) async -> Bool {
        let opts: UNAuthorizationOptions = [
            options.contains(.alert) ? .alert : [],
            options.contains(.badge) ? .badge : [],
            options.contains(.sound) ? .sound : []
        ].reduce([] as UNAuthorizationOptions) { $0.union($1) }

        do {
            let granted = try await center.requestAuthorization(options: opts)
            await MainActor.run {
                UIApplication.shared.registerForRemoteNotifications()
            }
            return granted
        } catch {
            return false
        }
    }

    // MARK: APNs

    public func registerForRemoteNotifications() {
        UIApplication.shared.registerForRemoteNotifications()
    }

    public func setDeviceToken(_ token: Data) {
        let hex = token.map { String(format: "%02x", $0) }.joined()
        apnsDeviceTokenHex = hex
        // TODO: отправь hex на бэкенд/в FCM при необходимости
        print("APNs token:", hex)
    }

    // MARK: Local

    public func scheduleLocal(title: String, body: String, after seconds: TimeInterval) async throws {
        let content = UNMutableNotificationContent()
        content.title = title
        content.body  = body
        content.sound = .default
        content.categoryIdentifier = PushCategoryFactory.defaultCategoryId

        let trigger = UNTimeIntervalNotificationTrigger(timeInterval: max(0.1, seconds), repeats: false)
        let req = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)
        try await center.add(req)
    }

    // MARK: Categories

    public func registerCategories() {
        center.setNotificationCategories(PushCategoryFactory.makeAll())
    }
}

// MARK: - UNUserNotificationCenterDelegate

extension PushService: UNUserNotificationCenterDelegate {
    public func userNotificationCenter(_ center: UNUserNotificationCenter,
                                       willPresent notification: UNNotification,
                                       withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) {
        completionHandler(presentInForeground ? [.banner, .list, .sound] : [])
    }

    public func userNotificationCenter(_ center: UNUserNotificationCenter,
                                       didReceive response: UNNotificationResponse,
                                       withCompletionHandler completionHandler: @escaping () -> Void) {
        // 1) Пробуем извлечь deep link из payload
        if let url = PushPayload.deeplink(from: response.notification.request.content.userInfo) {
            // 2) Передаём в ТВОЙ DeepLinkService (через DI)
            DIContainer.shared.resolver
                .resolve(DeepLinkHandling.self)?
                .handle(url: url)
        }
        completionHandler()
    }
}
//
//  PushCategoryFactory.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 10/6/25.
//


import UserNotifications

public enum PushCategoryFactory {
    public static let defaultCategoryId = "APP_DEFAULT"

    public static func makeAll() -> Set<UNNotificationCategory> {
        let open = UNNotificationAction(
            identifier: "OPEN_APP",
            title: "Open",
            options: [.foreground]
        )
        let cat = UNNotificationCategory(
            identifier: defaultCategoryId,
            actions: [open],
            intentIdentifiers: [],
            options: []
        )
        return [cat]
    }
}
//
//  NoopPushService.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 10/6/25.
//



import Foundation

@MainActor
final class NoopPushService: PushServiceProtocol {
    var apnsDeviceTokenHex: String? = nil
    var presentInForeground: Bool = false

    func getPermissionStatus() async -> PushPermissionStatus { .denied }
    func requestPermission(options: PushOptions) async -> Bool { false }
    func registerForRemoteNotifications() {}
    func setDeviceToken(_ token: Data) {}
    func scheduleLocal(title: String, body: String, after seconds: TimeInterval) async throws {}
    func registerCategories() {}
}
//
//  PushPayload.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 10/6/25.
//

import Foundation

enum PushPayload {
    /// Ожидаем кастомное поле "deeplink": "travelbuddy://poi/123"
    static func deeplink(from userInfo: [AnyHashable: Any]) -> URL? {
        guard
            let raw = userInfo["deeplink"] as? String,
            let url = URL(string: raw),
            url.scheme?.lowercased() == "travelbuddy"
        else { return nil }
        return url
    }
}
//
//  PushPermissionStatus.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 10/6/25.
//


import Foundation

public enum PushPermissionStatus {
    case notDetermined, denied, authorized, provisional, ephemeral
}

public struct PushOptions: OptionSet {
    public let rawValue: Int
    public static let alert = PushOptions(rawValue: 1 << 0)
    public static let badge = PushOptions(rawValue: 1 << 1)
    public static let sound = PushOptions(rawValue: 1 << 2)
    public init(rawValue: Int) { self.rawValue = rawValue }
    public static let all: PushOptions = [.alert, .badge, .sound]
}
@MainActor
public protocol PushServiceProtocol: AnyObject {
    // Permissions
    func getPermissionStatus() async -> PushPermissionStatus
    func requestPermission(options: PushOptions) async -> Bool

    // APNs
    func registerForRemoteNotifications()
    func setDeviceToken(_ token: Data)
    var apnsDeviceTokenHex: String? { get }

    // Local notifications (для теста без бэка)
    func scheduleLocal(title: String, body: String, after seconds: TimeInterval) async throws

    // Categories / Actions
    func registerCategories()

    // Foreground presentation
    var presentInForeground: Bool { get set }
}
//
//  NotificationServiceProtocol.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/28/25.
//


import UserNotifications
import Combine

public protocol NotificationServiceProtocol {
  func requestAuthorization() -> AnyPublisher<Bool, Never>
  func schedule(_ content: UNNotificationContent, at date: Date)
}
//
//  NotificationService.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/20/25.
//


import UserNotifications
import Combine


public final class NotificationService: NotificationServiceProtocol {
  public init() {}

  public func requestAuthorization() -> AnyPublisher<Bool, Never> {
    Future { promise in
      UNUserNotificationCenter.current()
        .requestAuthorization(options: [.alert, .sound]) { granted, _ in
          promise(.success(granted))
        }
    }
    .eraseToAnyPublisher()
  }

  public func schedule(_ content: UNNotificationContent, at date: Date) {
    let interval = max(1, date.timeIntervalSinceNow)
    let trigger = UNTimeIntervalNotificationTrigger(timeInterval: interval, repeats: false)
    let req = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)
    UNUserNotificationCenter.current().add(req)
  }
}
//
//  IAPObserver.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 9/17/25.
//


import StoreKit
import Combine

extension Notification.Name {
  static let iapEntitlementsChanged = Notification.Name("iapEntitlementsChanged")
}

public final class IAPObserver {
  private let iap: IAPServiceProtocol
  private var task: Task<Void, Never>?

  public init(iap: IAPServiceProtocol) { self.iap = iap }

  public func start() {
    guard task == nil else { return }
    task = Task.detached { [weak self] in
      await self?.observeTransactions()
    }
  }

  public func stop() { task?.cancel(); task = nil }
  deinit { stop() }

  private func observeTransactions() async {
    for await update in Transaction.updates {
      do {
        let tx: Transaction = try iap.verify(update)
        // выдаю право пользователю на использование
        await tx.finish()
        // сообщим UI, что энтитлменты могли измениться
        NotificationCenter.default.post(name: .iapEntitlementsChanged, object: nil)
      } catch {
        // опционально: лог/метрики
      }
    }
  }
}
//
//  IAPServiceProtocol.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/28/25.
//



import StoreKit
import Combine


public protocol IAPServiceProtocol {
  func fetchProducts() -> AnyPublisher<[Product], Error>
  func purchase(_ product: Product) -> AnyPublisher<Transaction, Error>
  func verify<T>(_ result: VerificationResult<T>) throws -> T
  func readCurrentPremiumEntitlement() -> AnyPublisher<Bool, Never>
}
//
//  IAPService.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/20/25.
//


import StoreKit
import Combine

public final class IAPService: IAPServiceProtocol {
    private let productID: String
    public init(config: AppConfig) {
        self.productID = config.iap.premiumProductID
    }
    
    public func fetchProducts() -> AnyPublisher<[Product], Error> {
        Deferred {
            Future { promise in
                Task {
                    do {
                        let ids: Set<String> = [self.productID]
                        let products = try await Product.products(for: ids)
                        promise(.success(products))
                    } catch { promise(.failure(error)) }
                }
            }
        }
        .eraseToAnyPublisher()
    }
    
    public func purchase(_ product: Product) -> AnyPublisher<Transaction, Error> {
        Deferred {
            Future { promise in
                Task {
                    do {
                        let result = try await product.purchase()
                        switch result {
                        case .success(let verification):
                            let tx: Transaction = try self.verify(verification)
                            await tx.finish()
                            promise(.success(tx))
                        case .userCancelled:
                            let err = NSError(domain: "IAP", code: NSUserCancelledError,
                                              userInfo: [NSLocalizedDescriptionKey: "Purchase cancelled"])
                            promise(.failure(err))
                        case .pending:
                            let err = NSError(domain: "IAP", code: -1,
                                              userInfo: [NSLocalizedDescriptionKey: "Purchase pending"])
                            promise(.failure(err))
                        @unknown default:
                            let err = NSError(domain: "IAP", code: -2,
                                              userInfo: [NSLocalizedDescriptionKey: "Unknown purchase result"])
                            promise(.failure(err))
                        }
                    } catch { promise(.failure(error)) }
                }
            }
        }
        .eraseToAnyPublisher()
    }
    
    // MARK: - NEW
    public func verify<T>(_ result: VerificationResult<T>) throws -> T {
        switch result {
        case .verified(let safe): return safe
        case .unverified(_, let error): throw error
        }
    }
    
    public func readCurrentPremiumEntitlement() -> AnyPublisher<Bool, Never> {
        Deferred {
            Future<Bool, Never> { promise in
                Task {
                    var hasPremium = false
                    for await entitlement in Transaction.currentEntitlements {
                        if case .verified(let tx) = entitlement,
                           tx.productID == self.productID {
                            hasPremium = true
                            break
                        }
                    }
                    promise(.success(hasPremium))
                }
            }
        }
        .eraseToAnyPublisher()
    }
}
//
//  AnalyticsServiceProtocol.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/28/25.
//


import Foundation

public protocol AnalyticsServiceProtocol {
  func logEvent(name: String, parameters: [String: Any]?)
  func recordError(_ error: Error)
}
//
//  AnalyticsService.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/20/25.
//

import FirebaseAnalytics
import FirebaseCrashlytics


public final class AnalyticsService: AnalyticsServiceProtocol {
  public init() {}
  public func logEvent(name: String, parameters: [String: Any]?) {
    Analytics.logEvent(name, parameters: parameters)
  }
  public func recordError(_ error: Error) {
    Crashlytics.crashlytics().record(error: error)
  }
}
//
//  POICategoryFilter.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/1/25.
//


import Foundation

public enum POICategoryFilter: String, CaseIterable, Identifiable {
    case all = "All", monument = "Monument", museum = "Museum", cafe = "Cafe"
    public var id: String { rawValue }
}

public extension POICategoryFilter {
    var localizedTitle: String {
        switch self {
        case .all: return L10n.catAll
        case .monument: return L10n.catMonument
        case .museum: return L10n.catMuseum
        case .cafe: return L10n.catCafe
        }
    }
}
//
//  POI.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/20/25.
//

import Foundation

public struct POI: Identifiable, Decodable, Hashable {
    public let id: Int
    public let name: String
    public let latitude: Double
    public let longitude: Double
    public let category: String?
    public let description: String?
    public let imageURL: URL?
}
//
//  POIServiceProtocol.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/11/25.
//


import Foundation
import Combine

public protocol POIServiceProtocol {
  func fetchPOIs() -> AnyPublisher<[POI], Error>
}//
//  POICacheProtocol.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/28/25.
//


import Foundation

public protocol POICacheProtocol: AnyObject {
    func save(_ pois: [POI])
    func load() -> [POI]
}
//
//  SettingsView.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/23/25.
//

import SwiftUI

public struct SettingsView<VM: SettingsViewModelProtocol>: View {
    @ObservedObject private var vm: VM

    public init(vm: VM) { self.vm = vm }

    public var body: some View {
        NavigationView {
            Form {
                // MARK: - Appearance
                Section {
                    Toggle(L10n.settingsDarkMode, isOn: Binding(
                        get:  { vm.isDarkMode },
                        set:  { vm.setDarkMode($0) }
                    ))
                    .accessibilityIdentifier("settings.darkmode.toggle")
                }

                // MARK: - Local Notifications (как было)
                Section {
                    Toggle(L10n.settingsNotifications, isOn: Binding(
                        get:  { vm.notificationsEnabled },
                        set:  { vm.setNotifications($0) }
                    ))
                    .accessibilityIdentifier("settings.notifications.toggle")
                }

                // MARK: - APNs / Push (НОВОЕ)
                Section(header: Text("Push Notifications")) {
                    HStack {
                        Text("Permission")
                        Spacer()
                        Text(vm.pushPermissionText).foregroundStyle(.secondary)
                    }

                    Toggle("Show banner in Foreground", isOn: Binding(
                        get: { vm.presentInForeground },
                        set: { vm.setPresentInForeground($0) }
                    ))

                    if let token = vm.apnsToken, !token.isEmpty {
                        VStack(alignment: .leading, spacing: 6) {
                            Text("APNs Device Token")
                                .font(.subheadline.weight(.semibold))
                            Text(token)
                                .font(.footnote)
                                .textSelection(.enabled)
                                .lineLimit(3)
                        }
                        .padding(.vertical, 4)
                    } else {
                        Text("APNs token is not available yet.")
                            .foregroundStyle(.secondary)
                            .font(.footnote)
                    }

                    Button("Request Permission") {
                        Task { await vm.requestPushPermission() }
                    }
                    Button("Register for Remote Notifications") {
                        vm.registerForRemoteNotifications()
                    }
                    Button("Schedule Local Test") {
                        Task { await vm.scheduleLocalPushTest() }
                    }
                }

                // MARK: - Premium (как было)
                Section {
                    Button(action: { vm.purchasePremium() }) {
                        Text(vm.premiumUnlocked
                             ? L10n.settingsPremiumUnlocked
                             : L10n.settingsPremiumUnlock)
                    }
                    .disabled(vm.premiumUnlocked)
                    .accessibilityIdentifier("settings.premium.button")
                }
            }
            .navigationTitle(L10n.navSettingsTitle)
            .task { await vm.refreshPush() } // подтянем статус/токен при открытии
            .alert(item: Binding(
                get: { vm.errorMessage.map { AlertError(message: $0) } },
                set: { _ in vm.clearError() }
            )) { alertError in
                Alert(
                    title: Text(L10n.alertErrorTitle),
                    message: Text(alertError.message),
                    dismissButton: .default(Text(L10n.alertOk))
                )
            }
        }
    }
}

private struct AlertError: Identifiable {
    let id = UUID()
    let message: String
}
//
//  SettingsViewModel.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/20/25.
//

import Combine
import StoreKit
import SwiftUI

public protocol SettingsViewModelProtocol: ObservableObject {
    var objectWillChange: ObservableObjectPublisher { get }
    
    // БЫЛО
    var isDarkMode: Bool { get }
    var notificationsEnabled: Bool { get }
    var premiumUnlocked: Bool { get }
    var errorMessage: String? { get }
    func setDarkMode(_ isOn: Bool)
    func setNotifications(_ isOn: Bool)
    func purchasePremium()
    func clearError()

    // ► НОВОЕ: APNs/Push
    var pushPermissionText: String { get }
    var apnsToken: String? { get }
    var presentInForeground: Bool { get }
    @MainActor func refreshPush() async
    @MainActor func requestPushPermission() async
    @MainActor func scheduleLocalPushTest() async
    func registerForRemoteNotifications()
    func setPresentInForeground(_ isOn: Bool)
}

@MainActor
public final class SettingsViewModel: SettingsViewModelProtocol {
    public let objectWillChange = ObservableObjectPublisher()
    
    private enum Keys {
        static let darkMode = "settings.darkMode"
        static let notificationsEnabled = "settings.notificationsEnabled"
    }
    
    // MARK: — Public state (старое)
    @Published public private(set) var isDarkMode = UserDefaults.standard.bool(forKey: Keys.darkMode)
    @Published public private(set) var notificationsEnabled = UserDefaults.standard.bool(forKey: Keys.notificationsEnabled)
    @Published public private(set) var premiumUnlocked = false
    @Published public private(set) var errorMessage: String?
    
    // MARK: — Новое: push/APNs
    @Published private var pushPermission: PushPermissionStatus = .notDetermined
    @Published public private(set) var apnsToken: String?
    @Published public private(set) var presentInForeground: Bool = true

    // MARK: — Deps
    private let iapService: IAPServiceProtocol
    private let analytics: AnalyticsServiceProtocol
    private let notification: NotificationServiceProtocol
    private let push: PushServiceProtocol?   // <-- теперь приходит из DI

    private var bag = Set<AnyCancellable>()
    
    public init(iapService: IAPServiceProtocol,
                analytics: AnalyticsServiceProtocol,
                notification: NotificationServiceProtocol,
                push: PushServiceProtocol?) {
        self.iapService = iapService
        self.analytics  = analytics
        self.notification = notification
        self.push = push

        // стартовая синхронизация push-состояния
        self.apnsToken = push?.apnsDeviceTokenHex
        self.presentInForeground = push?.presentInForeground ?? self.presentInForeground
        
        // Premium entitlement (как было)
        iapService.readCurrentPremiumEntitlement()
            .receive(on: DispatchQueue.main)
            .sink { [weak self] has in self?.premiumUnlocked = has }
            .store(in: &bag)
        
        NotificationCenter.default.publisher(for: .iapEntitlementsChanged)
            .flatMap { [iapService] _ in iapService.readCurrentPremiumEntitlement() }
            .receive(on: DispatchQueue.main)
            .sink { [weak self] has in self?.premiumUnlocked = has }
            .store(in: &bag)
    }
    
    // MARK: — Settings (старое)
    public func setDarkMode(_ isOn: Bool) {
        guard isDarkMode != isOn else { return }
        isDarkMode = isOn
        UserDefaults.standard.set(isOn, forKey: Keys.darkMode)
        analytics.logEvent(name: "settings_dark_mode_changed", parameters: ["value": isOn])
    }
    
    public func setNotifications(_ isOn: Bool) {
        guard notificationsEnabled != isOn else { return }
        notificationsEnabled = isOn
        UserDefaults.standard.set(isOn, forKey: Keys.notificationsEnabled )
        analytics.logEvent(name: "settings_notifications_changed", parameters: ["value": isOn])
        if isOn {
            notification.requestAuthorization().sink { _ in }.store(in: &bag)
        }
    }

    public func purchasePremium() {
        errorMessage = nil
        
        iapService.fetchProducts()
            .tryMap { products -> Product in
                guard let p = products.first else {
                    throw NSError(domain: "IAP", code: -3, userInfo: [NSLocalizedDescriptionKey: "Product not found"])
                }
                return p
            }
            .flatMap { [iapService] product in
                iapService.purchase(product)
            }
            .flatMap { [iapService] _ in
                iapService.readCurrentPremiumEntitlement()
            }
            .receive(on: DispatchQueue.main)
            .sink(receiveCompletion: { [weak self] comp in
                if case let .failure(err) = comp { self?.errorMessage = err.localizedDescription }
            }, receiveValue: { [weak self] has in
                self?.premiumUnlocked = has
            })
            .store(in: &bag)
    }
    
    public func clearError() { errorMessage = nil }

    // MARK: — Push/APNs
    public var pushPermissionText: String {
        switch pushPermission {
        case .notDetermined: return "Not Determined"
        case .denied:        return "Denied"
        case .authorized:    return "Authorized"
        case .provisional:   return "Provisional"
        case .ephemeral:     return "Ephemeral"
        }
    }

    @MainActor
    public func refreshPush() async {
        guard let push else { return }
        pushPermission      = await push.getPermissionStatus()
        apnsToken           = push.apnsDeviceTokenHex
        presentInForeground = push.presentInForeground
        objectWillChange.send()
    }

    @MainActor
    public func requestPushPermission() async {
        guard let push else { return }
        _ = await push.requestPermission(options: .all)
        await refreshPush()
    }

    public func registerForRemoteNotifications() {
        push?.registerForRemoteNotifications()
        apnsToken = push?.apnsDeviceTokenHex
        objectWillChange.send()
    }

    @MainActor
    public func scheduleLocalPushTest() async {
        guard let push else { return }
        do {
            try await push.scheduleLocal(
                title: "Local notification",
                body: "This is a local test notification.",
                after: 2
            )
        } catch {
            errorMessage = error.localizedDescription
            objectWillChange.send()
        }
    }

    public func setPresentInForeground(_ isOn: Bool) {
        presentInForeground = isOn
        push?.presentInForeground = isOn
        objectWillChange.send()
    }
}
//
//  AnySettingsViewModel.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/24/25.
//

import Combine
import StoreKit
import SwiftUI

final class AnySettingsViewModel: ObservableObject, SettingsViewModelProtocol {
    private let wrapped: any SettingsViewModelProtocol
    private var cancellables = Set<AnyCancellable>()

    // MARK: - SettingsViewModelProtocol
    let objectWillChange = ObservableObjectPublisher()

    // Старые поля
    @Published private(set) var isDarkMode: Bool = false
    @Published private(set) var notificationsEnabled: Bool = false
    @Published private(set) var premiumUnlocked: Bool = false
    @Published private(set) var errorMessage: String?

    // Новые поля (Push / APNs)
    @Published private(set) var pushPermissionText: String = "Not Determined"
    @Published private(set) var apnsToken: String?
    @Published private(set) var presentInForeground: Bool = true

    // MARK: - Init
    init(_ wrapped: any SettingsViewModelProtocol) {
        self.wrapped = wrapped

        // Важно: objectWillChange у wrapped — willSet.
        // Синхронизируемся на следующий runloop-такт, чтобы читать уже обновлённые значения.
        wrapped.objectWillChange
            .receive(on: DispatchQueue.main)
            .sink { [weak self] _ in
                DispatchQueue.main.async {
                    guard let self else { return }
                    self.syncProperties()
                    self.objectWillChange.send()
                }
            }
            .store(in: &cancellables)

        syncProperties()
    }

    // MARK: - Private
    private func syncProperties() {
        // Старые
        isDarkMode = wrapped.isDarkMode
        notificationsEnabled = wrapped.notificationsEnabled
        premiumUnlocked = wrapped.premiumUnlocked
        errorMessage = wrapped.errorMessage

        // Новые (Push)
        pushPermissionText = wrapped.pushPermissionText
        apnsToken = wrapped.apnsToken
        presentInForeground = wrapped.presentInForeground
    }

    // MARK: - Settings (старое API)
    func setDarkMode(_ isOn: Bool) {
        if isDarkMode != isOn {
            isDarkMode = isOn          // мгновенно для SwiftUI
            objectWillChange.send()
        }
        wrapped.setDarkMode(isOn)      // источник истины
    }

    func setNotifications(_ isOn: Bool) {
        if notificationsEnabled != isOn {
            notificationsEnabled = isOn
            objectWillChange.send()
        }
        wrapped.setNotifications(isOn)
    }

    func purchasePremium() { wrapped.purchasePremium() }
    func clearError()      { wrapped.clearError() }

    // MARK: - Push / APNs (новое API)
    @MainActor
    func refreshPush() async {
        await wrapped.refreshPush()
        // wrapped дернул свои паблишеры → прилетит через objectWillChange,
        // но синхронизируемся на всякий случай сразу:
        syncProperties()
        objectWillChange.send()
    }

    @MainActor
    func requestPushPermission() async {
        await wrapped.requestPushPermission()
        syncProperties()
        objectWillChange.send()
    }

    @MainActor
    func scheduleLocalPushTest() async {
        await wrapped.scheduleLocalPushTest()
        syncProperties()
        objectWillChange.send()
    }

    func registerForRemoteNotifications() {
        wrapped.registerForRemoteNotifications()
        syncProperties()
        objectWillChange.send()
    }

    func setPresentInForeground(_ isOn: Bool) {
        if presentInForeground != isOn {
            presentInForeground = isOn  // мгновенно в UI
            objectWillChange.send()
        }
        wrapped.setPresentInForeground(isOn)
    }
}
//
//  POIDetailViewModelProtocol.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/11/25.
//


import Combine
import MapKit

public protocol POIDetailViewModelProtocol: AnyObject {
  // Outputs
  var model: POIDetailModel { get }
  var isLoadingAddress: Bool { get }
  var address: String? { get }
  var errorMessage: String? { get }

  // User actions
  func onAppear()
  func didTapShare()
  func didTapOpenInMaps()
  func didTapClose()

  // Publishers for Coordinator/Router
  var sharePublisher: AnyPublisher<URL, Never> { get }
  var openInMapsPublisher: AnyPublisher<MKMapItem, Never> { get }
  var closePublisher: AnyPublisher<Void, Never> { get }

  // Publisher for model updates
  var modelPublisher: AnyPublisher<POIDetailModel, Never> { get }
}

@MainActor
public final class POIDetailViewModel: ObservableObject, POIDetailViewModelProtocol {
  @Published public private(set) var model: POIDetailModel
  @Published public private(set) var isLoadingAddress = false
  @Published public private(set) var address: String?
  @Published public private(set) var errorMessage: String?

  private let geocoder = CLGeocoder()
  private var cancellables = Set<AnyCancellable>()

  public init(poi: POI) {
    self.model = POIDetailModel(poi: poi,
                                address: nil,
                                imageData: nil)
  }

  public func onAppear() {
    guard address == nil else { return }
    isLoadingAddress = true
    let loc = CLLocation(latitude: model.poi.latitude,
                         longitude: model.poi.longitude)
    geocoder.reverseGeocodeLocation(loc) { [weak self] places, error in
      DispatchQueue.main.async {
          self?.isLoadingAddress = false
        if let err = error {
          self?.errorMessage = err.localizedDescription
        } else {
          self?.address = places?.first?.compactAddress
        }
      }
    }
  }

  public func didTapShare() {
    let p = model.poi
    let url = URL(string: "https://maps.apple.com/?ll=\(p.latitude),\(p.longitude)")!
    shareSubject.send(url)
  }

  public func didTapOpenInMaps() {
    let p = model.poi
    let coord = CLLocationCoordinate2D(latitude: p.latitude,
                                       longitude: p.longitude)
    let item = MKMapItem(placemark: MKPlacemark(coordinate: coord))
    item.name = p.name
    openInMapsSubject.send(item)
  }

  public func didTapClose() {
    closeSubject.send(())
  }

  // Internal subjects
  private let shareSubject      = PassthroughSubject<URL, Never>()
  private let openInMapsSubject = PassthroughSubject<MKMapItem, Never>()
  private let closeSubject      = PassthroughSubject<Void, Never>()

  // Protocol publishers
  public var sharePublisher: AnyPublisher<URL, Never> {
    shareSubject.eraseToAnyPublisher()
  }
  public var openInMapsPublisher: AnyPublisher<MKMapItem, Never> {
    openInMapsSubject.eraseToAnyPublisher()
  }
  public var closePublisher: AnyPublisher<Void, Never> {
    closeSubject.eraseToAnyPublisher()
  }

  public var modelPublisher: AnyPublisher<POIDetailModel, Never> {
    $model.eraseToAnyPublisher()
  }
}

private extension CLPlacemark {
  var compactAddress: String {
    [subThoroughfare, thoroughfare, locality, administrativeArea]
      .compactMap { $0 }
      .joined(separator: ", ")
  }
}
//
//  POIDetailRoute.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/11/25.
//



import Combine
import MapKit

public enum POIDetailRoute: Hashable, Identifiable {
  case share(URL)
  case openInMaps(MKMapItem)
  case close

  public var id: String {
    switch self {
    case .share(let url): return "share:\(url.absoluteString)"
    case .openInMaps(let item):
      let c = item.placemark.coordinate
      return "open:\(c.latitude),\(c.longitude)"
    case .close: return "close"
    }
  }
}

public enum POIDetailUIError: Hashable {
  case plain(String)
  var localizedMessage: String {
    switch self {
    case .plain(let m): return m
    }
  }
}

@MainActor
public final class POIDetailRouter: ObservableObject {
  public let routes = PassthroughSubject<POIDetailRoute, Never>()
  public let uiErrors = PassthroughSubject<POIDetailUIError, Never>()
  private var cancellables = Set<AnyCancellable>()

  public init(viewModel: POIDetailViewModel) {
    viewModel.sharePublisher
      .map(POIDetailRoute.share)
      .sink { [routes] in routes.send($0) }
      .store(in: &cancellables)

    viewModel.openInMapsPublisher
      .map(POIDetailRoute.openInMaps)
      .sink { [routes] in routes.send($0) }
      .store(in: &cancellables)

    viewModel.closePublisher
      .map { _ in POIDetailRoute.close }
      .sink { [routes] in routes.send($0) }
      .store(in: &cancellables)

    // Транслируем ошибки VM в UIError-канал
    viewModel.$errorMessage
      .compactMap { $0 }
      .map { POIDetailUIError.plain($0) }
      .sink { [uiErrors] in uiErrors.send($0) }
      .store(in: &cancellables)
  }
}
//
//  POIDetailCoordinator.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/11/25.
//


import SwiftUI
import Combine
import Swinject

@MainActor
public final class POIDetailCoordinator: ObservableObject {
    @Published private(set) var sheetRoute: POIDetailRoute?
    @Published private(set) var model: POIDetailModel

    private let viewModel: POIDetailViewModel
    private let router: POIDetailRouter
    private var cancellables = Set<AnyCancellable>()

    // UI error state
    @Published private var failAlert: FailAlert?
    private struct FailAlert: Identifiable { let id = UUID(); let message: String }

    public init(poi: POI, resolver: Resolver? = nil) {
        let r = resolver ?? DIContainer.shared.resolver
        guard let vm = r.resolve(POIDetailViewModel.self, argument: poi) else {
            preconditionFailure("Swinject: POIDetailViewModel не зарегистрирован для \(POI.self)")
        }

        self.viewModel = vm
        self.router    = POIDetailRouter(viewModel: vm)
        self.model     = vm.model

        router.routes
            .sink { [weak self] route in
                switch route {
                case .share(let url):       self?.sheetRoute = .share(url)
                case .openInMaps(let item): item.openInMaps(launchOptions: nil)
                case .close:                self?.sheetRoute = nil
                }
            }
            .store(in: &cancellables)

        // централизованный показ ошибок
        router.uiErrors
            .sink { [weak self] uiError in
                self?.failAlert = .init(message: uiError.localizedMessage)
            }
            .store(in: &cancellables)

        vm.modelPublisher
            .sink { [weak self] newModel in self?.model = newModel }
            .store(in: &cancellables)
    }

    @ViewBuilder
    public func rootView() -> some View {
        let binding = Binding<POIDetailRoute?>(
            get: { self.sheetRoute },
            set: { self.sheetRoute = $0 }
        )
        POIDetailView(viewModel: viewModel, sheetRoute: binding)
            .alert(item: Binding(
                get: { self.failAlert },
                set: { _ in self.failAlert = nil }
            )) { alert in
                Alert(
                    title: Text(L10n.alertErrorTitle),
                    message: Text(alert.message),
                    dismissButton: .default(Text(L10n.alertOk))
                )
            }
    }
}
//
//  POIDetailModel.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/11/25.
//


import Foundation

public struct POIDetailModel {
  public let poi: POI
  public let address: String?
  public let imageData: Data?

  public init(
    poi: POI,
    address: String?,
    imageData: Data?
  ) {
    self.poi = poi
    self.address = address
    self.imageData = imageData
  }
}
//
//  POIDetailView.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/11/25.
//


import SwiftUI
import MapKit

public struct POIDetailView: View {
  @ObservedObject private var vm: POIDetailViewModel
  @Binding private var sheetRoute: POIDetailRoute?

  public init(
    viewModel: POIDetailViewModel,
    sheetRoute: Binding<POIDetailRoute?>
  ) {
    self.vm = viewModel
    self._sheetRoute = sheetRoute
  }

  public var body: some View {
    VStack(spacing: 16) {
      HStack { Spacer()
        Button(action: vm.didTapClose) {
          Image(systemName: "xmark.circle.fill")
            .font(.title2)
        }
        .accessibilityIdentifier("detail.close")
      }

      Text(vm.model.poi.name).font(.largeTitle)

      if vm.isLoadingAddress {
        ProgressView(L10n.detailLoadingAddress)
      } else if let addr = vm.address {
        Text(addr).italic()
      } else if let err = vm.errorMessage {
        // Экранная подсветка + route-алерт прилетит из координатора
        Text(err).foregroundColor(.red)
      }

      Button(L10n.detailShare,        action: vm.didTapShare)
      Button(L10n.detailOpenInMaps,   action: vm.didTapOpenInMaps)
      Spacer()
    }
    .padding()
    .onAppear(perform: vm.onAppear)
    .navigationTitle(vm.model.poi.name)
    .sheet(item: $sheetRoute) { route in
      switch route {
      case .share(let url):
        ActivityViewController(activityItems: [url])
      default:
        EmptyView()
      }
    }
  }
}


// UIKit wrapper
struct ActivityViewController: UIViewControllerRepresentable {
  let activityItems: [Any]

  func makeUIViewController(
    context: Context
  ) -> UIActivityViewController {
    UIActivityViewController(
      activityItems: activityItems,
      applicationActivities: nil
    )
  }

  func updateUIViewController(
    _ vc: UIActivityViewController,
    context: Context
  ) {}
}
//
//  POIMapViewModelProtocol.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/7/25.
//


import Combine
import MapKit

public protocol POIMapViewModelProtocol: ObservableObject {
    var annotations: [POIAnnotation] { get }
    var selectedPOI: POI? { get }
    func fetch()
    func select(annotation: POIAnnotation)
}

public final class POIMapViewModel: POIMapViewModelProtocol {
    // Output
    @Published public private(set) var annotations: [POIAnnotation] = []
    @Published public private(set) var selectedPOI: POI?

    // Deps
    private let service: POIServiceProtocol
    private let factory: AnnotationFactory
    private var bag = Set<AnyCancellable>()

    init(service: POIServiceProtocol,
                factory: AnnotationFactory = DefaultAnnotationFactory()) {
        self.service  = service
        self.factory  = factory
    }

    public func fetch() {
        service.fetchPOIs()
            .map(factory.makeAnnotations)
            .receive(on: DispatchQueue.main)
            .sink(receiveCompletion: { _ in },
                  receiveValue: { [weak self] in self?.annotations = $0 })
            .store(in: &bag)
    }

    public func select(annotation: POIAnnotation) {
        selectedPOI = annotation.poi
    }
}
//
//  AnyPOIMapViewModel.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/7/25.
//


import Combine
import SwiftUI

public final class AnyPOIMapViewModel: ObservableObject {
    // -------- SwiftUI bindings --------
    @Published public var annotations: [POIAnnotation] = []
    @Published public var selectedPOI: POI?            = nil

    // -------- Internals --------
    private let wrapped: any POIMapViewModelProtocol
    private var bag = Set<AnyCancellable>()

    // MARK: – init
    public init(_ wrapped: any POIMapViewModelProtocol) {
        self.wrapped      = wrapped
        self.annotations  = wrapped.annotations
        self.selectedPOI  = wrapped.selectedPOI

        // Если это именно POIMapViewModel, подписываемся на его @Published-поля
        if let concrete = wrapped as? POIMapViewModel {
            concrete.$annotations
                .receive(on: DispatchQueue.main)
                .assign(to: &$annotations)

            concrete.$selectedPOI
                .receive(on: DispatchQueue.main)
                .assign(to: &$selectedPOI)
        }
    }

    // MARK: – Facade
    public func fetch()                           { wrapped.fetch() }
    public func select(annotation: POIAnnotation) { wrapped.select(annotation: annotation) }
}
//
//  MapRoute.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/11/25.
//

import SwiftUI
import Combine
import CoreLocation

enum MapRoute: Hashable {
    case detail(POI)
}

enum MapUIError: Equatable {
    case poiNotFound(Int)
    case plain(String)

    var localizedMessage: String {
        switch self {
        case .poiNotFound(let id):
            return L10n.deeplinkPoiNotFound(id)
        case .plain(let message):
            return message
        }
    }
}

enum MapNavigationCommand {
    case detail(POI)
    case back
    case reset
    case center(CLLocationCoordinate2D)
    case focusPOI(Int)
    case showError(MapUIError)
}

@MainActor
final class MapRouter: ObservableObject {
    let routes = PassthroughSubject<MapNavigationCommand, Never>()
    private var pending: [MapNavigationCommand] = []

    private func emit(_ cmd: MapNavigationCommand) {
        pending.append(cmd)
        routes.send(cmd)
    }

    func consumePending() -> [MapNavigationCommand] {
        let items = pending
        pending.removeAll()
        return items
    }

    // MARK: High-level API
    func goDetail(_ poi: POI)                 { emit(.detail(poi)) }
    func goBack()                              { emit(.back) }
    func reset()                               { emit(.reset) }
    func center(on coord: CLLocationCoordinate2D) { emit(.center(coord)) }
    func focusPOI(_ id: Int)                   { emit(.focusPOI(id)) }

    // Единый способ показать ошибку на карте
    func showError(_ error: MapUIError)        { emit(.showError(error)) }
}
//
//  MapCoordinator.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/10/25.
//


import SwiftUI
import Combine
import MapKit

@MainActor
final class MapCoordinator {
    private let vm: AnyPOIMapViewModel
    private let router: MapRouter
    private let defaultRegionMeters: CLLocationDistance
    private let makeDetail: (POI) -> AnyView
   
    
    init(vm: AnyPOIMapViewModel, router: MapRouter) {
        self.vm     = vm
        self.router = router
        
        let config = DIContainer.shared.resolver.resolve(AppConfig.self)!
        self.defaultRegionMeters = config.defaultRegionMeters
        let resolver = DIContainer.shared.resolver
        self.makeDetail = { poi in
            guard let coord = resolver.resolve(POIDetailCoordinator.self, argument: poi) else {
                return AnyView(EmptyView())
            }
            return AnyView(coord.rootView())
        }
    }
    
    func rootView() -> some View {
        MapContainer(vm: vm, router: router, defaultRegionMeters: defaultRegionMeters, makeDetail: makeDetail)
    }
}

//
//  POIAnnotation.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/7/25.
//


import MapKit

/// Простая обёртка над POI, чтобы стать MKAnnotation
public final class POIAnnotation: NSObject, MKAnnotation {
    let poi: POI

    // локально собираем координату, модель POI не меняем
    public var coordinate: CLLocationCoordinate2D {
        .init(latitude: poi.latitude, longitude: poi.longitude)
    }

    public var title: String?    { poi.name      }
    public var subtitle: String? { poi.category  }

    init(poi: POI) { self.poi = poi }
}

/// SRP-фабрика для тестов и явной зависимости
protocol AnnotationFactory {
    func makeAnnotations(from pois: [POI]) -> [POIAnnotation]
}

struct DefaultAnnotationFactory: AnnotationFactory {
    func makeAnnotations(from pois: [POI]) -> [POIAnnotation] {
        pois.map(POIAnnotation.init)
    }
}
//
//  POISnippetView.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/7/25.
//

import SwiftUI
import MapKit

struct POISnippetView: View {
    let poi: POI
    var onDetails: () -> Void
    var onRoute:   () -> Void

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text(poi.name).font(.title2).bold()
            if let cat = poi.category { Text(cat).foregroundColor(.secondary) }
            if let desc = poi.description { Text(desc).lineLimit(3) }

            HStack {
                Button(L10n.snippetDetails, action: onDetails)
                    .buttonStyle(.borderedProminent)

                Spacer()
                Button(L10n.detailOpenInMaps, action: onRoute)
            }
        }
        .padding()
    }
}
//
//  MapViewRepresentable.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/7/25.
//

import SwiftUI
import MapKit

/// UIKit-карта с управлением:
/// - дифф аннотаций
/// - синхронизация выделения по `selectedId`
/// - внешняя команда центрирования через `centerRequest`
struct MapViewRepresentable: UIViewRepresentable {
    let annotations: [POIAnnotation]
    let defaultRegionMeters: CLLocationDistance

    /// Единый источник правды для выделения пина
    @Binding var selectedId: Int?

    /// Внешняя команда центрирования карты (однократная) — после применения сбрасывается в nil
    @Binding var centerRequest: CLLocationCoordinate2D?

    /// Доп. коллбек (сохраняем для совместимости; чаще всего noop)
    let onSelect: (POIAnnotation) -> Void

    func makeCoordinator() -> Coordinator { Coordinator(self) }

    func makeUIView(context: Context) -> MKMapView {
        let map = MKMapView()
        map.delegate = context.coordinator
        map.register(MKMarkerAnnotationView.self, forAnnotationViewWithReuseIdentifier: "marker")
        map.register(MKMarkerAnnotationView.self, forAnnotationViewWithReuseIdentifier: "cluster")
        map.showsUserLocation = true
        map.pointOfInterestFilter = .excludingAll
        return map
    }

    func updateUIView(_ map: MKMapView, context: Context) {
        // --- дифф аннотаций ---
        let existing = map.annotations.compactMap { $0 as? POIAnnotation }
        let existingIDs = Set(existing.map { $0.poi.id })
        let incomingIDs = Set(annotations.map { $0.poi.id })

        let toRemove = existing.filter { !incomingIDs.contains($0.poi.id) }
        if !toRemove.isEmpty { map.removeAnnotations(toRemove) }

        let toAdd = annotations.filter { !existingIDs.contains($0.poi.id) }
        if !toAdd.isEmpty { map.addAnnotations(toAdd) }

        // --- первичная установка региона ---
        if !context.coordinator.hasSetInitialRegion, !map.annotations.isEmpty {
            context.coordinator.hasSetInitialRegion = true
            let poiAnnos = map.annotations.compactMap { $0 as? POIAnnotation }
            if poiAnnos.count == 1, let only = poiAnnos.first {
                let region = MKCoordinateRegion(
                    center: only.coordinate,
                    latitudinalMeters: defaultRegionMeters,
                    longitudinalMeters: defaultRegionMeters
                )
                map.setRegion(region, animated: false)
            } else {
                map.showAnnotations(poiAnnos, animated: false)
                let insets = UIEdgeInsets(top: 80, left: 40, bottom: 160, right: 40)
                map.setVisibleMapRect(map.visibleMapRect, edgePadding: insets, animated: false)
            }
        }

        // --- синхронизация выделения ---
        if let id = selectedId {
            if let anno = map.annotations
                .compactMap({ $0 as? POIAnnotation })
                .first(where: { $0.poi.id == id }) {
                let already = map.selectedAnnotations.contains {
                    guard let a = $0 as? POIAnnotation else { return false }
                    return a.poi.id == id
                }
                if !already { map.selectAnnotation(anno, animated: true) }
            }
        } else {
            if !map.selectedAnnotations.isEmpty {
                map.selectedAnnotations.forEach { map.deselectAnnotation($0, animated: true) }
            }
        }

        // --- внешняя команда центрирования (deeplink) ---
        if let center = centerRequest {
            // это и есть «наш» стартовый регион — запретим авто-инициализацию позже
            context.coordinator.hasSetInitialRegion = true
            let region = MKCoordinateRegion(
                center: center,
                latitudinalMeters: defaultRegionMeters,
                longitudinalMeters: defaultRegionMeters
            )
            map.setRegion(region, animated: true)
            // однократное действие — сбрасываем запрос в nil
            DispatchQueue.main.async {
                self.centerRequest = nil
            }
        }
    }

    // MARK: - Coordinator

    final class Coordinator: NSObject, MKMapViewDelegate {
        var hasSetInitialRegion = false
        let parent: MapViewRepresentable
        private var lastSelectedId: Int?

        init(_ parent: MapViewRepresentable) { self.parent = parent }

        func mapView(_ mapView: MKMapView, didSelect view: MKAnnotationView) {
            guard let anno = view.annotation as? POIAnnotation else { return }
            guard lastSelectedId != anno.poi.id else { return }
            lastSelectedId = anno.poi.id

            parent.selectedId = anno.poi.id
            parent.onSelect(anno)
        }

        func mapView(_ mapView: MKMapView, didDeselect view: MKAnnotationView) {
            guard let anno = view.annotation as? POIAnnotation else { return }
            if lastSelectedId == anno.poi.id { lastSelectedId = nil }
            if parent.selectedId == anno.poi.id { parent.selectedId = nil }
        }

        func mapView(_ mapView: MKMapView, viewFor annotation: MKAnnotation) -> MKAnnotationView? {
            if let cluster = annotation as? MKClusterAnnotation {
                let v = mapView.dequeueReusableAnnotationView(withIdentifier: "cluster", for: annotation) as! MKMarkerAnnotationView
                v.displayPriority = .required
                v.markerTintColor = .systemBlue
                v.glyphText = "\(cluster.memberAnnotations.count)"
                v.titleVisibility = .hidden
                v.subtitleVisibility = .hidden
                v.canShowCallout = false
                return v
            }
            guard annotation is POIAnnotation else { return nil }
            let v = mapView.dequeueReusableAnnotationView(withIdentifier: "marker", for: annotation) as! MKMarkerAnnotationView
            v.displayPriority      = .defaultHigh
            v.clusteringIdentifier = "poi"
            v.markerTintColor      = .systemBlue
            v.glyphImage           = UIImage(systemName: "mappin")
            v.canShowCallout       = false
            return v
        }
    }
}
//
//  POIMapView.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/7/25.
//

import SwiftUI
import MapKit

/// Владеет `AnyPOIMapViewModel`, показывает карту и сниппет.
/// Управление фокусом и центрированием приходит сверху через биндинги.
public struct POIMapView: View {
    @StateObject private var vm: AnyPOIMapViewModel
    @EnvironmentObject private var router: MapRouter
    private let defaultRegionMeters: CLLocationDistance

    /// Прокидываем из `MapContainer` запросы центра/фокуса
    @Binding private var centerRequest: CLLocationCoordinate2D?

    public init(
        viewModel: AnyPOIMapViewModel,
        defaultRegionMeters: CLLocationDistance,
        centerRequest: Binding<CLLocationCoordinate2D?>
    ) {
        _vm = StateObject(wrappedValue: viewModel)
        self.defaultRegionMeters = defaultRegionMeters
        self._centerRequest = centerRequest
    }

    public var body: some View {
        MapViewRepresentable(
            annotations: vm.annotations,
            defaultRegionMeters: defaultRegionMeters,
            selectedId: Binding(
                get: { vm.selectedPOI?.id },
                set: { newId in
                    vm.selectedPOI = newId.flatMap { id in
                        vm.annotations.first(where: { $0.poi.id == id })?.poi
                    }
                }
            ),
            centerRequest: $centerRequest,
            onSelect: { _ in }
        )
        .ignoresSafeArea()
        .onAppear { vm.fetch() }
        .sheet(item: Binding(
            get: { vm.selectedPOI },
            set: { vm.selectedPOI = $0 }
        ), onDismiss: {
            vm.selectedPOI = nil
        }) { poi in
            POISnippetView(
                poi: poi,
                onDetails: {
                    vm.selectedPOI = nil
                    DispatchQueue.main.async { router.goDetail(poi) }
                },
                onRoute: {
                    let coord = CLLocationCoordinate2D(latitude: poi.latitude, longitude: poi.longitude)
                    let item = MKMapItem(placemark: MKPlacemark(coordinate: coord))
                    item.name = poi.name
                    item.openInMaps()
                }
            )
            .presentationDetents([.height(200), .medium])
        }
    }
}
//
//  MapContainer.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/17/25.
//


import SwiftUI
import Combine
import Swinject
import MapKit

struct MapContainer: View {
    @State private var path: [MapRoute] = []
    @State private var prevPathCount: Int = 0

    @State private var lastPushedPOIId: Int?
    @State private var isNavigating = false

    @StateObject private var router: MapRouter
    @StateObject private var vm: AnyPOIMapViewModel

    private let defaultRegionMeters: CLLocationDistance
    private let makeDetail: (POI) -> AnyView

    @State private var centerRequest: CLLocationCoordinate2D? = nil

    @State private var pendingFocusId: Int? = nil
    @State private var focusTimeoutWorkItem: DispatchWorkItem? = nil
    @State private var failAlert: FailAlert? = nil

    private struct FailAlert: Identifiable {
        let id = UUID()
        let message: String
    }

    init(
        vm: AnyPOIMapViewModel,
        router: MapRouter,
        defaultRegionMeters: CLLocationDistance,
        makeDetail: @escaping (POI) -> AnyView
    ) {
        _vm = StateObject(wrappedValue: vm)
        _router = StateObject(wrappedValue: router)
        self.defaultRegionMeters = defaultRegionMeters
        self.makeDetail = makeDetail
    }

    var body: some View {
        NavigationStack(path: $path) {
            POIMapView(
                viewModel: vm,
                defaultRegionMeters: defaultRegionMeters,
                centerRequest: $centerRequest
            )
            .navigationDestination(for: MapRoute.self) { route in
                switch route {
                case .detail(let poi):
                    makeDetail(poi)
                }
            }
        }
        .onReceive(router.routes) { command in
            handle(command)
        }
        .onAppear {
            router.consumePending().forEach { handle($0) }
        }
        .onChange(of: path) { newValue in
            if newValue.count < prevPathCount {
                lastPushedPOIId = nil
                isNavigating = false
            }
            prevPathCount = newValue.count
        }
        .onChange(of: vm.annotations) { _ in
            if let id = pendingFocusId,
               let poi = vm.annotations.first(where: { $0.poi.id == id })?.poi {
                pendingFocusId = nil
                cancelFocusTimeout()
                vm.selectedPOI = poi
            }
        }
        .alert(item: $failAlert) { alert in
            Alert(
                title: Text(L10n.alertErrorTitle),
                message: Text(alert.message),
                dismissButton: .default(Text(L10n.alertOk))
            )
        }
        .environmentObject(router)
    }

    // MARK: - Helpers

    private func scheduleFocusTimeout(for id: Int, seconds: Double = 2.5) {
        cancelFocusTimeout()
        let work = DispatchWorkItem {
            if pendingFocusId == id, vm.selectedPOI?.id != id {
                // единый путь показа ошибки — через Router
                router.showError(.poiNotFound(id))

                // подвинем карту, чтобы не оставлять «никуда»
                if let anyAnno = vm.annotations.first {
                    centerRequest = anyAnno.coordinate
                }

                // (опционально) метрика
                DIContainer.shared.resolver
                    .resolve(AnalyticsServiceProtocol.self)?
                    .logEvent(name: "deeplink_poi_not_found", parameters: ["id": id])

                pendingFocusId = nil
            }
        }
        focusTimeoutWorkItem = work
        DispatchQueue.main.asyncAfter(deadline: .now() + seconds, execute: work)
    }

    private func cancelFocusTimeout() {
        focusTimeoutWorkItem?.cancel()
        focusTimeoutWorkItem = nil
    }

    private func handle(_ command: MapNavigationCommand) {
        switch command {
        case .detail(let poi):
            guard !isNavigating, lastPushedPOIId != poi.id else { return }
            isNavigating = true
            path.append(.detail(poi))
            lastPushedPOIId = poi.id
            DispatchQueue.main.async { isNavigating = false }

        case .back:
            if !path.isEmpty { path.removeLast() }
            lastPushedPOIId = nil
            isNavigating = false

        case .reset:
            path.removeAll()
            lastPushedPOIId = nil
            isNavigating = false

        case .center(let coord):
            centerRequest = coord

        case .focusPOI(let id):
            if let poi = vm.annotations.first(where: { $0.poi.id == id })?.poi {
                vm.selectedPOI = poi
                cancelFocusTimeout()
            } else {
                pendingFocusId = id
                vm.fetch()
                scheduleFocusTimeout(for: id)
            }

        case .showError(let uiError):
            // Всегда локализовано здесь, в UI-слое
            failAlert = .init(message: uiError.localizedMessage)
        }
    }
}
//
//  POIListViewModel.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/20/25.
//



import Combine
import CoreLocation
import MapKit

public protocol POIListViewModelProtocol: AnyObject {
    // Inputs
    var filter: POICategoryFilter { get set }
    func fetchPOIs()
    func openInMaps(poi: POI)
    
    // Outputs
    var pois: [POI] { get }
    var isLoading: Bool { get }
    var errorMessage: String? { get }
}

public final class POIListViewModel: ObservableObject, POIListViewModelProtocol {
    // MARK: Inputs
    @Published public var filter: POICategoryFilter = .all
    
    // MARK: Internal state
    private var allPois: [POI] = []
    
    // MARK: Outputs
    @Published public private(set) var pois: [POI] = []
    @Published public private(set) var isLoading: Bool = false
    @Published public private(set) var errorMessage: String? = nil
    
    private let repository: POIServiceProtocol
    private var cancellables = Set<AnyCancellable>()
    
    public init(repository: POIServiceProtocol) {
        self.repository = repository
        
        // Локальная фильтрация при смене filter
        $filter
            .dropFirst()
            .receive(on: DispatchQueue.main)
            .sink { [weak self] newFilter in
                self?.applyFilter(using: newFilter)
            }
            .store(in: &cancellables)
    }
    
    public func fetchPOIs() {
        if pois.isEmpty { isLoading = true }
        errorMessage = nil
        
        repository.fetchPOIs()
            .receive(on: DispatchQueue.main)
            .sink { [weak self] completion in
                guard let self = self else { return }
                self.isLoading = false
                if case let .failure(err) = completion {
                    self.errorMessage = err.localizedDescription
                }
            } receiveValue: { [weak self] list in
                guard let self = self else { return }
                self.allPois = list
                self.applyFilter()
            }
            .store(in: &cancellables)
    }
    
    private func applyFilter(using filter: POICategoryFilter? = nil) {
        let effective = filter ?? self.filter
        pois = (effective == .all)
        ? allPois
        : allPois.filter { $0.category == effective.rawValue }
    }
    
    public func openInMaps(poi: POI) {
        let coord = CLLocationCoordinate2D(latitude: poi.latitude,
                                           longitude: poi.longitude)
        let item = MKMapItem(placemark: MKPlacemark(coordinate: coord))
        item.name = poi.name
        item.openInMaps(launchOptions: nil)
    }
}
//
//  AnyPOIListViewModel.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/1/25.
//

import Foundation
import Combine

public final class AnyPOIListViewModel: ObservableObject {
    @Published public var filter: POICategoryFilter = .all
    @Published public var pois: [POI] = []
    @Published public var isLoading: Bool = false
    @Published public var errorMessage: String? = nil

    private let wrapped: POIListViewModelProtocol
    private var cancellables = Set<AnyCancellable>()

    public init(_ wrapped: POIListViewModelProtocol) {
        self.wrapped = wrapped
        self.filter = wrapped.filter

        // 1. Пробрасываем filter из wrapper в wrapped
        $filter
            .dropFirst()
            .sink { [weak self] newFilter in
                guard let self else { return }
                if self.wrapped.filter != newFilter {
                    self.wrapped.filter = newFilter
                }
            }
            .store(in: &cancellables)

        // 2. Пробрасываем filter из wrapped наружу (если вдруг он меняется)
        if let vm = wrapped as? POIListViewModel {
            vm.$filter
                .receive(on: DispatchQueue.main)
                .sink { [weak self] newFilter in
                    guard let self else { return }
                    if self.filter != newFilter {
                        self.filter = newFilter
                    }
                }
                .store(in: &cancellables)

            vm.$pois
                .receive(on: DispatchQueue.main)
                .assign(to: &$pois)
            vm.$isLoading
                .receive(on: DispatchQueue.main)
                .assign(to: &$isLoading)
            vm.$errorMessage
                .receive(on: DispatchQueue.main)
                .assign(to: &$errorMessage)
        }
    }

    public func fetchPOIs() { wrapped.fetchPOIs() }
    public func openInMaps(poi: POI) { wrapped.openInMaps(poi: poi) }
}
//
//  POIListRoute.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/11/25.
//



import SwiftUI
import Combine

enum POIListRoute: Hashable {
    case detail(POI)
}

enum POIListUIError: Hashable {
    case plain(String)
    var localizedMessage: String {
        switch self {
        case .plain(let m): return m
        }
    }
}

enum POIListNavigationCommand {
    case detail(POI)
    case back
    case reset
    case showError(POIListUIError)
}

@MainActor
final class POIListRouter: ObservableObject {
    let routes = PassthroughSubject<POIListNavigationCommand, Never>()
    var cancellables = Set<AnyCancellable>()

    func goDetail(_ poi: POI) { routes.send(.detail(poi)) }
    func goBack() { routes.send(.back) }
    func reset() { routes.send(.reset) }

    func showError(_ error: POIListUIError) { routes.send(.showError(error)) }
}
//
//  POIListRoute.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/10/25.
//


import SwiftUI

@MainActor
final class POIListCoordinator {
    private let viewModel: AnyPOIListViewModel
    private let router: POIListRouter
    private let makeDetail: (POI) -> AnyView
    
    init(viewModel: AnyPOIListViewModel, router: POIListRouter) {
        self.viewModel = viewModel
        self.router = router
        let resolver = DIContainer.shared.resolver
        self.makeDetail = { poi in
            guard let coord = resolver.resolve(POIDetailCoordinator.self, argument: poi) else {
                return AnyView(EmptyView())
            }
            return AnyView(coord.rootView())
        }
    }
    
    @ViewBuilder
    func rootView() -> some View {
        POIListContainer(vm: viewModel, router: router, makeDetail: makeDetail)
    }
}
//
//  POIImageView.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/2/25.
//

import SwiftUI

public struct POIImageView: View {
    let imagePath: String?

    public init(imagePath: String?) { self.imagePath = imagePath }

    public var body: some View {
        VStack {
            if let imagePath,
               let imageName = imagePath.split(separator: "/").last {
                let components = imageName.split(separator: ".")
                if components.count == 2 {
                    let name = String(components[0])
                    let ext = String(components[1])
                    if let url = Bundle.main.url(forResource: name, withExtension: ext),
                       let uiImage = UIImage(contentsOfFile: url.path) {
                        Image(uiImage: uiImage).resizable().scaledToFit()
                    } else {
                        Text(L10n.imageInvalidPath(imagePath))
                            .font(.caption)
                            .foregroundColor(.red)
                    }
                } else {
                    Text(L10n.imageInvalidPath(imagePath))
                        .font(.caption)
                        .foregroundColor(.red)
                }
            } else {
                Text(L10n.imageNoImage)
            }
        }
    }
}
//
//  POIListContainer.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 9/11/25.
//



import SwiftUI
import Combine

struct POIListContainer: View {
    @State private var path = NavigationPath()
    @StateObject private var vm: AnyPOIListViewModel
    @StateObject private var router: POIListRouter
    private let makeDetail: (POI) -> AnyView

    // единый алерт
    @State private var failAlert: FailAlert?
    private struct FailAlert: Identifiable { let id = UUID(); let message: String }

    private var bag = Set<AnyCancellable>() // не @State — но нам хватит onAppear/Disappear

    init(vm: AnyPOIListViewModel, router: POIListRouter, makeDetail: @escaping (POI) -> AnyView) {
        _vm = StateObject(wrappedValue: vm)
        _router = StateObject(wrappedValue: router)
        self.makeDetail = makeDetail
    }

    var body: some View {
        NavigationStack(path: $path) {
            POIListView(viewModel: vm)
                .navigationDestination(for: POIListRoute.self) { route in
                    switch route {
                    case .detail(let poi):
                        makeDetail(poi)
                    }
                }
        }
        .onReceive(router.routes) { cmd in
            switch cmd {
            case .detail(let poi): path.append(POIListRoute.detail(poi))
            case .back: if !path.isEmpty { path.removeLast() }
            case .reset: if !path.isEmpty { path.removeLast(path.count) }
            case .showError(let e):
                failAlert = .init(message: e.localizedMessage)
            }
        }
        .onAppear {
            // Транслируем VM.errorMessage -> роутер
            vm.$errorMessage
                .compactMap { $0 }
                .sink { msg in router.showError(.plain(msg)) }
                .store(in: &router.cancellables)
        }
        .alert(item: $failAlert) { alert in
            Alert(
                title: Text(L10n.alertErrorTitle),
                message: Text(alert.message),
                dismissButton: .default(Text(L10n.alertOk))
            )
        }
        .environmentObject(router)
    }
}
//
//  POIListView.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/1/25.
//


import SwiftUI

public struct POIListView: View {
    @ObservedObject var viewModel: AnyPOIListViewModel
    @EnvironmentObject var router: POIListRouter

    public init(viewModel: AnyPOIListViewModel) {
        self.viewModel = viewModel
    }

    public var body: some View {
        ZStack {
            content
            if viewModel.isLoading {
                if viewModel.pois.isEmpty {
                    ProgressView().scaleEffect(1.2)
                } else {
                    VStack { Spacer() }
                        .overlay(
                            ProgressView()
                                .padding(12)
                                .background(.ultraThinMaterial)
                                .clipShape(RoundedRectangle(cornerRadius: 12))
                                .padding(.bottom, 24),
                            alignment: .bottom
                        )
                }
            }
        }
        .navigationTitle(L10n.navPlacesTitle)
        .onAppear { viewModel.fetchPOIs() }
    }

    @ViewBuilder
    private var content: some View {
        if let err = viewModel.errorMessage {
            VStack(spacing: 16) {
                Text(err).multilineTextAlignment(.center)
                Button(L10n.commonRetry) { viewModel.fetchPOIs() }
            }
            .padding()
        } else {
            VStack {
                Picker(L10n.listCategoryTitle, selection: $viewModel.filter) {
                    ForEach(POICategoryFilter.allCases) { Text($0.localizedTitle).tag($0) }
                }
                .pickerStyle(.segmented)
                .padding(.vertical)

                // Пример использования plural (если хочешь — покажем над списком)
                if !viewModel.pois.isEmpty {
                    Text(L10n.listPlacesCount(viewModel.pois.count))
                        .font(.footnote).foregroundColor(.secondary)
                }

                List(viewModel.pois) { poi in
                    Button { router.goDetail(poi) } label: {
                        HStack {
                            POIImageView(imagePath: poi.imageURL?.path)
                                .frame(width: 48, height: 48)
                                .clipShape(RoundedRectangle(cornerRadius: 8))
                                .padding(.trailing, 4)
                            VStack(alignment: .leading) {
                                Text(poi.name).font(.headline)
                                if let c = poi.category {
                                    Text(c).font(.subheadline).foregroundColor(.secondary)
                                }
                            }
                        }
                        .padding(.vertical, 4)
                    }
                }
                .listStyle(.plain)
            }
        }
    }
}
//
//  AnyOnboardingViewModel.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/26/25.
//

import Combine

/// Универсальный Any-ViewModel для Onboarding, скрывает конкретный тип
public final class AnyOnboardingViewModel: OnboardingViewModelProtocol {
    // MARK: — ObservableObject conformance
    public let objectWillChange = ObservableObjectPublisher()
    private var cancellables = Set<AnyCancellable>()
    
    // MARK: — Outputs
    @Published public private(set) var pages: [OnboardingPage]
    @Published public private(set) var currentPage: Int
    @Published public private(set) var hasCompletedOnboarding: Bool
    
    
    // MARK: — Wrapped instance
    private let wrapped: any OnboardingViewModelProtocol
    
    /// Инициализируем тип-стирающую «обёртку»
    public init(_ wrapped: any OnboardingViewModelProtocol) {
        self.wrapped = wrapped
        // копируем начальные значения
        self.pages               = wrapped.pages
        self.currentPage         = wrapped.currentPage
        self.hasCompletedOnboarding = wrapped.hasCompletedOnboarding
        
        // подписываемся на objectWillChange wrapped-VM,
        // чтобы передавать события субъективного обновления и синхронизировать свойства
        wrapped.objectWillChange
            .sink { [weak self] _ in
                guard let self = self else { return }
                self.pages               = self.wrapped.pages
                self.currentPage         = self.wrapped.currentPage
                self.hasCompletedOnboarding = self.wrapped.hasCompletedOnboarding
                self.objectWillChange.send()
            }
            .store(in: &cancellables)
    }
    
    // MARK: — Inputs: просто делегируем вызовы
    public func next() {
        wrapped.next()
    }
    public func previous() {
        wrapped.previous()
    }
    public func skip() {
        wrapped.skip()
    }
}
//
//  OnboardingViewModel.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/26/25.
//


import Combine
import Foundation

public protocol OnboardingViewModelProtocol: ObservableObject {
    /// Чтобы View могла подписаться на любые изменения
    var objectWillChange: ObservableObjectPublisher { get }
    
    // MARK: — Outputs
    var pages: [OnboardingPage] { get }
    var currentPage: Int { get }
    var hasCompletedOnboarding: Bool { get }
    
    // MARK: — Inputs
    func next()
    func previous()
    func skip()
}

public final class OnboardingViewModel: OnboardingViewModelProtocol {
    // MARK: — ObservableObject conformance
    public let objectWillChange = ObservableObjectPublisher()
    
    // MARK: — Outputs
    @Published public private(set) var currentPage: Int = 0
    @Published public private(set) var hasCompletedOnboarding: Bool
    
    public let pages: [OnboardingPage]
    private var cancellables = Set<AnyCancellable>()
    
    public init() {
        // Страницы онбординга
        self.pages = [
                   OnboardingPage(id: 0, imageName: "onb1",
                                  title: L10n.onbPage1Title, description: L10n.onbPage1Desc),
                   OnboardingPage(id: 1, imageName: "onb2",
                                  title: L10n.onbPage2Title, description: L10n.onbPage2Desc),
                   OnboardingPage(id: 2, imageName: "onb3",
                                  title: L10n.onbPage3Title, description: L10n.onbPage3Desc)
               ]
        self.hasCompletedOnboarding = UserDefaults.standard.hasCompletedOnboarding
    }
    
    // MARK: — Inputs
    
    public func next() {
        guard currentPage < pages.count - 1 else {
            skip()
            return
        }
        currentPage += 1
        objectWillChange.send()                 // <-- уведомляем SwiftUI заранее
    }
    
    public func previous() {
        guard currentPage > 0 else { return }
        currentPage -= 1
        objectWillChange.send()
    }
    
    public func skip() {
        hasCompletedOnboarding = true
        UserDefaults.standard.hasCompletedOnboarding = true
        objectWillChange.send()
    }
}
//
//  OnboardingPage.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/26/25.
//


import Foundation

public struct OnboardingPage: Identifiable {
  public let id: Int
  public let imageName: String
  public let title: String
  public let description: String

  public init(
    id: Int,
    imageName: String,
    title: String,
    description: String
  ) {
    self.id = id
    self.imageName = imageName
    self.title = title
    self.description = description
  }
}
//
//  OnboardingView.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/26/25.
//

import SwiftUI

public struct OnboardingView<VM: OnboardingViewModelProtocol>: View {
    @ObservedObject private var vm: VM

    public init(vm: VM) { self.vm = vm }

    public var body: some View {
        ZStack {
            Color(DesignTokens.colorBackground).ignoresSafeArea()

            VStack(spacing: DesignTokens.spacingMedium) {
                Spacer()

                // Картинка текущей страницы (простая анимация)
                ForEach(vm.pages, id: \.id) { page in
                    if page.id == vm.currentPage {
                        Image(page.imageName)
                            .resizable()
                            .scaledToFit()
                            .frame(maxHeight: 300.scale)
                            .padding(.horizontal, DesignTokens.spacingMedium)
                            .transition(
                                .asymmetric(
                                    insertion: .scale.combined(with: .opacity),
                                    removal: .scale.combined(with: .opacity)
                                )
                            )
                    }
                }

                Text(vm.pages[vm.currentPage].title)
                    .font(.headline)
                    .multilineTextAlignment(.center)
                    .padding(.horizontal, DesignTokens.spacingMedium)

                Text(vm.pages[vm.currentPage].description)
                    .font(.body)
                    .multilineTextAlignment(.center)
                    .padding(.horizontal, DesignTokens.spacingMedium)

                Spacer()

                // Пейдж-индикатор
                HStack(spacing: 5.scale) {
                    ForEach(vm.pages.indices, id: \.self) { idx in
                        Circle()
                            .fill(idx == vm.currentPage
                                  ? Color(DesignTokens.colorPrimary)
                                  : Color.gray.opacity(0.4))
                            .frame(width: 5.scale, height: 5.scale)
                            .scaleEffect(idx == vm.currentPage ? 1.2 : 1.0)
                    }
                }

                // Кнопки
                HStack {
                    if vm.currentPage > 0 {
                        Button(L10n.onbBack) {
                            withAnimation(.easeInOut) { vm.previous() }
                        }
                        .font(.body)
                        .accessibilityIdentifier("onboarding.back")
                        .padding(.trailing, DesignTokens.spacingMedium)
                    }

                    Spacer()

                    Button(vm.currentPage == vm.pages.count - 1 ? L10n.onbGetStarted : L10n.onbNext) {
                        withAnimation(.easeInOut) { vm.next() }
                    }
                    .font(.body)
                    .accessibilityIdentifier(
                        vm.currentPage == vm.pages.count - 1
                        ? "onboarding.get_started" : "onboarding.next"
                    )
                }
                .padding(.horizontal, DesignTokens.spacingMedium)
            }
            .foregroundColor(.primary)
        }
        .animation(.spring(response: 0.5, dampingFraction: 0.7), value: vm.currentPage)
    }
}
# Autogenerated by fastlane
#
# Ensure this file is checked in to source control!

gem 'fastlane-plugin-appicon'
app_identifier("niiazkhasanov.TravelBuddy") # поменяй на свой bundle id при необходимости
apple_id("niyaz.khasanov@gmail.com")     # не обязателен, если не выгружаешь в TestFlight
# fastlane/Fastfile
default_platform(:ios)

platform :ios do
  desc "UI Snapshots on simulator"
  lane :snapshots do
    # ⛑️ Увеличим время ожидания получения build settings (у тебя тут таймаутило)
    ENV["FASTLANE_XCODEBUILD_SETTINGS_TIMEOUT"] = "180" # сек
    ENV["FASTLANE_XCODEBUILD_SETTINGS_RETRIES"] = "2"

    # Абсолютный путь к .xcodeproj (так надежнее, т.к. Fastfile лежит в fastlane/)
    project_path = File.expand_path("../TravelBuddy.xcodeproj", __dir__)

    # 1) Прогреть SPM (в CI это ускоряет snapshot, локально тоже полезно)
    sh %(
      xcodebuild -resolvePackageDependencies \
        -project "#{project_path}" \
        -onlyUsePackageVersionsFromResolvedFile \
        -disableAutomaticPackageResolution
    )

    # 2) Снимки — запускаем ТОЛЬКО наш класс снапшотов
    snapshot(
      project: project_path,
      scheme:  "TravelBuddy",

      # Запускаем только нужный класс/таргет UI-тестов
      test_target_name: "TravelBuddyUITests",
      only_testing:     ["TravelBuddyUITests/TravelBuddySnapshotUITests"],

      # Вывод/артефакты
      output_directory: "fastlane/screenshots",
      derived_data_path: "fastlane/DerivedData",
      result_bundle: false,          # чтобы ретраи не падали на "Existing file at -resultBundlePath"
      number_of_retries: 0,
      xcodebuild_formatter: "xcbeautify",

      # Сборка/симулятор
      reinstall_app: true,           # каждый прогон — чистое приложение (но без wipe DerivedData)
      clean: false,
      erase_simulator: false,
      concurrent_simulators: false,
      headless: true,
      override_status_bar: true,

      # SPM
      skip_package_dependencies_resolution: true,
      disable_package_automatic_updates: true,

      # Флаги в приложение — включаем режим UI-тестов и локальные данные
      launch_arguments: ["-uiTesting", "1", "-uiMockData", "1"]
    )
  end
end
fastlane documentation
----

# Installation

Make sure you have the latest version of the Xcode command line tools installed:

```sh
xcode-select --install
```

For _fastlane_ installation instructions, see [Installing _fastlane_](https://docs.fastlane.tools/#installing-fastlane)

# Available Actions

## iOS

### ios lint

```sh
[bundle exec] fastlane ios lint
```

Run SwiftLint

### ios build_debug

```sh
[bundle exec] fastlane ios build_debug
```

Build Debug (simulator)

### ios archive_release

```sh
[bundle exec] fastlane ios archive_release
```

Archive Release (device)

### ios export_ipa

```sh
[bundle exec] fastlane ios export_ipa
```

Export IPA (ad-hoc)

### ios snapshots

```sh
[bundle exec] fastlane ios snapshots
```

Run UI snapshots via fastlane snapshot

### ios ci

```sh
[bundle exec] fastlane ios ci
```

CI lane

----

This README.md is auto-generated and will be re-generated every time [_fastlane_](https://fastlane.tools) is run.

More information about _fastlane_ can be found on [fastlane.tools](https://fastlane.tools).

The documentation of _fastlane_ can be found on [docs.fastlane.tools](https://docs.fastlane.tools).
<?xml version="1.0" encoding="UTF-8"?>
<testsuites>
  <testsuite name="fastlane.lanes">
    
    
    
      
      <testcase classname="fastlane.lanes" name="0: default_platform" time="0.000187">
        
      </testcase>
    
      
      <testcase classname="fastlane.lanes" name="1: clear_derived_data" time="6.327153">
        
      </testcase>
    
      
      <testcase classname="fastlane.lanes" name="2: snapshot" time="148.061438">
        
          <failure message="/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/fastlane-2.228.0/fastlane/lib/fastlane/actions/actions_helper.rb:67:in `execute_action&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/fastlane-2.228.0/fastlane/lib/fastlane/runner.rb:255:in `block in execute_action&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/fastlane-2.228.0/fastlane/lib/fastlane/runner.rb:229:in `chdir&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/fastlane-2.228.0/fastlane/lib/fastlane/runner.rb:229:in `execute_action&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/fastlane-2.228.0/fastlane/lib/fastlane/runner.rb:157:in `trigger_action_by_name&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/fastlane-2.228.0/fastlane/lib/fastlane/fast_file.rb:159:in `method_missing&apos;&#10;Fastfile:41:in `block (2 levels) in parsing_binding&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/fastlane-2.228.0/fastlane/lib/fastlane/lane.rb:41:in `call&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/fastlane-2.228.0/fastlane/lib/fastlane/runner.rb:49:in `block in execute&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/fastlane-2.228.0/fastlane/lib/fastlane/runner.rb:45:in `chdir&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/fastlane-2.228.0/fastlane/lib/fastlane/runner.rb:45:in `execute&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/fastlane-2.228.0/fastlane/lib/fastlane/lane_manager.rb:46:in `cruise_lane&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/fastlane-2.228.0/fastlane/lib/fastlane/command_line_handler.rb:34:in `handle&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/fastlane-2.228.0/fastlane/lib/fastlane/commands_generator.rb:110:in `block (2 levels) in run&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/commander-4.6.0/lib/commander/command.rb:187:in `call&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/commander-4.6.0/lib/commander/command.rb:157:in `run&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/commander-4.6.0/lib/commander/runner.rb:444:in `run_active_command&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/fastlane-2.228.0/fastlane_core/lib/fastlane_core/ui/fastlane_runner.rb:124:in `run!&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/commander-4.6.0/lib/commander/delegates.rb:18:in `run!&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/fastlane-2.228.0/fastlane/lib/fastlane/commands_generator.rb:363:in `run&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/fastlane-2.228.0/fastlane/lib/fastlane/commands_generator.rb:43:in `start&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/fastlane-2.228.0/fastlane/lib/fastlane/cli_tools_distributor.rb:123:in `take_off&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/fastlane-2.228.0/bin/fastlane:23:in `&lt;top (required)&gt;&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/bin/fastlane:25:in `load&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/bin/fastlane:25:in `&lt;top (required)&gt;&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/bundler-2.6.9/lib/bundler/cli/exec.rb:59:in `load&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/bundler-2.6.9/lib/bundler/cli/exec.rb:59:in `kernel_load&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/bundler-2.6.9/lib/bundler/cli/exec.rb:23:in `run&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/bundler-2.6.9/lib/bundler/cli.rb:452:in `exec&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/bundler-2.6.9/lib/bundler/vendor/thor/lib/thor/command.rb:28:in `run&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/bundler-2.6.9/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/bundler-2.6.9/lib/bundler/vendor/thor/lib/thor.rb:538:in `dispatch&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/bundler-2.6.9/lib/bundler/cli.rb:35:in `dispatch&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/bundler-2.6.9/lib/bundler/vendor/thor/lib/thor/base.rb:584:in `start&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/bundler-2.6.9/lib/bundler/cli.rb:29:in `start&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/bundler-2.6.9/exe/bundle:28:in `block in &lt;top (required)&gt;&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/bundler-2.6.9/lib/bundler/friendly_errors.rb:117:in `with_friendly_errors&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/bundler-2.6.9/exe/bundle:20:in `&lt;top (required)&gt;&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/bin/bundle:25:in `load&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/bin/bundle:25:in `&lt;main&gt;&apos;&#10;&#10;Exit status: 74" />
        
      </testcase>
    
  </testsuite>
</testsuites>
# fastlane/Snapfile
project "./TravelBuddy.xcodeproj"
scheme "TravelBuddy"

# Минимальная матрица для стабильности и скорости
devices(["iPhone 16 Pro"])
languages(["en-US"])

output_directory "fastlane/screenshots"
derived_data_path "fastlane/DerivedData"

reinstall_app true
erase_simulator false
concurrent_simulators false
headless true
override_status_bar true

# Передаём флаги в приложение (см. AppFlags)
launch_arguments ["-uiTesting", "1", "-uiMockData", "1"]

# Оптимизация по SPM
skip_package_dependencies_resolution true
disable_package_automatic_updates true

# Без ретраев и без result bundle — меньше шансов упасть по артефактам
result_bundle false
number_of_retries 0

xcodebuild_formatter "xcbeautify"
name: iOS CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

permissions:
  contents: read

concurrency:
  group: ios-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # build:
  #   name: Build + Lint
  #   runs-on: macos-15
  #   timeout-minutes: 60
  #   steps:
  #     - name: Checkout
  #       uses: actions/checkout@v4
  #     - name: Select Xcode
  #       run: |
  #         XCODE="/Applications/Xcode.app"
  #         sudo xcode-select -s "$XCODE"
  #         xcodebuild -version
  #     - name: Cache Ruby gems
  #       uses: actions/cache@v4
  #       with:
  #         path: vendor/bundle
  #         key: ${{ runner.os }}-gems-${{ hashFiles('**/Gemfile.lock') }}
  #         restore-keys: |
  #           ${{ runner.os }}-gems-
  #     - name: Setup Ruby
  #       uses: ruby/setup-ruby@v1
  #       with:
  #         ruby-version: '3.2'
  #         bundler-cache: true
  #     - name: Install Bundler deps
  #       run: bundle install --path vendor/bundle
  #     - name: Install SwiftLint
  #       run: brew install swiftlint || true
  #     - name: Install xcpretty
  #       run: gem install xcpretty
  #     - name: Lint
  #       run: swiftlint
  #     - name: Build (Debug, simulator)
  #       run: |
  #         set -e
  #         xcodebuild \
  #           -scheme TravelBuddy \
  #           -sdk iphonesimulator \
  #           -configuration Debug \
  #           -destination 'platform=iOS Simulator,name=iPhone 16 Pro' \
  #           -skipPackagePluginValidation \
  #           -skipMacroValidation \
  #           clean build | xcpretty
  #       env:
  #         NSUnbufferedIO: YES
  #     - name: Archive (Release, device)
  #       run: |
  #         xcodebuild \
  #           -scheme TravelBuddy \
  #           -configuration Release \
  #           -sdk iphoneos \
  #           -archivePath build/TravelBuddy.xcarchive \
  #           -skipPackagePluginValidation \
  #           -skipMacroValidation \
  #           archive | xcpretty
  #     - name: Export .ipa (ad-hoc)
  #       if: ${{ always() }}
  #       run: |
  #         cat > ExportOptions.plist <<'PLIST'
  #         <?xml version="1.0" encoding="UTF-8"?>
  #         <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
  #         <plist version="1.0">
  #         <dict>
  #           <key>method</key><string>ad-hoc</string>
  #           <key>signingStyle</key><string>automatic</string>
  #           <key>compileBitcode</key><false/>
  #           <key>destination</key><string>export</string>
  #           <key>stripSwiftSymbols</key><true/>
  #         </dict>
  #         </plist>
  #         PLIST
  #         if [ -d "build/TravelBuddy.xcarchive" ]; then
  #           xcodebuild -exportArchive \
  #             -archivePath build/TravelBuddy.xcarchive \
  #             -exportOptionsPlist ExportOptions.plist \
  #             -exportPath build/export | xcpretty
  #         else
  #           echo "Archive not found, skipping export."
  #         fi
  #       continue-on-error: true
  #     - name: Upload artifacts
  #       if: ${{ always() }}
  #       uses: actions/upload-artifact@v4
  #       with:
  #         name: build-artifacts
  #         path: |
  #           build/TravelBuddy.xcarchive
  #           build/export/*.ipa
  #           fastlane/logs

  snapshots:
    name: UI Snapshots (fastlane)
    runs-on: macos-15
    timeout-minutes: 60
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Select Xcode
        run: |
          XCODE="/Applications/Xcode.app"
          sudo xcode-select -s "$XCODE"
          xcodebuild -version

      - name: Cache Ruby gems
        uses: actions/cache@v4
        with:
          path: vendor/bundle
          key: ${{ runner.os }}-gems-${{ hashFiles('**/Gemfile.lock') }}
          restore-keys: |
            ${{ runner.os }}-gems-

      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2'
          bundler-cache: true

      - name: Install Bundler deps
        run: bundle install --path vendor/bundle

      - name: List simulators (debug)
        run: xcrun simctl list devices

      # >>> КЭШ SwiftPM — максимальный профит по времени
      - name: Cache SwiftPM
        uses: actions/cache@v4
        with:
          path: |
            ~/Library/Caches/org.swift.swiftpm
            ~/Library/Developer/Xcode/PackageCaches
            ~/.swiftpm
          key: ${{ runner.os }}-spm-${{ hashFiles('**/Package.resolved') }}
          restore-keys: |
            ${{ runner.os }}-spm-

      # Прогреваем резолвинг пакетов (возьмёт из кэша)
      - name: Resolve SPM
        run: |
          xcodebuild -resolvePackageDependencies \
            -project ./TravelBuddy.xcodeproj \
            -onlyUsePackageVersionsFromResolvedFile \
            -disableAutomaticPackageResolution

      - name: Run fastlane snapshots
        env:
          FASTLANE_SNAPSHOT: "YES"
          LC_ALL: en_US.UTF-8
          LANG: en_US.UTF-8
          FASTLANE_XCODEBUILD_SETTINGS_TIMEOUT: "180"  # ⬅️ синхронно с Fastfile
          FASTLANE_XCODEBUILD_SETTINGS_RETRIES: "2"
        run: bundle exec fastlane snapshots

      - name: Upload screenshots
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: ui-screenshots
          path: fastlane/screenshots
source "https://rubygems.org"

gem "fastlane"
gem "xcpretty"
GEM
  remote: https://rubygems.org/
  specs:
    CFPropertyList (3.0.7)
      base64
      nkf
      rexml
    addressable (2.8.7)
      public_suffix (>= 2.0.2, < 7.0)
    artifactory (3.0.17)
    atomos (0.1.3)
    aws-eventstream (1.4.0)
    aws-partitions (1.1120.0)
    aws-sdk-core (3.226.1)
      aws-eventstream (~> 1, >= 1.3.0)
      aws-partitions (~> 1, >= 1.992.0)
      aws-sigv4 (~> 1.9)
      base64
      jmespath (~> 1, >= 1.6.1)
      logger
    aws-sdk-kms (1.105.0)
      aws-sdk-core (~> 3, >= 3.225.0)
      aws-sigv4 (~> 1.5)
    aws-sdk-s3 (1.191.0)
      aws-sdk-core (~> 3, >= 3.225.0)
      aws-sdk-kms (~> 1)
      aws-sigv4 (~> 1.5)
    aws-sigv4 (1.12.1)
      aws-eventstream (~> 1, >= 1.0.2)
    babosa (1.0.4)
    base64 (0.3.0)
    claide (1.1.0)
    colored (1.2)
    colored2 (3.1.2)
    commander (4.6.0)
      highline (~> 2.0.0)
    declarative (0.0.20)
    digest-crc (0.7.0)
      rake (>= 12.0.0, < 14.0.0)
    domain_name (0.6.20240107)
    dotenv (2.8.1)
    emoji_regex (3.2.3)
    excon (0.112.0)
    faraday (1.10.4)
      faraday-em_http (~> 1.0)
      faraday-em_synchrony (~> 1.0)
      faraday-excon (~> 1.1)
      faraday-httpclient (~> 1.0)
      faraday-multipart (~> 1.0)
      faraday-net_http (~> 1.0)
      faraday-net_http_persistent (~> 1.0)
      faraday-patron (~> 1.0)
      faraday-rack (~> 1.0)
      faraday-retry (~> 1.0)
      ruby2_keywords (>= 0.0.4)
    faraday-cookie_jar (0.0.7)
      faraday (>= 0.8.0)
      http-cookie (~> 1.0.0)
    faraday-em_http (1.0.0)
    faraday-em_synchrony (1.0.1)
    faraday-excon (1.1.0)
    faraday-httpclient (1.0.1)
    faraday-multipart (1.1.1)
      multipart-post (~> 2.0)
    faraday-net_http (1.0.2)
    faraday-net_http_persistent (1.2.0)
    faraday-patron (1.0.0)
    faraday-rack (1.0.0)
    faraday-retry (1.0.3)
    faraday_middleware (1.2.1)
      faraday (~> 1.0)
    fastimage (2.4.0)
    fastlane (2.228.0)
      CFPropertyList (>= 2.3, < 4.0.0)
      addressable (>= 2.8, < 3.0.0)
      artifactory (~> 3.0)
      aws-sdk-s3 (~> 1.0)
      babosa (>= 1.0.3, < 2.0.0)
      bundler (>= 1.12.0, < 3.0.0)
      colored (~> 1.2)
      commander (~> 4.6)
      dotenv (>= 2.1.1, < 3.0.0)
      emoji_regex (>= 0.1, < 4.0)
      excon (>= 0.71.0, < 1.0.0)
      faraday (~> 1.0)
      faraday-cookie_jar (~> 0.0.6)
      faraday_middleware (~> 1.0)
      fastimage (>= 2.1.0, < 3.0.0)
      fastlane-sirp (>= 1.0.0)
      gh_inspector (>= 1.1.2, < 2.0.0)
      google-apis-androidpublisher_v3 (~> 0.3)
      google-apis-playcustomapp_v1 (~> 0.1)
      google-cloud-env (>= 1.6.0, < 2.0.0)
      google-cloud-storage (~> 1.31)
      highline (~> 2.0)
      http-cookie (~> 1.0.5)
      json (< 3.0.0)
      jwt (>= 2.1.0, < 3)
      mini_magick (>= 4.9.4, < 5.0.0)
      multipart-post (>= 2.0.0, < 3.0.0)
      naturally (~> 2.2)
      optparse (>= 0.1.1, < 1.0.0)
      plist (>= 3.1.0, < 4.0.0)
      rubyzip (>= 2.0.0, < 3.0.0)
      security (= 0.1.5)
      simctl (~> 1.6.3)
      terminal-notifier (>= 2.0.0, < 3.0.0)
      terminal-table (~> 3)
      tty-screen (>= 0.6.3, < 1.0.0)
      tty-spinner (>= 0.8.0, < 1.0.0)
      word_wrap (~> 1.0.0)
      xcodeproj (>= 1.13.0, < 2.0.0)
      xcpretty (~> 0.4.1)
      xcpretty-travis-formatter (>= 0.0.3, < 2.0.0)
    fastlane-sirp (1.0.0)
      sysrandom (~> 1.0)
    gh_inspector (1.1.3)
    google-apis-androidpublisher_v3 (0.54.0)
      google-apis-core (>= 0.11.0, < 2.a)
    google-apis-core (0.11.3)
      addressable (~> 2.5, >= 2.5.1)
      googleauth (>= 0.16.2, < 2.a)
      httpclient (>= 2.8.1, < 3.a)
      mini_mime (~> 1.0)
      representable (~> 3.0)
      retriable (>= 2.0, < 4.a)
      rexml
    google-apis-iamcredentials_v1 (0.17.0)
      google-apis-core (>= 0.11.0, < 2.a)
    google-apis-playcustomapp_v1 (0.13.0)
      google-apis-core (>= 0.11.0, < 2.a)
    google-apis-storage_v1 (0.31.0)
      google-apis-core (>= 0.11.0, < 2.a)
    google-cloud-core (1.8.0)
      google-cloud-env (>= 1.0, < 3.a)
      google-cloud-errors (~> 1.0)
    google-cloud-env (1.6.0)
      faraday (>= 0.17.3, < 3.0)
    google-cloud-errors (1.5.0)
    google-cloud-storage (1.47.0)
      addressable (~> 2.8)
      digest-crc (~> 0.4)
      google-apis-iamcredentials_v1 (~> 0.1)
      google-apis-storage_v1 (~> 0.31.0)
      google-cloud-core (~> 1.6)
      googleauth (>= 0.16.2, < 2.a)
      mini_mime (~> 1.0)
    googleauth (1.8.1)
      faraday (>= 0.17.3, < 3.a)
      jwt (>= 1.4, < 3.0)
      multi_json (~> 1.11)
      os (>= 0.9, < 2.0)
      signet (>= 0.16, < 2.a)
    highline (2.0.3)
    http-cookie (1.0.8)
      domain_name (~> 0.5)
    httpclient (2.9.0)
      mutex_m
    jmespath (1.6.2)
    json (2.12.2)
    jwt (2.10.1)
      base64
    logger (1.7.0)
    mini_magick (4.13.2)
    mini_mime (1.1.5)
    multi_json (1.15.0)
    multipart-post (2.4.1)
    mutex_m (0.3.0)
    nanaimo (0.4.0)
    naturally (2.3.0)
    nkf (0.2.0)
    optparse (0.6.0)
    os (1.1.4)
    plist (3.7.2)
    public_suffix (6.0.2)
    rake (13.3.0)
    representable (3.2.0)
      declarative (< 0.1.0)
      trailblazer-option (>= 0.1.1, < 0.2.0)
      uber (< 0.2.0)
    retriable (3.1.2)
    rexml (3.4.1)
    rouge (3.28.0)
    ruby2_keywords (0.0.5)
    rubyzip (2.4.1)
    security (0.1.5)
    signet (0.20.0)
      addressable (~> 2.8)
      faraday (>= 0.17.5, < 3.a)
      jwt (>= 1.5, < 3.0)
      multi_json (~> 1.10)
    simctl (1.6.10)
      CFPropertyList
      naturally
    sysrandom (1.0.5)
    terminal-notifier (2.0.0)
    terminal-table (3.0.2)
      unicode-display_width (>= 1.1.1, < 3)
    trailblazer-option (0.1.2)
    tty-cursor (0.7.1)
    tty-screen (0.8.2)
    tty-spinner (0.9.3)
      tty-cursor (~> 0.7)
    uber (0.1.0)
    unicode-display_width (2.6.0)
    word_wrap (1.0.0)
    xcodeproj (1.27.0)
      CFPropertyList (>= 2.3.3, < 4.0)
      atomos (~> 0.1.3)
      claide (>= 1.0.2, < 2.0)
      colored2 (~> 3.1)
      nanaimo (~> 0.4.0)
      rexml (>= 3.3.6, < 4.0)
    xcpretty (0.4.1)
      rouge (~> 3.28.0)
    xcpretty-travis-formatter (1.0.1)
      xcpretty (~> 0.2, >= 0.0.7)

PLATFORMS
  arm64-darwin-24
  ruby

DEPENDENCIES
  fastlane
  xcpretty

BUNDLED WITH
   2.6.9
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleURLTypes</key>
	<array>
		<dict>
			<key>CFBundleTypeRole</key>
			<string>Editor</string>
			<key>CFBundleURLName</key>
			<string>com.niiaz.travelbuddy</string>
			<key>CFBundleURLSchemes</key>
			<array>
				<string>travelbuddy</string>
			</array>
		</dict>
	</array>
	<key>UIApplicationSceneManifest</key>
	<dict>
		<key>UIApplicationSupportsMultipleScenes</key>
		<false/>
		<key>UISceneConfigurations</key>
		<dict>
			<key>UIWindowSceneSessionRoleApplication</key>
			<array>
				<dict>
					<key>UISceneConfigurationName</key>
					<string>Default Configuration</string>
					<key>UISceneDelegateClassName</key>
					<string>$(PRODUCT_MODULE_NAME).SceneDelegate</string>
					<key>UISceneStoryboardFile</key>
					<string>Main</string>
				</dict>
			</array>
		</dict>
	</dict>
	<key>UIBackgroundModes</key>
	<array>
		<string>remote-notification</string>
	</array>
</dict>
</plist>
