//
//  TravelBuddyUITestsLaunchTests.swift
//  TravelBuddyUITests
//
//  Created by Niiaz Khasanov on 10/1/25.
//

import XCTest

final class TravelBuddyUITestsLaunchTests: XCTestCase {

    override class var runsForEachTargetApplicationUIConfiguration: Bool {
        true
    }

    override func setUpWithError() throws {
        continueAfterFailure = false
    }

    @MainActor
    func testLaunch() throws {
        let app = XCUIApplication()
        app.launch()

        // Insert steps here to perform after app launch but before taking a screenshot,
        // such as logging into a test account or navigating somewhere in the app

        let attachment = XCTAttachment(screenshot: app.screenshot())
        attachment.name = "Launch Screen"
        attachment.lifetime = .keepAlways
        add(attachment)
    }
}
//
//  SnapshotHelper.swift
//  Example
//
//  Created by Felix Krause on 10/8/15.
//

// -----------------------------------------------------
// IMPORTANT: When modifying this file, make sure to
//            increment the version number at the very
//            bottom of the file to notify users about
//            the new SnapshotHelper.swift
// -----------------------------------------------------

import Foundation
import XCTest

@MainActor
func setupSnapshot(_ app: XCUIApplication, waitForAnimations: Bool = true) {
    Snapshot.setupSnapshot(app, waitForAnimations: waitForAnimations)
}

@MainActor
func snapshot(_ name: String, waitForLoadingIndicator: Bool) {
    if waitForLoadingIndicator {
        Snapshot.snapshot(name)
    } else {
        Snapshot.snapshot(name, timeWaitingForIdle: 0)
    }
}

/// - Parameters:
///   - name: The name of the snapshot
///   - timeout: Amount of seconds to wait until the network loading indicator disappears. Pass `0` if you don't want to wait.
@MainActor
func snapshot(_ name: String, timeWaitingForIdle timeout: TimeInterval = 20) {
    Snapshot.snapshot(name, timeWaitingForIdle: timeout)
}

enum SnapshotError: Error, CustomDebugStringConvertible {
    case cannotFindSimulatorHomeDirectory
    case cannotRunOnPhysicalDevice

    var debugDescription: String {
        switch self {
        case .cannotFindSimulatorHomeDirectory:
            return "Couldn't find simulator home location. Please, check SIMULATOR_HOST_HOME env variable."
        case .cannotRunOnPhysicalDevice:
            return "Can't use Snapshot on a physical device."
        }
    }
}

@objcMembers
@MainActor
open class Snapshot: NSObject {
    static var app: XCUIApplication?
    static var waitForAnimations = true
    static var cacheDirectory: URL?
    static var screenshotsDirectory: URL? {
        return cacheDirectory?.appendingPathComponent("screenshots", isDirectory: true)
    }
    static var deviceLanguage = ""
    static var currentLocale = ""

    open class func setupSnapshot(_ app: XCUIApplication, waitForAnimations: Bool = true) {

        Snapshot.app = app
        Snapshot.waitForAnimations = waitForAnimations

        do {
            let cacheDir = try getCacheDirectory()
            Snapshot.cacheDirectory = cacheDir
            setLanguage(app)
            setLocale(app)
            setLaunchArguments(app)
        } catch let error {
            NSLog(error.localizedDescription)
        }
    }

    class func setLanguage(_ app: XCUIApplication) {
        guard let cacheDirectory = self.cacheDirectory else {
            NSLog("CacheDirectory is not set - probably running on a physical device?")
            return
        }

        let path = cacheDirectory.appendingPathComponent("language.txt")

        do {
            let trimCharacterSet = CharacterSet.whitespacesAndNewlines
            deviceLanguage = try String(contentsOf: path, encoding: .utf8).trimmingCharacters(in: trimCharacterSet)
            app.launchArguments += ["-AppleLanguages", "(\(deviceLanguage))"]
        } catch {
            NSLog("Couldn't detect/set language...")
        }
    }

    class func setLocale(_ app: XCUIApplication) {
        guard let cacheDirectory = self.cacheDirectory else {
            NSLog("CacheDirectory is not set - probably running on a physical device?")
            return
        }

        let path = cacheDirectory.appendingPathComponent("locale.txt")

        do {
            let trimCharacterSet = CharacterSet.whitespacesAndNewlines
            currentLocale = try String(contentsOf: path, encoding: .utf8).trimmingCharacters(in: trimCharacterSet)
        } catch {
            NSLog("Couldn't detect/set locale...")
        }

        if currentLocale.isEmpty && !deviceLanguage.isEmpty {
            currentLocale = Locale(identifier: deviceLanguage).identifier
        }

        if !currentLocale.isEmpty {
            app.launchArguments += ["-AppleLocale", "\"\(currentLocale)\""]
        }
    }

    class func setLaunchArguments(_ app: XCUIApplication) {
        guard let cacheDirectory = self.cacheDirectory else {
            NSLog("CacheDirectory is not set - probably running on a physical device?")
            return
        }

        let path = cacheDirectory.appendingPathComponent("snapshot-launch_arguments.txt")
        app.launchArguments += ["-FASTLANE_SNAPSHOT", "YES", "-ui_testing"]

        do {
            let launchArguments = try String(contentsOf: path, encoding: String.Encoding.utf8)
            let regex = try NSRegularExpression(pattern: "(\\\".+?\\\"|\\S+)", options: [])
            let matches = regex.matches(in: launchArguments, options: [], range: NSRange(location: 0, length: launchArguments.count))
            let results = matches.map { result -> String in
                (launchArguments as NSString).substring(with: result.range)
            }
            app.launchArguments += results
        } catch {
            NSLog("Couldn't detect/set launch_arguments...")
        }
    }

    open class func snapshot(_ name: String, timeWaitingForIdle timeout: TimeInterval = 20) {
        if timeout > 0 {
            waitForLoadingIndicatorToDisappear(within: timeout)
        }

        NSLog("snapshot: \(name)") // more information about this, check out https://docs.fastlane.tools/actions/snapshot/#how-does-it-work

        if Snapshot.waitForAnimations {
            sleep(1) // Waiting for the animation to be finished (kind of)
        }

        #if os(OSX)
            guard let app = self.app else {
                NSLog("XCUIApplication is not set. Please call setupSnapshot(app) before snapshot().")
                return
            }

            app.typeKey(XCUIKeyboardKeySecondaryFn, modifierFlags: [])
        #else

            guard self.app != nil else {
                NSLog("XCUIApplication is not set. Please call setupSnapshot(app) before snapshot().")
                return
            }

            let screenshot = XCUIScreen.main.screenshot()
            #if os(iOS) && !targetEnvironment(macCatalyst)
            let image = XCUIDevice.shared.orientation.isLandscape ?  fixLandscapeOrientation(image: screenshot.image) : screenshot.image
            #else
            let image = screenshot.image
            #endif

            guard var simulator = ProcessInfo().environment["SIMULATOR_DEVICE_NAME"], let screenshotsDir = screenshotsDirectory else { return }

            do {
                // The simulator name contains "Clone X of " inside the screenshot file when running parallelized UI Tests on concurrent devices
                let regex = try NSRegularExpression(pattern: "Clone [0-9]+ of ")
                let range = NSRange(location: 0, length: simulator.count)
                simulator = regex.stringByReplacingMatches(in: simulator, range: range, withTemplate: "")

                let path = screenshotsDir.appendingPathComponent("\(simulator)-\(name).png")
                #if swift(<5.0)
                    try UIImagePNGRepresentation(image)?.write(to: path, options: .atomic)
                #else
                    try image.pngData()?.write(to: path, options: .atomic)
                #endif
            } catch let error {
                NSLog("Problem writing screenshot: \(name) to \(screenshotsDir)/\(simulator)-\(name).png")
                NSLog(error.localizedDescription)
            }
        #endif
    }

    class func fixLandscapeOrientation(image: UIImage) -> UIImage {
        #if os(watchOS)
            return image
        #else
            if #available(iOS 10.0, *) {
                let format = UIGraphicsImageRendererFormat()
                format.scale = image.scale
                let renderer = UIGraphicsImageRenderer(size: image.size, format: format)
                return renderer.image { context in
                    image.draw(in: CGRect(x: 0, y: 0, width: image.size.width, height: image.size.height))
                }
            } else {
                return image
            }
        #endif
    }

    class func waitForLoadingIndicatorToDisappear(within timeout: TimeInterval) {
        #if os(tvOS)
            return
        #endif

        guard let app = self.app else {
            NSLog("XCUIApplication is not set. Please call setupSnapshot(app) before snapshot().")
            return
        }

        let networkLoadingIndicator = app.otherElements.deviceStatusBars.networkLoadingIndicators.element
        let networkLoadingIndicatorDisappeared = XCTNSPredicateExpectation(predicate: NSPredicate(format: "exists == false"), object: networkLoadingIndicator)
        _ = XCTWaiter.wait(for: [networkLoadingIndicatorDisappeared], timeout: timeout)
    }

    class func getCacheDirectory() throws -> URL {
        let cachePath = "Library/Caches/tools.fastlane"
        // on OSX config is stored in /Users/<username>/Library
        // and on iOS/tvOS/WatchOS it's in simulator's home dir
        #if os(OSX)
            let homeDir = URL(fileURLWithPath: NSHomeDirectory())
            return homeDir.appendingPathComponent(cachePath)
        #elseif arch(i386) || arch(x86_64) || arch(arm64)
            guard let simulatorHostHome = ProcessInfo().environment["SIMULATOR_HOST_HOME"] else {
                throw SnapshotError.cannotFindSimulatorHomeDirectory
            }
            let homeDir = URL(fileURLWithPath: simulatorHostHome)
            return homeDir.appendingPathComponent(cachePath)
        #else
            throw SnapshotError.cannotRunOnPhysicalDevice
        #endif
    }
}

private extension XCUIElementAttributes {
    var isNetworkLoadingIndicator: Bool {
        if hasAllowListedIdentifier { return false }

        let hasOldLoadingIndicatorSize = frame.size == CGSize(width: 10, height: 20)
        let hasNewLoadingIndicatorSize = frame.size.width.isBetween(46, and: 47) && frame.size.height.isBetween(2, and: 3)

        return hasOldLoadingIndicatorSize || hasNewLoadingIndicatorSize
    }

    var hasAllowListedIdentifier: Bool {
        let allowListedIdentifiers = ["GeofenceLocationTrackingOn", "StandardLocationTrackingOn"]

        return allowListedIdentifiers.contains(identifier)
    }

    func isStatusBar(_ deviceWidth: CGFloat) -> Bool {
        if elementType == .statusBar { return true }
        guard frame.origin == .zero else { return false }

        let oldStatusBarSize = CGSize(width: deviceWidth, height: 20)
        let newStatusBarSize = CGSize(width: deviceWidth, height: 44)

        return [oldStatusBarSize, newStatusBarSize].contains(frame.size)
    }
}

private extension XCUIElementQuery {
    var networkLoadingIndicators: XCUIElementQuery {
        let isNetworkLoadingIndicator = NSPredicate { (evaluatedObject, _) in
            guard let element = evaluatedObject as? XCUIElementAttributes else { return false }

            return element.isNetworkLoadingIndicator
        }

        return self.containing(isNetworkLoadingIndicator)
    }

    @MainActor
    var deviceStatusBars: XCUIElementQuery {
        guard let app = Snapshot.app else {
            fatalError("XCUIApplication is not set. Please call setupSnapshot(app) before snapshot().")
        }

        let deviceWidth = app.windows.firstMatch.frame.width

        let isStatusBar = NSPredicate { (evaluatedObject, _) in
            guard let element = evaluatedObject as? XCUIElementAttributes else { return false }

            return element.isStatusBar(deviceWidth)
        }

        return self.containing(isStatusBar)
    }
}

private extension CGFloat {
    func isBetween(_ numberA: CGFloat, and numberB: CGFloat) -> Bool {
        return numberA...numberB ~= self
    }
}

// Please don't remove the lines below
// They are used to detect outdated configuration files
// SnapshotHelperVersion [1.30]
//
//  TravelBuddySnapshotUITests.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 10/1/25.
//



import XCTest

@MainActor
final class TravelBuddySnapshotUITests: XCTestCase {

    private var app: XCUIApplication!

    override func setUp() {
        super.setUp()
        continueAfterFailure = false

        app = XCUIApplication()

        // Если используете fastlane snapshot, setupSnapshot(app) уже добавит свои аргументы/локаль.
        // Если у вас подключен SnapshotHelper.swift — раскомментируйте:
         setupSnapshot(app)

        // Рекомендовано пробрасывать флаги (опционально, если поддержаны приложением):
        // app.launchArguments += ["-uiTesting", "1", "-uiMockData", "1", "-uiPremium", "locked", "-skipOnboarding", "YES"]

        app.launch()
    }

    // MARK: - Главный сценарий скриншотов

     func testSnapshot_Onboarding_List_Map_Settings() {
        // --- 01: Onboarding page 1 ---
        // Ждем появления кнопки онбординга (id или текст), чтобы не сделать снимок "раньше времени"
        let onboardingNext = app.buttons["onboarding.next"]
        let onboardingNextText = app.buttons["Next"]
        XCTAssertTrue(
            onboardingNext.waitForExistence(timeout: 5) || onboardingNextText.waitForExistence(timeout: 5),
            "Onboarding page 1 did not appear"
        )
        snapshot("01-Onboarding-Page1")

        // Переходим на 2 страницу
        tapIfExists(onboardingNext, fallback: onboardingNextText)

        // Переходим на 3 страницу
        let onboardingNext2 = app.buttons["onboarding.next"]
        let onboardingNextText2 = app.buttons["Next"]
        tapIfExists(onboardingNext2, fallback: onboardingNextText2)

        // Завершаем онбординг
        let getStarted = app.buttons["onboarding.get_started"]
        let getStartedText = app.buttons["Get Started"]
        tapIfExists(getStarted, fallback: getStartedText)

        // --- 02: Places list ---
        // Убедимся, что мы на экране Places/Места
        let navPlaces = app.navigationBars["Places"]
        let navPlacesRu = app.navigationBars["Места"]
        XCTAssertTrue(navPlaces.waitForExistence(timeout: 5) || navPlacesRu.waitForExistence(timeout: 5),
                      "Places screen did not appear")

        // Ждем таблицу и первую ячейку (это убирает "ромашку" на снимке)
        let table = app.tables.firstMatch
        XCTAssertTrue(table.waitForExistence(timeout: 10), "Places table did not appear")

        let firstCell = table.cells.element(boundBy: 0)
        XCTAssertTrue(firstCell.waitForExistence(timeout: 20),
                      "Places first cell did not appear (waited for remote->fallback local)")

        snapshot("02-Places-List")

        // --- 03: POI Detail ---
        firstCell.tap()

        // Ждем появления элемента на экране детали:
        // используем кнопку закрытия, которая у тебя есть ("xmark.circle.fill").
        let closeButton = app.buttons["xmark.circle.fill"]
        XCTAssertTrue(closeButton.waitForExistence(timeout: 5), "POI Detail did not open")

        // Если есть доступный стабильный элемент (заголовок/кнопка share) — можно ждать его:
        // let share = app.buttons["detail.share"] // если в App выставлен identifier
        // _ = share.waitForExistence(timeout: 2)

        snapshot("03-POI-Detail")

        closeButton.tap()

        // --- 04: Map ---
        tapTab(labelEn: "Map", labelRu: "Карта")

        // Ждем устойчивый системный элемент карты внизу (Legal / Правовые документы)
        let legal = app.staticTexts["Legal"]
        let legalRu = app.staticTexts["Правовые документы"]
        XCTAssertTrue(legal.waitForExistence(timeout: 10) || legalRu.waitForExistence(timeout: 10),
                      "Map did not load 'Legal' label")

        snapshot("04-Map")

        // --- 05: Settings ---
        tapTab(labelEn: "Settings", labelRu: "Настройки")

        let settingsTitle = app.staticTexts["Settings"]
        let settingsTitleRu = app.staticTexts["Настройки"]
        XCTAssertTrue(settingsTitle.waitForExistence(timeout: 5) || settingsTitleRu.waitForExistence(timeout: 5),
                      "Settings screen did not appear")

        snapshot("05-Settings")
    }

    // MARK: - Helpers

    /// Тапаем element, если он существует; иначе — fallback.
    private func tapIfExists(_ element: XCUIElement, fallback: XCUIElement? = nil, timeout: TimeInterval = 2) {
        if element.waitForExistence(timeout: timeout) {
            element.tap()
        } else if let fb = fallback, fb.waitForExistence(timeout: timeout) {
            fb.tap()
        } else {
            XCTFail("Neither main element nor fallback existed for tap")
        }
    }

    /// Переход по табу. Сначала пытаемся по айдишникам (если добавишь их в приложении),
    /// затем по локализованным текстам, затем по первому табу.
    private func tapTab(labelEn: String, labelRu: String) {
        let tabBar = app.tabBars.firstMatch

        // 1) Попытка по identifier (добавь в приложении, если захочешь):
        let idCandidates = ["tab.places", "tab.map", "tab.settings"]
        for id in idCandidates {
            let btn = tabBar.buttons[id]
            if btn.exists {
                btn.tap()
                return
            }
        }

        // 2) По текстовым лейблам (как сейчас)
        let en = tabBar.buttons[labelEn]
        let ru = tabBar.buttons[labelRu]
        if en.exists { en.tap(); return }
        if ru.exists { ru.tap(); return }

        // 3) Фолбэк — любой первый таб
        if tabBar.buttons.count > 0 {
            tabBar.buttons.element(boundBy: 0).tap()
        } else {
            XCTFail("No tabs found")
        }
    }
}

 
//
//  TravelBuddyUITests.swift
//  TravelBuddyUITests
//
//  Created by Niiaz Khasanov on 10/1/25.
//

import XCTest

final class TravelBuddyUITests: XCTestCase {

    override func setUpWithError() throws {
        // Put setup code here. This method is called before the invocation of each test method in the class.

        // In UI tests it is usually best to stop immediately when a failure occurs.
        continueAfterFailure = false

        // In UI tests it’s important to set the initial state - such as interface orientation - required for your tests before they run. The setUp method is a good place to do this.
    }

    override func tearDownWithError() throws {
        // Put teardown code here. This method is called after the invocation of each test method in the class.
    }

    @MainActor
    func testExample() throws {
        // UI tests must launch the application that they test.
        let app = XCUIApplication()
        app.launch()

        // Use XCTAssert and related functions to verify your tests produce the correct results.
    }

    @MainActor
    func testLaunchPerformance() throws {
        // This measures how long it takes to launch your application.
        measure(metrics: [XCTApplicationLaunchMetric()]) {
            XCUIApplication().launch()
        }
    }
}
//
//  DesignTokens.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/20/25.
//

import UIKit

public enum DesignTokens {
    // MARK: Colors
    public static let colorPrimary = UIColor(hex: "#0055FF")!
    public static let colorBackground = UIColor { trait in
        trait.userInterfaceStyle == .dark
        ? UIColor(hex: "#000000")!
        : UIColor(hex: "#FFFFFF")!
    }
    
    // MARK: Typography
    public static let fontHeadline = UIFont.systemFont(ofSize: 24.scale, weight: .bold)
    public static let fontBody     = UIFont.systemFont(ofSize: 16.scale, weight: .regular)
    
    // MARK: Spacing
    public static let spacingSmall  = 8.scale
    public static let spacingMedium = 16.scale
    
}
//
//  L10n.swift
//  TravelBuddy
//

import Foundation

enum L10n {

    // MARK: - Internal helpers

    /// Возвращает локализованную строку по первому существующему ключу.
    private static func pick(_ keys: [String], _ comment: String) -> String {
        for k in keys {
            let v = NSLocalizedString(k, comment: comment)
            if v != k { return v } // ключ найден в .strings
        }
        // если ничего не нашли — вернём первую как есть (видно будет в UI)
        return NSLocalizedString(keys.first ?? "", comment: comment)
    }

    /// Формат для plural/параметров с фолбэком по нескольким ключам.
    private static func pickFormat(_ keys: [String], _ comment: String, _ args: CVarArg...) -> String {
        for k in keys {
            let fmt = NSLocalizedString(k, comment: comment)
            if fmt != k { return String(format: fmt, locale: .current, arguments: args) }
        }
        let fallback = NSLocalizedString(keys.first ?? "", comment: comment)
        return String(format: fallback, locale: .current, arguments: args)
    }

    // MARK: - Common
    static var alertOk: String { pick(["alert.ok"], "OK button") }
    static var alertErrorTitle: String { pick(["alert.error.title"], "Generic error alert title") }
    static var commonRetry: String { pick(["common.retry","list.retry"], "Retry") }
    static var commonClose: String { pick(["common.close"], "Close") }

    // MARK: - Tabs / Navigation titles
    static var tabPlaces: String { pick(["tab.places"], "Tab: Places") }
    static var tabMap: String { pick(["tab.map"], "Tab: Map") }
    static var tabSettings: String { pick(["tab.settings"], "Tab: Settings") }

    static var navPlacesTitle: String {
        pick(["nav.places.title","places.title","tab.places"], "Navigation title: Places")
    }
    static var navSettingsTitle: String {
        pick(["nav.settings.title","settings.title","tab.settings"], "Navigation title: Settings")
    }

    // MARK: - Settings
    static var settingsDarkMode: String {
        pick(["settings.darkmode","settings.dark_mode"], "Settings: Dark Mode")
    }
    static var settingsNotifications: String {
        pick(["settings.notifications"], "Settings: Notifications")
    }
    static var settingsPremiumUnlock: String {
        pick(["settings.premium.unlock"], "Settings: Unlock Premium")
    }
    static var settingsPremiumUnlocked: String {
        pick(["settings.premium.unlocked"], "Settings: Premium unlocked label")
    }

    // MARK: - List screen
    static var listCategoryTitle: String {
        pick(["list.category.title","places.category"], "Category picker title")
    }

    // Категории — поддерживаем обе схемы ключей
    static var catAll: String { pick(["category.all","places.category.all"], "Category: All") }
    static var catMonument: String { pick(["category.monument","places.category.monument"], "Category: Monument") }
    static var catMuseum: String { pick(["category.museum","places.category.museum"], "Category: Museum") }
    static var catCafe: String { pick(["category.cafe","places.category.cafe"], "Category: Cafe") }

    /// Плюралы «N places»
    static func listPlacesCount(_ n: Int) -> String {
        pickFormat(["list.places.count"], "Pluralized places count", n)
    }

    // MARK: - POI Detail / Snippet / Image
    static var detailLoadingAddress: String {
        pick(["detail.loading.address","poi.loading_address"], "Loading address…")
    }
    static var detailShare: String {
        pick(["detail.share","poi.share"], "Share button")
    }
    static var detailOpenInMaps: String {
        pick(["detail.openinmaps","poi.open_in_maps"], "Open in Maps")
    }

    static var snippetDetails: String { pick(["snippet.details","poi.details"], "Map snippet: Details") }
    static var snippetRoute: String { pick(["snippet.route","poi.route"], "Map snippet: Route") }

    static var imageNoImage: String { pick(["image.noimage","poi.image.none"], "No image placeholder") }
    static func imageInvalidPath(_ path: String) -> String {
        pickFormat(["image.invalid.path","poi.image.invalid_path"], "Invalid path", path)
    }
    static func imageMissingNamed(_ name: String) -> String {
        pickFormat(["poi.image.missing_named"], "Missing named image", name)
    }
    static func imagePath(_ path: String) -> String {
        pickFormat(["poi.image.path"], "Path label", path)
    }

    // MARK: - Onboarding (поддержка двух нейминг-схем)
    static var onboardingNext: String { pick(["onboarding.next","onb.next"], "Onboarding: Next") }
    static var onboardingBack: String { pick(["onboarding.back","onb.back"], "Onboarding: Back") }
    static var onboardingGetStarted: String { pick(["onboarding.get_started","onb.getstarted"], "Onboarding: Get Started") }

    static var onboardingTitle1: String { pick(["onboarding.title1","onb.p1.title"], "Onb page1 title") }
    static var onboardingDesc1: String  { pick(["onboarding.desc1","onb.p1.desc"], "Onb page1 desc") }
    static var onboardingTitle2: String { pick(["onboarding.title2","onb.p2.title"], "Onb page2 title") }
    static var onboardingDesc2: String  { pick(["onboarding.desc2","onb.p2.desc"], "Onb page2 desc") }
    static var onboardingTitle3: String { pick(["onboarding.title3","onb.p3.title"], "Onb page3 title") }
    static var onboardingDesc3: String  { pick(["onboarding.desc3","onb.p3.desc"], "Onb page3 desc") }

    // Для кода, который уже использует onb.*
    static var onbNext: String { onboardingNext }
    static var onbBack: String { onboardingBack }
    static var onbGetStarted: String { onboardingGetStarted }
    static var onbPage1Title: String { onboardingTitle1 }
    static var onbPage1Desc: String { onboardingDesc1 }
    static var onbPage2Title: String { onboardingTitle2 }
    static var onbPage2Desc: String { onboardingDesc2 }
    static var onbPage3Title: String { onboardingTitle3 }
    static var onbPage3Desc: String { onboardingDesc3 }

    // MARK: - DeepLink parsing errors
    static var deeplinkUnknownHost: String { pick(["deeplink.unknown_host"], "Unsupported link host") }
    static var deeplinkInvalidCoords: String { pick(["deeplink.invalid_coords"], "Invalid coordinates in deeplink") }
    static var deeplinkUnsupportedScheme: String { pick(["deeplink.unsupported_scheme"], "Unsupported url scheme") }

    // MARK: - DeepLink business errors
    static func deeplinkPoiNotFound(_ id: Int) -> String {
        pickFormat(["deeplink.poi.not_found"], "POI not found by ID", id)
    }
}
//
//  AppConfig.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 9/19/25.
//


import Foundation
import CoreLocation

public struct AppConfig {
    // MARK: — Network
    public let apiBaseURL: URL
    public let httpTimeout: TimeInterval

    // MARK: — Repository / Cache
    public let poiCacheTTL: TimeInterval

    // MARK: — IAP
    public struct IAP {
        public let premiumProductID: String
    }
    public let iap: IAP

    // MARK: — Local data / mocks
    public let localPOIJSONName: String

    // MARK: — Map defaults
    public let defaultRegionMeters: CLLocationDistance

    // MARK: — Feature Flags
    public struct Flags {
        public let enableDebugLogs: Bool
        public let useAlamofireClient: Bool  // на будущее
        public let showBLETab: Bool          // на будущее
        public let enableAudioGuide: Bool    // на будущее
    }
    public let flags: Flags
}


public extension AppConfig {
    static func makeDefault() -> AppConfig {
        #if DEBUG
        return AppConfig(
            apiBaseURL: URL(string: "https://api.example.com")!,
            httpTimeout: 0.15 ,
            poiCacheTTL: 300,
            iap: .init(premiumProductID: "com.travelbuddy.premium"),
            localPOIJSONName: "mock_pois_local",
            defaultRegionMeters: 4000,
            flags: .init(
                enableDebugLogs: true,
                useAlamofireClient: false,
                showBLETab: false,
                enableAudioGuide: false
            )
        )
        #else
        return AppConfig(
            apiBaseURL: URL(string: "https://api.example.com")!,
            httpTimeout: 15,
            poiCacheTTL: 300,
            iap: .init(premiumProductID: "com.travelbuddy.premium"),
            localPOIJSONName: "mock_pois_local",
            defaultRegionMeters: 4000,
            flags: .init(
                enableDebugLogs: false,
                useAlamofireClient: false,
                showBLETab: false,
                enableAudioGuide: false
            )
        )
        #endif
    }
}
//
//  AppRouter.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 9/12/25.
//


import Combine

@MainActor
public final class AppRouter: ObservableObject {
    public let events = PassthroughSubject<AppRoute, Never>()
    public init() {}
    public func send(_ route: AppRoute) { events.send(route) }
}
//
//  AppRoute.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 9/12/25.
//


import Foundation

public enum AppRoute: Equatable {
    case openPOIDetail(POI)
    case openMapWithPOI(POI.ID)
    case openSettings
}
//
//  Scalable.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/26/25.
//

import UIKit

protocol Scalable {
    var scale: Self { get }
}

extension CGFloat: Scalable {
    var scale: CGFloat {
        let designScreenWidth: CGFloat = 375
        let currentScreenWidth = UIScreen.main.bounds.size.width
        return self * currentScreenWidth / designScreenWidth
    }
   
}

extension Int {
    var scale: CGFloat {
        CGFloat(self).scale
    }
}

extension Double {
    var scale: CGFloat {
        CGFloat(self).scale
    }
}

extension CGPoint: Scalable {
    var scale: CGPoint {
        CGPoint(x: x.scale, y: y.scale)
    }
}

extension CGSize: Scalable {
    var scale: CGSize {
        CGSize(width: width.scale, height: height.scale)
    }
}

extension CGRect: Scalable {
    var scale: CGRect {
        CGRect(origin: origin.scale, size: size.scale)
    }
}

extension UIFont {
    var scale: UIFont {
        UIFont(name: fontName, size: pointSize.scale) ?? UIFont.systemFont(ofSize: pointSize.scale)
    }
}

extension UIEdgeInsets: Scalable {
    var scale: UIEdgeInsets {
        UIEdgeInsets(top: top.scale, left: left.scale, bottom: bottom.scale, right: right.scale)
    }
}
//
//  ScreenSize.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/26/25.
//


import UIKit

enum ScreenSize {
    static let bounds: CGRect = (UIScreen.main.bounds)
    static let width: CGFloat = (bounds.width)
    static let height: CGFloat = (bounds.height)
    static let maxLength: CGFloat = (max(width, height))
    static let minLength: CGFloat = (min(width, height))
    
    static let isIphone = UIDevice.current.userInterfaceIdiom == .phone
    static let isRetina = (UIScreen.main.scale >= 2.0)
    static let isIphoneXFamily = (isIphone && maxLength / minLength > 2.0)
}
//
//  UIColor+Hex.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/20/25.
//

import UIKit

public extension UIColor {
  convenience init?(hex: String) {
    var hexSanitized = hex.trimmingCharacters(in: .whitespacesAndNewlines)
    hexSanitized = hexSanitized.replacingOccurrences(of: "#", with: "")
    var rgb: UInt64 = 0
    guard Scanner(string: hexSanitized).scanHexInt64(&rgb) else { return nil }
    let r = CGFloat((rgb & 0xFF0000) >> 16) / 255
    let g = CGFloat((rgb & 0x00FF00) >> 8) / 255
    let b = CGFloat(rgb & 0x0000FF) / 255
    self.init(red: r, green: g, blue: b, alpha: 1)
  }
}
//
//  Publisher+Extensions.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/20/25.
//

import Combine

public extension Publisher {
  func logError(_ tag: String) -> AnyPublisher<Output, Failure> {
    handleEvents(receiveCompletion: { completion in
      if case let .failure(error) = completion {
          Swift.print("[\(tag)] Error:", error)
      }
    })
    .eraseToAnyPublisher()
  }
}
//
//  UserDefaults+AppStorage.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/26/25.
//

import Foundation

extension UserDefaults {
  // MARK: — Ключи
  private enum Keys {
    static let hasCompletedOnboarding = "hasCompletedOnboarding"
    // в будущем сюда можно добавлять другие ключи
  }

  // MARK: — Свойства
  var hasCompletedOnboarding: Bool {
    get { bool(forKey: Keys.hasCompletedOnboarding) }
    set { set(newValue, forKey: Keys.hasCompletedOnboarding) }
  }
}
//
//  UITabBarController+Alert.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 9/28/25.
//


import UIKit

extension UITabBarController {
    func presentAlert(title: String, message: String, okTitle: String) {
        let alert = UIAlertController(title: title, message: message, preferredStyle: .alert)
        alert.addAction(UIAlertAction(title: okTitle, style: .default))
        (selectedViewController ?? presentedViewController ?? self).present(alert, animated: true)
    }
}
//
//  AppCoordinator.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/26/25.
//

import UIKit
import SwiftUI
import Combine
import Swinject
import CoreLocation

protocol Coordinator {
    func start()
}

@MainActor
final class AppCoordinator: Coordinator {
    // MARK: - Dependencies
    private let window: UIWindow
    private let container: DIContainer

    // IAP
    private let iapObserver: IAPObserver
    private let iapService: IAPServiceProtocol

    // MARK: - UI State
    private let tabBar = UITabBarController()
    private var cancellables = Set<AnyCancellable>()

    // Навигация/роутеры, доступные из разных обработчиков
    private var appRouter: AppRouter!
    private var mapRouter: MapRouter!      // общий экземпляр для вкладки "Map"

    // MARK: - Init
    init(window: UIWindow, container: DIContainer? = nil) {
        self.window = window
        self.container = container ?? DIContainer.shared

        guard
            let observer = self.container.resolver.resolve(IAPObserver.self),
            let iapSvc   = self.container.resolver.resolve(IAPServiceProtocol.self)
        else {
            preconditionFailure("Swinject: IAPObserver/IAPServiceProtocol не зарегистрированы")
        }
        self.iapObserver = observer
        self.iapService  = iapSvc
    }

    // MARK: - Start
    func start() {
        window.makeKeyAndVisible()

        if UserDefaults.standard.hasCompletedOnboarding {
            showMainInterface()
        } else {
            showOnboarding()
        }
    }

    // MARK: - Onboarding
    private func showOnboarding() {
        guard let onboardingVM = container.resolver.resolve(AnyOnboardingViewModel.self) else {
            preconditionFailure("Swinject: AnyOnboardingViewModel не зарегистрирован")
        }

        let onboardingHost = UIHostingController(rootView: OnboardingView(vm: onboardingVM))
        window.rootViewController = onboardingHost

        onboardingVM.$hasCompletedOnboarding
            .filter { $0 }
            .first()
            .receive(on: DispatchQueue.main)
            .sink { [weak self] _ in
                self?.showMainInterface()
            }
            .store(in: &cancellables)
    }

    // MARK: - Main UI
    private func showMainInterface() {
        // AppRouter — один на все табы
        guard let appRouter = container.resolver.resolve(AppRouter.self) else {
            preconditionFailure("Swinject: AppRouter не зарегистрирован")
        }
        self.appRouter = appRouter

        // --- Places tab
        guard
            let poiListVM     = container.resolver.resolve(AnyPOIListViewModel.self),
            let poiListRouter = container.resolver.resolve(POIListRouter.self)
        else {
            preconditionFailure("Swinject: нет регистрации AnyPOIListViewModel или POIListRouter")
        }
        let poiListCoord = POIListCoordinator(viewModel: poiListVM, router: poiListRouter)
        let placesVC = UIHostingController(
            rootView: poiListCoord.rootView().environmentObject(appRouter)
        )
        placesVC.tabBarItem = UITabBarItem(title: L10n.tabPlaces, image: UIImage(systemName: "map"), tag: 0)

        // --- Map tab
        guard
            let mapVM     = container.resolver.resolve(AnyPOIMapViewModel.self),
            let mapRouter = container.resolver.resolve(MapRouter.self)
        else {
            preconditionFailure("Swinject: нет регистрации AnyPOIMapViewModel или MapRouter")
        }
        self.mapRouter = mapRouter // <— сохраняем ссылку для диплинков/роутинга
        let mapCoord = MapCoordinator(vm: mapVM, router: mapRouter)
        let mapVC = UIHostingController(
            rootView: mapCoord.rootView().environmentObject(appRouter)
        )
        mapVC.tabBarItem    = UITabBarItem(title: L10n.tabMap, image: UIImage(systemName: "map.fill"), tag: 1)
        
        // --- Settings tab
        guard let settingsVM = container.resolver.resolve(AnySettingsViewModel.self) else {
            preconditionFailure("Swinject: AnySettingsViewModel не зарегистрирован")
        }
        let settingsVC = UIHostingController(
            rootView: SettingsView(vm: settingsVM).environmentObject(appRouter)
        )
        settingsVC.tabBarItem = UITabBarItem(title: L10n.tabSettings, image: UIImage(systemName: "gearshape"), tag: 2)

        // --- Assemble
        tabBar.viewControllers = [placesVC, mapVC, settingsVC]
        window.rootViewController = tabBar

        // --- Bindings
        bindAppRouter(appRouter)
        bindDeepLinks()

        // --- IAP
        iapObserver.start()
        iapService.readCurrentPremiumEntitlement()
            .receive(on: DispatchQueue.main)
            .sink { _ in }
            .store(in: &cancellables)
    }

    // MARK: - Bind AppRouter
    private func bindAppRouter(_ appRouter: AppRouter) {
        appRouter.events
            .receive(on: DispatchQueue.main)
            .sink { [weak self] route in
                self?.handle(route)
            }
            .store(in: &cancellables)
    }

    // MARK: - Bind Deep Links
    private func bindDeepLinks() {
        guard let deeplinkService = container.resolver.resolve(DeepLinkHandling.self) else { return }

        // Успех — маршрутизируем в карту/табы
        deeplinkService
            .events
            .receive(on: DispatchQueue.main)
            .sink { [weak self] link in
                self?.handleDeepLink(link)
            }
            .store(in: &cancellables)

        // Ошибки парсинга/валидации диплинков — показываем глобальный алерт
        deeplinkService
            .errors
            .receive(on: DispatchQueue.main)
            .sink { [weak self] err in
                self?.presentDeepLinkError(err)
            }
            .store(in: &cancellables)
    }

    // MARK: - Show errors (GLOBAL)
    /// Глобальные ошибки диплинков (scheme/host/coords) — вне контекста Map-сцены.
    private func presentDeepLinkError(_ error: DeepLinkError) {
        let message: String
        switch error {
        case .unsupportedScheme:
            message = L10n.deeplinkUnsupportedScheme
        case .unknownHost:
            message = L10n.deeplinkUnknownHost
        case .invalidCoordinates:
            message = L10n.deeplinkInvalidCoords
        }

        tabBar.presentAlert(
            title: L10n.alertErrorTitle,
            message: message,
            okTitle: L10n.alertOk
        )
    }

    // MARK: - Handle AppRoute (из списков/настроек и т.п.)
    private func handle(_ route: AppRoute) {
        switch route {
        case .openPOIDetail:
            tabBar.selectedIndex = 0

        case .openMapWithPOI(let id):
            tabBar.selectedIndex = 1
            mapRouter?.focusPOI(id)

        case .openSettings:
            tabBar.selectedIndex = 2
        }
    }

    // MARK: - Handle Deep Link (SUCCESS)
    private func handleDeepLink(_ deeplink: DeepLink) {
        switch deeplink {
        case .mapCenter(let coord):
            tabBar.selectedIndex = 1
            mapRouter?.center(on: coord)

        case .poi(let id):
            tabBar.selectedIndex = 1
            // если такого POI в итоге нет — MapContainer сам покажет локализованный алерт
            // через router.showError(.poiNotFound(id)) по таймауту
            mapRouter?.focusPOI(id)
        }
    }
}
//
//  DIContainer.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/23/25.
//


// DIContainer.swift
import Foundation
import Swinject
import UIKit
import SwiftUI

@MainActor
public final class DIContainer {
    public static let shared = DIContainer()
    let container = Container()

    private init() {
        // 0) AppConfig —
        let config = AppConfig.makeDefault()
        container.register(AppConfig.self) { _ in config }
            .inObjectScope(.container)
      
        // DeepLink
        container.register(DeepLinkHandling.self) { _ in
            DeepLinkService()
        }.inObjectScope(.container)

        // 1) Core
        container.register(HTTPClientProtocol.self) { r in
            HTTPClient(timeout: r.resolve(AppConfig.self)!.httpTimeout)
        }.inObjectScope(.container)

        // 2) Services
        container.register(AnalyticsServiceProtocol.self) { _ in AnalyticsService() }
            .inObjectScope(.container)

        container.register(IAPServiceProtocol.self) { r in
            IAPService(config: r.resolve(AppConfig.self)!)
        }.inObjectScope(.container)

        container.register(IAPObserver.self) { r in
            IAPObserver(iap: r.resolve(IAPServiceProtocol.self)!)
        }.inObjectScope(.container)

        container.register(NotificationServiceProtocol.self) { _ in NotificationService() }
            .inObjectScope(.container)

        // 3) POI data stack
        container.register(RemotePOIService.self) { r in
            RemotePOIService(
                httpClient: r.resolve(HTTPClientProtocol.self)!,
                config: r.resolve(AppConfig.self)!
            )
        } // scope по умолчанию .graph — норм

        container.register(LocalPOIService.self) { r in
            LocalPOIService(config: r.resolve(AppConfig.self)!)
        }

        container.register(POICacheProtocol.self) { _ in RealmPOICache() }

        container.register(POIServiceProtocol.self) { r in
            POIRepository(
                remote: r.resolve(RemotePOIService.self)!,
                local:  r.resolve(LocalPOIService.self)!,
                cache:  r.resolve(POICacheProtocol.self)!,
                ttl:    r.resolve(AppConfig.self)!.poiCacheTTL
            )
        }.inObjectScope(.container)

        // 4) Onboarding
        container.register((any OnboardingViewModelProtocol).self) { _ in OnboardingViewModel() }
        container.register(AnyOnboardingViewModel.self) { r in
            AnyOnboardingViewModel(r.resolve((any OnboardingViewModelProtocol).self)!)
        }.inObjectScope(.graph)

        // 5) POIList scene
        container.register((any POIListViewModelProtocol).self) { r in
            POIListViewModel(repository: r.resolve(POIServiceProtocol.self)!)
        }.inObjectScope(.graph)

        container.register(AnyPOIListViewModel.self) { r in
            AnyPOIListViewModel(r.resolve((any POIListViewModelProtocol).self)!)
        }.inObjectScope(.graph)

        container.register(POIListRouter.self) { _ in POIListRouter() }
            .inObjectScope(.graph)

        // 6) Map scene
        container.register((any POIMapViewModelProtocol).self) { r in
            POIMapViewModel(
                service: r.resolve(POIServiceProtocol.self)!,
                factory: DefaultAnnotationFactory()
            )
        }.inObjectScope(.graph)

        container.register(AnyPOIMapViewModel.self) { r in
            AnyPOIMapViewModel(r.resolve((any POIMapViewModelProtocol).self)!)
        }.inObjectScope(.graph)

        container.register(MapRouter.self) { _ in MapRouter() }
            .inObjectScope(.graph)

        // 7) Settings scene
        container.register((any SettingsViewModelProtocol).self) { r in
            SettingsViewModel(
                iapService:   r.resolve(IAPServiceProtocol.self)!,
                analytics:    r.resolve(AnalyticsServiceProtocol.self)!,
                notification: r.resolve(NotificationServiceProtocol.self)!
            )
        }.inObjectScope(.graph)

        container.register(AnySettingsViewModel.self) { r in
            AnySettingsViewModel(r.resolve((any SettingsViewModelProtocol).self)!)
        }.inObjectScope(.graph)

        // 8) AppRouter и Detail
        container.register(AppRouter.self) { _ in AppRouter() }
            .inObjectScope(.container)

        container.register(POIDetailViewModel.self) { _, poi in
            POIDetailViewModel(poi: poi)
        }
        container.register(POIDetailCoordinator.self) { r, poi in
            POIDetailCoordinator(poi: poi, resolver: r)
        }.inObjectScope(.graph)
    }

    public var resolver: Resolver { container.synchronize() }
}
//
//  AppDelegate.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/19/25.
//

import UIKit

@main
class AppDelegate: UIResponder, UIApplicationDelegate {



    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        // Override point for customization after application launch.
        return true
    }

    // MARK: UISceneSession Lifecycle

    func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -> UISceneConfiguration {
        // Called when a new scene session is being created.
        // Use this method to select a configuration to create the new scene with.
        return UISceneConfiguration(name: "Default Configuration", sessionRole: connectingSceneSession.role)
    }

    func application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set<UISceneSession>) {
        // Called when the user discards a scene session.
        // If any sessions were discarded while the application was not running, this will be called shortly after application:didFinishLaunchingWithOptions.
        // Use this method to release any resources that were specific to the discarded scenes, as they will not return.
    }


}

//
//  AppFlags.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 10/04/25.
//

import Foundation

/// Флаги, которые управляют режимом работы приложения (например, UI-тесты, мок-данные и т.п.)
enum AppFlags {
    static var isUITesting: Bool {
        ProcessInfo.processInfo.arguments.contains("-uiTesting")
    }

    static var useMockData: Bool {
        ProcessInfo.processInfo.arguments.contains("-uiMockData")
    }
}
//
//  DeepLinkParser.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/17/25.
//


import CoreLocation

public enum DeepLink {
    case mapCenter(CLLocationCoordinate2D)
    case poi(id: Int)
}

public enum DeepLinkError: Error {
    case unsupportedScheme
    case unknownHost
    case invalidCoordinates
}



public struct DeepLinkParser {
    public init() {}

    public func parse(url: URL) -> Result<DeepLink, DeepLinkError> {
        let scheme = url.scheme?.lowercased()
        if scheme == "travelbuddy" {
            return parseCustomScheme(url)
        }
        return .failure(.unsupportedScheme)
    }

    private func parseCustomScheme(_ url: URL) -> Result<DeepLink, DeepLinkError> {
        switch url.host?.lowercased() {
        case "map":
            return parseMap(url)
        case "poi":
            guard let id = Int(url.lastPathComponent) else {
                return .failure(.unknownHost)
            }
            return .success(.poi(id: id))
        default:
            return .failure(.unknownHost)
        }
    }

    private func parseMap(_ url: URL) -> Result<DeepLink, DeepLinkError> {
        guard
            let comps = URLComponents(url: url, resolvingAgainstBaseURL: false),
            let latStr = comps.queryItems?.first(where: { $0.name == "lat" })?.value,
            let lonStr = comps.queryItems?.first(where: { $0.name == "lon" })?.value,
            let lat = Double(latStr),
            let lon = Double(lonStr)
        else {
            return .failure(.invalidCoordinates)
        }
        return .success(.mapCenter(.init(latitude: lat, longitude: lon)))
    }
}
//
//  DeepLinkService.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/7/25.
//

import Foundation
import CoreLocation
import Combine

public protocol DeepLinkHandling {
    func handle(url: URL)
    var events: AnyPublisher<DeepLink, Never> { get }
    var errors: AnyPublisher<DeepLinkError, Never> { get }
}

public final class DeepLinkService: DeepLinkHandling {
    private let parser = DeepLinkParser()

    private let successSubject = CurrentValueSubject<DeepLink?, Never>(nil)
    private let errorSubject = PassthroughSubject<DeepLinkError, Never>()

    public init() {}

    public func handle(url: URL) {
        switch parser.parse(url: url) {
        case .success(let dl):
            successSubject.value = dl
        case .failure(let err):
            errorSubject.send(err)
        }
    }

    public var events: AnyPublisher<DeepLink, Never> {
        successSubject.compactMap { $0 }.eraseToAnyPublisher()
    }

    public var errors: AnyPublisher<DeepLinkError, Never> {
        errorSubject.eraseToAnyPublisher()
    }
}
//
//  SceneDelegate.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/19/25.
//

import UIKit

class SceneDelegate: UIResponder, UIWindowSceneDelegate {
    var window: UIWindow?
    var coordinator: AppCoordinator?

    func scene(_ scene: UIScene,
               willConnectTo session: UISceneSession,
               options connectionOptions: UIScene.ConnectionOptions) {
        guard let ws = (scene as? UIWindowScene) else { return }
        let window = UIWindow(windowScene: ws)
        self.window = window

        coordinator = AppCoordinator(window: window)
        coordinator?.start()

        // 🔗 обрабатываем диплинк при холодном старте
        if let url = connectionOptions.urlContexts.first?.url {
            DIContainer.shared.resolver
                .resolve(DeepLinkHandling.self)?
                .handle(url: url)
        }
    }

    // 🔗 диплинки в уже запущенное приложение
    func scene(_ scene: UIScene, openURLContexts URLContexts: Set<UIOpenURLContext>) {
        guard let url = URLContexts.first?.url else { return }
        DIContainer.shared.resolver
            .resolve(DeepLinkHandling.self)?
            .handle(url: url)
    }
}

//
//  HTTPClient.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/28/25.
//

// Infrastructure/Networking/HTTPClient.swift
import Foundation
import Combine

public final class HTTPClient: HTTPClientProtocol {
    private let timeout: TimeInterval
    private let decoder: JSONDecoder

    public init(timeout: TimeInterval = 15,
                decoder: JSONDecoder = .init()) {
        self.timeout = timeout
        self.decoder = decoder
    }

    public func send<T: Decodable>(_ requestIn: URLRequest) -> AnyPublisher<T, Error> {
        var request = requestIn
        // если у запроса не задан таймаут – подставим дефолт из клиента
        if request.timeoutInterval == 0 {
            request.timeoutInterval = timeout
        }

        return URLSession.shared.dataTaskPublisher(for: request)
            .tryMap { output -> Data in
                // маппим network-ошибки и статусы
                if let http = output.response as? HTTPURLResponse,
                   !(200...299).contains(http.statusCode) {
                    throw URLError(.badServerResponse)
                }
                return output.data
            }
            .decode(type: T.self, decoder: decoder)
            .eraseToAnyPublisher()
    }
}
//
//  HTTPClientProtocol.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/20/25.
//


import Foundation
import Combine

public protocol HTTPClientProtocol {
  func send<T: Decodable>(_ request: URLRequest) -> AnyPublisher<T, Error>
}

//
//  POIRepository.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/1/25.
//


import Combine
import Foundation

public final class POIRepository: POIServiceProtocol {
    private let remote: POIServiceProtocol
    private let local: POIServiceProtocol
    private let cache: POICacheProtocol
    private let ttl: TimeInterval

    // in-flight общий publisher для дедупликации конкурентных запросов
    private let stateQueue = DispatchQueue(label: "poi.repo.state")
    private var inFlight: AnyPublisher<[POI], Error>?

    // хранение времени последнего успешного remote save (не меняем протокол кэша)
    private let lastRefreshKey = "poi.cache.lastRefreshAt"

    public init(remote: POIServiceProtocol,
                 local: POIServiceProtocol,
                 cache: POICacheProtocol,
                 ttl: TimeInterval) {
         self.remote = remote
         self.local  = local
         self.cache  = cache
         self.ttl    = ttl
     }

    public func fetchPOIs() -> AnyPublisher<[POI], Error> {
        let cached = loadCacheAsync()

        // если кэш свежий — отдаём его и выходим
        if isFresh() {
            return cached
        }

        // иначе: сразу отдаём содержимое кэша (если есть) и затем — обновление из сети
        // (если in-flight уже идёт — переиспользуем)
        let refresh = remoteOnceShared()
            .catch { [weak self] _ -> AnyPublisher<[POI], Error> in
                guard let self else {
                    return Fail(error: URLError(.unknown)).eraseToAnyPublisher()
                }
                // fallback: локальный JSON (и одновременно обновим кэш)
                return self.local.fetchPOIs()
                    .handleEvents(receiveOutput: { [weak self] pois in
                        self?.saveToCache(pois)
                    })
                    .eraseToAnyPublisher()
            }

        // cacheThenRefresh: сначала кэш, затем сеть
        return cached
            .filter { !$0.isEmpty }
            .append(refresh)
            .eraseToAnyPublisher()
    }

    // MARK: - Helpers

    private func loadCacheAsync() -> AnyPublisher<[POI], Error> {
        Deferred {
            Future<[POI], Error> { [weak self] promise in
                guard let self else {
                    promise(.failure(URLError(.unknown))); return
                }
                DispatchQueue.global(qos: .userInitiated).async {
                    let pois = self.cache.load()
                    promise(.success(pois))
                }
            }
        }
        .eraseToAnyPublisher()
    }

    private func remoteOnceShared() -> AnyPublisher<[POI], Error> {
        // 1) если уже есть общий in-flight, вернём его
        if let shared = stateQueue.sync(execute: { inFlight }) {
            return shared
        }

        // 2) создаём новый, сохраняем в inFlight и шарим
        let publisher = remote.fetchPOIs()
            .handleEvents(receiveOutput: { [weak self] pois in
                self?.saveToCache(pois)
                self?.setLastRefresh(Date())
            }, receiveCompletion: { [weak self] _ in
                self?.stateQueue.async { self?.inFlight = nil }
            }, receiveCancel: { [weak self] in
                self?.stateQueue.async { self?.inFlight = nil }
            })
            .share()
            .eraseToAnyPublisher()

        stateQueue.async { [weak self] in self?.inFlight = publisher }
        return publisher
    }

    private func saveToCache(_ pois: [POI]) {
        // запись синхронная внутри реализаций; если будет дисковая — они уже у тебя в autoreleasepool
        cache.save(pois)
    }

    // MARK: - TTL

    private func isFresh(now: Date = Date()) -> Bool {
        guard let last = getLastRefresh() else { return false }
        return now.timeIntervalSince(last) < ttl
    }

    private func getLastRefresh() -> Date? {
        let t = UserDefaults.standard.double(forKey: lastRefreshKey)
        return t > 0 ? Date(timeIntervalSince1970: t) : nil
    }

    private func setLastRefresh(_ date: Date) {
        UserDefaults.standard.set(date.timeIntervalSince1970, forKey: lastRefreshKey)
    }
}
//
//  RealmPOICache.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/30/25.
//

import Foundation
import RealmSwift

public final class RealmPOICache: POICacheProtocol {
    public func save(_ pois: [POI]) {
        autoreleasepool {
            do {
                let realm = try Realm()
                let objects = pois.map { RealmPOI(poi: $0) }
                try realm.write { realm.add(objects, update: .modified) }
            } catch { /* лог при желании */ }
        }
    }

    public func load() -> [POI] {
        autoreleasepool {
            (try? Realm()).map { Array($0.objects(RealmPOI.self)).map { $0.toPOI() } } ?? []
        }
    }
}

public final class RealmPOI: Object {
    @objc dynamic var id = 0
    @objc dynamic var name = ""
    @objc dynamic var latitude = 0.0
    @objc dynamic var longitude = 0.0
    @objc dynamic var category: String? = nil
    @objc dynamic var descriptionText: String? = nil
    @objc dynamic var imageURLString: String? = nil

    public override static func primaryKey() -> String? { "id" }

    convenience init(poi: POI) {
        self.init()
        id = poi.id; name = poi.name
        latitude = poi.latitude; longitude = poi.longitude
        category = poi.category
        descriptionText = poi.description
        imageURLString = poi.imageURL?.absoluteString
    }

    func toPOI() -> POI {
        POI(
          id: id, name: name,
          latitude: latitude, longitude: longitude,
          category: category,
          description: descriptionText,
          imageURL: imageURLString.flatMap(URL.init)
        )
    }
}

//
//  RemotePOIService.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/28/25.
//

import Foundation
import Combine

public final class RemotePOIService: POIServiceProtocol {
    private let httpClient: HTTPClientProtocol
    private let baseURL: URL

    public init(httpClient: HTTPClientProtocol, config: AppConfig) {
        self.httpClient = httpClient
        self.baseURL = config.apiBaseURL
    }

    public func fetchPOIs() -> AnyPublisher<[POI], Error> {
        let url = baseURL.appendingPathComponent("pois")
        return httpClient.send(URLRequest(url: url))
    }
}
//
//  LocalPOIService.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/28/25.
//

import Foundation
import Combine

public final class LocalPOIService: POIServiceProtocol {
    private let jsonName: String
    
    public init(config: AppConfig) {
        self.jsonName = config.localPOIJSONName
    }
    
    
    public func fetchPOIs() -> AnyPublisher<[POI], Error> {
        Deferred {
            Future<[POI], Error> { promise in
                DispatchQueue.global(qos: .background).async {
                    do {
                        guard let url = Bundle.main.url(forResource: self.jsonName, withExtension: "json") else {
                            promise(.failure(URLError(.fileDoesNotExist)))
                            return
                        }
                        let data = try Data(contentsOf: url)
                        let pois = try JSONDecoder().decode([POI].self, from: data)
                        //Thread.sleep(forTimeInterval: 0)
                        promise(.success(pois))
                    } catch {
                        promise(.failure(error))
                    }
                }
            }
        }
        .eraseToAnyPublisher()
    }
}
//
//  NotificationServiceProtocol.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/28/25.
//


import UserNotifications
import Combine

public protocol NotificationServiceProtocol {
  func requestAuthorization() -> AnyPublisher<Bool, Never>
  func schedule(_ content: UNNotificationContent, at date: Date)
}
//
//  NotificationService.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/20/25.
//


import UserNotifications
import Combine


public final class NotificationService: NotificationServiceProtocol {
  public init() {}

  public func requestAuthorization() -> AnyPublisher<Bool, Never> {
    Future { promise in
      UNUserNotificationCenter.current()
        .requestAuthorization(options: [.alert, .sound]) { granted, _ in
          promise(.success(granted))
        }
    }
    .eraseToAnyPublisher()
  }

  public func schedule(_ content: UNNotificationContent, at date: Date) {
    let interval = max(1, date.timeIntervalSinceNow)
    let trigger = UNTimeIntervalNotificationTrigger(timeInterval: interval, repeats: false)
    let req = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)
    UNUserNotificationCenter.current().add(req)
  }
}
//
//  IAPObserver.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 9/17/25.
//


import StoreKit
import Combine

extension Notification.Name {
  static let iapEntitlementsChanged = Notification.Name("iapEntitlementsChanged")
}

public final class IAPObserver {
  private let iap: IAPServiceProtocol
  private var task: Task<Void, Never>?

  public init(iap: IAPServiceProtocol) { self.iap = iap }

  public func start() {
    guard task == nil else { return }
    task = Task.detached { [weak self] in
      await self?.observeTransactions()
    }
  }

  public func stop() { task?.cancel(); task = nil }
  deinit { stop() }

  private func observeTransactions() async {
    for await update in Transaction.updates {
      do {
        let tx: Transaction = try iap.verify(update)
        // выдаю право пользователю на использование
        await tx.finish()
        // сообщим UI, что энтитлменты могли измениться
        NotificationCenter.default.post(name: .iapEntitlementsChanged, object: nil)
      } catch {
        // опционально: лог/метрики
      }
    }
  }
}
//
//  IAPServiceProtocol.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/28/25.
//



import StoreKit
import Combine


public protocol IAPServiceProtocol {
  func fetchProducts() -> AnyPublisher<[Product], Error>
  func purchase(_ product: Product) -> AnyPublisher<Transaction, Error>
  func verify<T>(_ result: VerificationResult<T>) throws -> T
  func readCurrentPremiumEntitlement() -> AnyPublisher<Bool, Never>
}
//
//  IAPService.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/20/25.
//


import StoreKit
import Combine

public final class IAPService: IAPServiceProtocol {
    private let productID: String
    public init(config: AppConfig) {
        self.productID = config.iap.premiumProductID
    }
    
    public func fetchProducts() -> AnyPublisher<[Product], Error> {
        Deferred {
            Future { promise in
                Task {
                    do {
                        let ids: Set<String> = [self.productID]
                        let products = try await Product.products(for: ids)
                        promise(.success(products))
                    } catch { promise(.failure(error)) }
                }
            }
        }
        .eraseToAnyPublisher()
    }
    
    public func purchase(_ product: Product) -> AnyPublisher<Transaction, Error> {
        Deferred {
            Future { promise in
                Task {
                    do {
                        let result = try await product.purchase()
                        switch result {
                        case .success(let verification):
                            let tx: Transaction = try self.verify(verification)
                            await tx.finish()
                            promise(.success(tx))
                        case .userCancelled:
                            let err = NSError(domain: "IAP", code: NSUserCancelledError,
                                              userInfo: [NSLocalizedDescriptionKey: "Purchase cancelled"])
                            promise(.failure(err))
                        case .pending:
                            let err = NSError(domain: "IAP", code: -1,
                                              userInfo: [NSLocalizedDescriptionKey: "Purchase pending"])
                            promise(.failure(err))
                        @unknown default:
                            let err = NSError(domain: "IAP", code: -2,
                                              userInfo: [NSLocalizedDescriptionKey: "Unknown purchase result"])
                            promise(.failure(err))
                        }
                    } catch { promise(.failure(error)) }
                }
            }
        }
        .eraseToAnyPublisher()
    }
    
    // MARK: - NEW
    public func verify<T>(_ result: VerificationResult<T>) throws -> T {
        switch result {
        case .verified(let safe): return safe
        case .unverified(_, let error): throw error
        }
    }
    
    public func readCurrentPremiumEntitlement() -> AnyPublisher<Bool, Never> {
        Deferred {
            Future<Bool, Never> { promise in
                Task {
                    var hasPremium = false
                    for await entitlement in Transaction.currentEntitlements {
                        if case .verified(let tx) = entitlement,
                           tx.productID == self.productID {
                            hasPremium = true
                            break
                        }
                    }
                    promise(.success(hasPremium))
                }
            }
        }
        .eraseToAnyPublisher()
    }
}
//
//  AnalyticsServiceProtocol.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/28/25.
//


import Foundation

public protocol AnalyticsServiceProtocol {
  func logEvent(name: String, parameters: [String: Any]?)
  func recordError(_ error: Error)
}
//
//  AnalyticsService.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/20/25.
//

import FirebaseAnalytics
import FirebaseCrashlytics


public final class AnalyticsService: AnalyticsServiceProtocol {
  public init() {}
  public func logEvent(name: String, parameters: [String: Any]?) {
    Analytics.logEvent(name, parameters: parameters)
  }
  public func recordError(_ error: Error) {
    Crashlytics.crashlytics().record(error: error)
  }
}
//
//  POICategoryFilter.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/1/25.
//


import Foundation

public enum POICategoryFilter: String, CaseIterable, Identifiable {
    case all = "All", monument = "Monument", museum = "Museum", cafe = "Cafe"
    public var id: String { rawValue }
}

public extension POICategoryFilter {
    var localizedTitle: String {
        switch self {
        case .all: return L10n.catAll
        case .monument: return L10n.catMonument
        case .museum: return L10n.catMuseum
        case .cafe: return L10n.catCafe
        }
    }
}
//
//  POI.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/20/25.
//

import Foundation

public struct POI: Identifiable, Decodable, Hashable {
    public let id: Int
    public let name: String
    public let latitude: Double
    public let longitude: Double
    public let category: String?
    public let description: String?
    public let imageURL: URL?
}
//
//  POIServiceProtocol.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/11/25.
//


import Foundation
import Combine

public protocol POIServiceProtocol {
  func fetchPOIs() -> AnyPublisher<[POI], Error>
}//
//  POICacheProtocol.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/28/25.
//


import Foundation

public protocol POICacheProtocol: AnyObject {
    func save(_ pois: [POI])
    func load() -> [POI]
}
//
//  SettingsView.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/23/25.
//

import SwiftUI

public struct SettingsView<VM: SettingsViewModelProtocol>: View {
    @ObservedObject private var vm: VM

    public init(vm: VM) { self.vm = vm }

    public var body: some View {
        NavigationView {
            Form {
                // Dark Mode
                Toggle(L10n.settingsDarkMode, isOn: Binding(
                    get:  { vm.isDarkMode },
                    set:  { vm.setDarkMode($0) }
                ))
                .accessibilityIdentifier("settings.darkmode.toggle")

                // Notifications
                Toggle(L10n.settingsNotifications, isOn: Binding(
                    get:  { vm.notificationsEnabled },
                    set:  { vm.setNotifications($0) }
                ))
                .accessibilityIdentifier("settings.notifications.toggle")

                // Premium
                Button(action: { vm.purchasePremium() }) {
                    Text(vm.premiumUnlocked
                         ? L10n.settingsPremiumUnlocked
                         : L10n.settingsPremiumUnlock)
                }
                .disabled(vm.premiumUnlocked)
                .accessibilityIdentifier("settings.premium.button")
            }
            .navigationTitle(L10n.navSettingsTitle)
            .alert(item: Binding(
                get: { vm.errorMessage.map { AlertError(message: $0) } },
                set: { _ in vm.clearError() }
            )) { alertError in
                Alert(
                    title: Text(L10n.alertErrorTitle),
                    message: Text(alertError.message),
                    dismissButton: .default(Text(L10n.alertOk))
                )
            }
        }
    }
}

private struct AlertError: Identifiable {
    let id = UUID()
    let message: String
}
//
//  SettingsViewModel.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/20/25.
//

import Combine
import StoreKit
import SwiftUI

public protocol SettingsViewModelProtocol: ObservableObject {
    var objectWillChange: ObservableObjectPublisher { get }
    
    var isDarkMode: Bool { get }
    var notificationsEnabled: Bool { get }
    var premiumUnlocked: Bool { get }
    var errorMessage: String? { get }
    
    func setDarkMode(_ isOn: Bool)
    func setNotifications(_ isOn: Bool)
    
    func purchasePremium()
    func clearError()
}


public final class SettingsViewModel: SettingsViewModelProtocol {
    public let objectWillChange = ObservableObjectPublisher()
    
    private enum Keys {
        static let darkMode = "settings.darkMode"
        static let notificationsEnabled = "settings.notificationsEnabled"
    }
    
    @Published public private(set) var isDarkMode = UserDefaults.standard.bool(forKey: Keys.darkMode)
    @Published public private(set) var notificationsEnabled = UserDefaults.standard.bool(forKey: Keys.notificationsEnabled)
    @Published public private(set) var premiumUnlocked = false
    @Published public private(set) var errorMessage: String?
    
    private let iapService: IAPServiceProtocol
    private let analytics: AnalyticsServiceProtocol
    private let notification: NotificationServiceProtocol
    private var bag = Set<AnyCancellable>()
    
    public init(iapService: IAPServiceProtocol,
                analytics: AnalyticsServiceProtocol,
                notification: NotificationServiceProtocol) {
        self.iapService = iapService
        self.analytics  = analytics
        self.notification = notification
        
        iapService.readCurrentPremiumEntitlement()
            .receive(on: DispatchQueue.main)
            .sink { [weak self] has in self?.premiumUnlocked = has }
            .store(in: &bag)
        
        NotificationCenter.default.publisher(for: .iapEntitlementsChanged)
            .flatMap { [iapService] _ in iapService.readCurrentPremiumEntitlement() }
            .receive(on: DispatchQueue.main)
            .sink { [weak self] has in self?.premiumUnlocked = has }
            .store(in: &bag)
    }
    
    public func setDarkMode(_ isOn: Bool) {
        guard isDarkMode != isOn else { return }
        isDarkMode = isOn
        UserDefaults.standard.set(isOn, forKey: Keys.darkMode)
        analytics.logEvent(name: "settings_dark_mode_changed", parameters: ["value": isOn])
    }
    
    public func setNotifications(_ isOn: Bool) {
        guard notificationsEnabled != isOn else { return }
        notificationsEnabled = isOn
        UserDefaults.standard.set(isOn, forKey: Keys.notificationsEnabled )
        analytics.logEvent(name: "settings_notifications_changed", parameters: ["value": isOn])
        if isOn {
            notification.requestAuthorization().sink { _ in }.store(in: &bag)
        }
    }
    // — остальной код IAP без изменений
    public func purchasePremium() {
        errorMessage = nil
        
        iapService.fetchProducts()
            .tryMap { products -> Product in
                guard let p = products.first else {
                    throw NSError(domain: "IAP", code: -3, userInfo: [NSLocalizedDescriptionKey: "Product not found"])
                }
                return p
            }
            .flatMap { [iapService] product in
                iapService.purchase(product)
            }
            .flatMap { [iapService] _ in
                iapService.readCurrentPremiumEntitlement()
            }
            .receive(on: DispatchQueue.main)
            .sink(receiveCompletion: { [weak self] comp in
                if case let .failure(err) = comp { self?.errorMessage = err.localizedDescription }
            }, receiveValue: { [weak self] has in
                self?.premiumUnlocked = has
            })
            .store(in: &bag)
    }
    
    public func clearError() { errorMessage = nil }
}
//
//  AnySettingsViewModel.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/24/25.


import Combine
import StoreKit
import SwiftUI

final class AnySettingsViewModel: ObservableObject, SettingsViewModelProtocol {
    private let wrapped: any SettingsViewModelProtocol
    private var cancellables = Set<AnyCancellable>()

    let objectWillChange = ObservableObjectPublisher()

    @Published private(set) var isDarkMode: Bool = false
    @Published private(set) var notificationsEnabled: Bool = false
    @Published private(set) var premiumUnlocked: Bool = false
    @Published private(set) var errorMessage: String?

    init(_ wrapped: any SettingsViewModelProtocol) {
        self.wrapped = wrapped

        // Важно: objectWillChange у wrapped — это willSet.
        // Синхронизируемся на следующий runloop-так, чтобы читать уже обновлённые значения.
        wrapped.objectWillChange
            .receive(on: DispatchQueue.main)
            .sink { [weak self] _ in
                DispatchQueue.main.async {
                    guard let self else { return }
                    self.syncProperties()
                    self.objectWillChange.send()
                }
            }
            .store(in: &cancellables)

        syncProperties()
    }

    private func syncProperties() {
        isDarkMode = wrapped.isDarkMode
        notificationsEnabled = wrapped.notificationsEnabled
        premiumUnlocked = wrapped.premiumUnlocked
        errorMessage = wrapped.errorMessage
    }

    func setDarkMode(_ isOn: Bool) {
        if isDarkMode != isOn {
            isDarkMode = isOn          // мгновенно для SwiftUI
            objectWillChange.send()    // на случай, если где-то нужен немедленный импульс
        }
        wrapped.setDarkMode(isOn)      // источник истины
    }

    func setNotifications(_ isOn: Bool) {
        if notificationsEnabled != isOn {
            notificationsEnabled = isOn
            objectWillChange.send()
        }
        wrapped.setNotifications(isOn)
    }

    func purchasePremium() { wrapped.purchasePremium() }
    func clearError()      { wrapped.clearError() }
}
//
//  POIDetailViewModelProtocol.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/11/25.
//


import Combine
import MapKit

public protocol POIDetailViewModelProtocol: AnyObject {
  // Outputs
  var model: POIDetailModel { get }
  var isLoadingAddress: Bool { get }
  var address: String? { get }
  var errorMessage: String? { get }

  // User actions
  func onAppear()
  func didTapShare()
  func didTapOpenInMaps()
  func didTapClose()

  // Publishers for Coordinator/Router
  var sharePublisher: AnyPublisher<URL, Never> { get }
  var openInMapsPublisher: AnyPublisher<MKMapItem, Never> { get }
  var closePublisher: AnyPublisher<Void, Never> { get }

  // Publisher for model updates
  var modelPublisher: AnyPublisher<POIDetailModel, Never> { get }
}

@MainActor
public final class POIDetailViewModel: ObservableObject, POIDetailViewModelProtocol {
  @Published public private(set) var model: POIDetailModel
  @Published public private(set) var isLoadingAddress = false
  @Published public private(set) var address: String?
  @Published public private(set) var errorMessage: String?

  private let geocoder = CLGeocoder()
  private var cancellables = Set<AnyCancellable>()

  public init(poi: POI) {
    self.model = POIDetailModel(poi: poi,
                                address: nil,
                                imageData: nil)
  }

  public func onAppear() {
    guard address == nil else { return }
    isLoadingAddress = true
    let loc = CLLocation(latitude: model.poi.latitude,
                         longitude: model.poi.longitude)
    geocoder.reverseGeocodeLocation(loc) { [weak self] places, error in
      DispatchQueue.main.async {
          self?.isLoadingAddress = false
        if let err = error {
          self?.errorMessage = err.localizedDescription
        } else {
          self?.address = places?.first?.compactAddress
        }
      }
    }
  }

  public func didTapShare() {
    let p = model.poi
    let url = URL(string: "https://maps.apple.com/?ll=\(p.latitude),\(p.longitude)")!
    shareSubject.send(url)
  }

  public func didTapOpenInMaps() {
    let p = model.poi
    let coord = CLLocationCoordinate2D(latitude: p.latitude,
                                       longitude: p.longitude)
    let item = MKMapItem(placemark: MKPlacemark(coordinate: coord))
    item.name = p.name
    openInMapsSubject.send(item)
  }

  public func didTapClose() {
    closeSubject.send(())
  }

  // Internal subjects
  private let shareSubject      = PassthroughSubject<URL, Never>()
  private let openInMapsSubject = PassthroughSubject<MKMapItem, Never>()
  private let closeSubject      = PassthroughSubject<Void, Never>()

  // Protocol publishers
  public var sharePublisher: AnyPublisher<URL, Never> {
    shareSubject.eraseToAnyPublisher()
  }
  public var openInMapsPublisher: AnyPublisher<MKMapItem, Never> {
    openInMapsSubject.eraseToAnyPublisher()
  }
  public var closePublisher: AnyPublisher<Void, Never> {
    closeSubject.eraseToAnyPublisher()
  }

  public var modelPublisher: AnyPublisher<POIDetailModel, Never> {
    $model.eraseToAnyPublisher()
  }
}

private extension CLPlacemark {
  var compactAddress: String {
    [subThoroughfare, thoroughfare, locality, administrativeArea]
      .compactMap { $0 }
      .joined(separator: ", ")
  }
}
//
//  POIDetailRoute.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/11/25.
//



import Combine
import MapKit

public enum POIDetailRoute: Hashable, Identifiable {
  case share(URL)
  case openInMaps(MKMapItem)
  case close

  public var id: String {
    switch self {
    case .share(let url): return "share:\(url.absoluteString)"
    case .openInMaps(let item):
      let c = item.placemark.coordinate
      return "open:\(c.latitude),\(c.longitude)"
    case .close: return "close"
    }
  }
}

public enum POIDetailUIError: Hashable {
  case plain(String)
  var localizedMessage: String {
    switch self {
    case .plain(let m): return m
    }
  }
}

@MainActor
public final class POIDetailRouter: ObservableObject {
  public let routes = PassthroughSubject<POIDetailRoute, Never>()
  public let uiErrors = PassthroughSubject<POIDetailUIError, Never>()
  private var cancellables = Set<AnyCancellable>()

  public init(viewModel: POIDetailViewModel) {
    viewModel.sharePublisher
      .map(POIDetailRoute.share)
      .sink { [routes] in routes.send($0) }
      .store(in: &cancellables)

    viewModel.openInMapsPublisher
      .map(POIDetailRoute.openInMaps)
      .sink { [routes] in routes.send($0) }
      .store(in: &cancellables)

    viewModel.closePublisher
      .map { _ in POIDetailRoute.close }
      .sink { [routes] in routes.send($0) }
      .store(in: &cancellables)

    // Транслируем ошибки VM в UIError-канал
    viewModel.$errorMessage
      .compactMap { $0 }
      .map { POIDetailUIError.plain($0) }
      .sink { [uiErrors] in uiErrors.send($0) }
      .store(in: &cancellables)
  }
}
//
//  POIDetailCoordinator.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/11/25.
//


import SwiftUI
import Combine
import Swinject

@MainActor
public final class POIDetailCoordinator: ObservableObject {
    @Published private(set) var sheetRoute: POIDetailRoute?
    @Published private(set) var model: POIDetailModel

    private let viewModel: POIDetailViewModel
    private let router: POIDetailRouter
    private var cancellables = Set<AnyCancellable>()

    // UI error state
    @Published private var failAlert: FailAlert?
    private struct FailAlert: Identifiable { let id = UUID(); let message: String }

    public init(poi: POI, resolver: Resolver? = nil) {
        let r = resolver ?? DIContainer.shared.resolver
        guard let vm = r.resolve(POIDetailViewModel.self, argument: poi) else {
            preconditionFailure("Swinject: POIDetailViewModel не зарегистрирован для \(POI.self)")
        }

        self.viewModel = vm
        self.router    = POIDetailRouter(viewModel: vm)
        self.model     = vm.model

        router.routes
            .sink { [weak self] route in
                switch route {
                case .share(let url):       self?.sheetRoute = .share(url)
                case .openInMaps(let item): item.openInMaps(launchOptions: nil)
                case .close:                self?.sheetRoute = nil
                }
            }
            .store(in: &cancellables)

        // централизованный показ ошибок
        router.uiErrors
            .sink { [weak self] uiError in
                self?.failAlert = .init(message: uiError.localizedMessage)
            }
            .store(in: &cancellables)

        vm.modelPublisher
            .sink { [weak self] newModel in self?.model = newModel }
            .store(in: &cancellables)
    }

    @ViewBuilder
    public func rootView() -> some View {
        let binding = Binding<POIDetailRoute?>(
            get: { self.sheetRoute },
            set: { self.sheetRoute = $0 }
        )
        POIDetailView(viewModel: viewModel, sheetRoute: binding)
            .alert(item: Binding(
                get: { self.failAlert },
                set: { _ in self.failAlert = nil }
            )) { alert in
                Alert(
                    title: Text(L10n.alertErrorTitle),
                    message: Text(alert.message),
                    dismissButton: .default(Text(L10n.alertOk))
                )
            }
    }
}
//
//  POIDetailModel.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/11/25.
//


import Foundation

public struct POIDetailModel {
  public let poi: POI
  public let address: String?
  public let imageData: Data?

  public init(
    poi: POI,
    address: String?,
    imageData: Data?
  ) {
    self.poi = poi
    self.address = address
    self.imageData = imageData
  }
}
//
//  POIDetailView.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/11/25.
//


import SwiftUI
import MapKit

public struct POIDetailView: View {
  @ObservedObject private var vm: POIDetailViewModel
  @Binding private var sheetRoute: POIDetailRoute?

  public init(
    viewModel: POIDetailViewModel,
    sheetRoute: Binding<POIDetailRoute?>
  ) {
    self.vm = viewModel
    self._sheetRoute = sheetRoute
  }

  public var body: some View {
    VStack(spacing: 16) {
      HStack { Spacer()
        Button(action: vm.didTapClose) {
          Image(systemName: "xmark.circle.fill")
            .font(.title2)
        }
      }

      Text(vm.model.poi.name).font(.largeTitle)

      if vm.isLoadingAddress {
        ProgressView(L10n.detailLoadingAddress)
      } else if let addr = vm.address {
        Text(addr).italic()
      } else if let err = vm.errorMessage {
        // Экранная подсветка + route-алерт прилетит из координатора
        Text(err).foregroundColor(.red)
      }

      Button(L10n.detailShare,        action: vm.didTapShare)
      Button(L10n.detailOpenInMaps,   action: vm.didTapOpenInMaps)
      Spacer()
    }
    .padding()
    .onAppear(perform: vm.onAppear)
    .navigationTitle(vm.model.poi.name)
    .sheet(item: $sheetRoute) { route in
      switch route {
      case .share(let url):
        ActivityViewController(activityItems: [url])
      default:
        EmptyView()
      }
    }
  }
}


// UIKit wrapper
struct ActivityViewController: UIViewControllerRepresentable {
  let activityItems: [Any]

  func makeUIViewController(
    context: Context
  ) -> UIActivityViewController {
    UIActivityViewController(
      activityItems: activityItems,
      applicationActivities: nil
    )
  }

  func updateUIViewController(
    _ vc: UIActivityViewController,
    context: Context
  ) {}
}
//
//  POIMapViewModelProtocol.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/7/25.
//


import Combine
import MapKit

public protocol POIMapViewModelProtocol: ObservableObject {
    var annotations: [POIAnnotation] { get }
    var selectedPOI: POI? { get }
    func fetch()
    func select(annotation: POIAnnotation)
}

public final class POIMapViewModel: POIMapViewModelProtocol {
    // Output
    @Published public private(set) var annotations: [POIAnnotation] = []
    @Published public private(set) var selectedPOI: POI?

    // Deps
    private let service: POIServiceProtocol
    private let factory: AnnotationFactory
    private var bag = Set<AnyCancellable>()

    init(service: POIServiceProtocol,
                factory: AnnotationFactory = DefaultAnnotationFactory()) {
        self.service  = service
        self.factory  = factory
    }

    public func fetch() {
        service.fetchPOIs()
            .map(factory.makeAnnotations)
            .receive(on: DispatchQueue.main)
            .sink(receiveCompletion: { _ in },
                  receiveValue: { [weak self] in self?.annotations = $0 })
            .store(in: &bag)
    }

    public func select(annotation: POIAnnotation) {
        selectedPOI = annotation.poi
    }
}
//
//  AnyPOIMapViewModel.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/7/25.
//


import Combine
import SwiftUI

public final class AnyPOIMapViewModel: ObservableObject {
    // -------- SwiftUI bindings --------
    @Published public var annotations: [POIAnnotation] = []
    @Published public var selectedPOI: POI?            = nil

    // -------- Internals --------
    private let wrapped: any POIMapViewModelProtocol
    private var bag = Set<AnyCancellable>()

    // MARK: – init
    public init(_ wrapped: any POIMapViewModelProtocol) {
        self.wrapped      = wrapped
        self.annotations  = wrapped.annotations
        self.selectedPOI  = wrapped.selectedPOI

        // Если это именно POIMapViewModel, подписываемся на его @Published-поля
        if let concrete = wrapped as? POIMapViewModel {
            concrete.$annotations
                .receive(on: DispatchQueue.main)
                .assign(to: &$annotations)

            concrete.$selectedPOI
                .receive(on: DispatchQueue.main)
                .assign(to: &$selectedPOI)
        }
    }

    // MARK: – Facade
    public func fetch()                           { wrapped.fetch() }
    public func select(annotation: POIAnnotation) { wrapped.select(annotation: annotation) }
}
//
//  MapRoute.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/11/25.
//

import SwiftUI
import Combine
import CoreLocation

enum MapRoute: Hashable {
    case detail(POI)
}

enum MapUIError: Equatable {
    case poiNotFound(Int)
    case plain(String)

    var localizedMessage: String {
        switch self {
        case .poiNotFound(let id):
            return L10n.deeplinkPoiNotFound(id)
        case .plain(let message):
            return message
        }
    }
}

enum MapNavigationCommand {
    case detail(POI)
    case back
    case reset
    case center(CLLocationCoordinate2D)
    case focusPOI(Int)
    case showError(MapUIError)
}

@MainActor
final class MapRouter: ObservableObject {
    let routes = PassthroughSubject<MapNavigationCommand, Never>()
    private var pending: [MapNavigationCommand] = []

    private func emit(_ cmd: MapNavigationCommand) {
        pending.append(cmd)
        routes.send(cmd)
    }

    func consumePending() -> [MapNavigationCommand] {
        let items = pending
        pending.removeAll()
        return items
    }

    // MARK: High-level API
    func goDetail(_ poi: POI)                 { emit(.detail(poi)) }
    func goBack()                              { emit(.back) }
    func reset()                               { emit(.reset) }
    func center(on coord: CLLocationCoordinate2D) { emit(.center(coord)) }
    func focusPOI(_ id: Int)                   { emit(.focusPOI(id)) }

    // Единый способ показать ошибку на карте
    func showError(_ error: MapUIError)        { emit(.showError(error)) }
}
//
//  MapCoordinator.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/10/25.
//


import SwiftUI
import Combine
import MapKit

@MainActor
final class MapCoordinator {
    private let vm: AnyPOIMapViewModel
    private let router: MapRouter
    private let defaultRegionMeters: CLLocationDistance
    private let makeDetail: (POI) -> AnyView
   
    
    init(vm: AnyPOIMapViewModel, router: MapRouter) {
        self.vm     = vm
        self.router = router
        
        let config = DIContainer.shared.resolver.resolve(AppConfig.self)!
        self.defaultRegionMeters = config.defaultRegionMeters
        let resolver = DIContainer.shared.resolver
        self.makeDetail = { poi in
            guard let coord = resolver.resolve(POIDetailCoordinator.self, argument: poi) else {
                return AnyView(EmptyView())
            }
            return AnyView(coord.rootView())
        }
    }
    
    func rootView() -> some View {
        MapContainer(vm: vm, router: router, defaultRegionMeters: defaultRegionMeters, makeDetail: makeDetail)
    }
}

//
//  POIAnnotation.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/7/25.
//


import MapKit

/// Простая обёртка над POI, чтобы стать MKAnnotation
public final class POIAnnotation: NSObject, MKAnnotation {
    let poi: POI

    // локально собираем координату, модель POI не меняем
    public var coordinate: CLLocationCoordinate2D {
        .init(latitude: poi.latitude, longitude: poi.longitude)
    }

    public var title: String?    { poi.name      }
    public var subtitle: String? { poi.category  }

    init(poi: POI) { self.poi = poi }
}

/// SRP-фабрика для тестов и явной зависимости
protocol AnnotationFactory {
    func makeAnnotations(from pois: [POI]) -> [POIAnnotation]
}

struct DefaultAnnotationFactory: AnnotationFactory {
    func makeAnnotations(from pois: [POI]) -> [POIAnnotation] {
        pois.map(POIAnnotation.init)
    }
}
//
//  POISnippetView.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/7/25.
//

import SwiftUI
import MapKit

struct POISnippetView: View {
    let poi: POI
    var onDetails: () -> Void
    var onRoute:   () -> Void

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text(poi.name).font(.title2).bold()
            if let cat = poi.category { Text(cat).foregroundColor(.secondary) }
            if let desc = poi.description { Text(desc).lineLimit(3) }

            HStack {
                Button(L10n.snippetDetails, action: onDetails)
                    .buttonStyle(.borderedProminent)

                Spacer()
                Button(L10n.detailOpenInMaps, action: onRoute)
            }
        }
        .padding()
    }
}
//
//  MapViewRepresentable.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/7/25.
//

import SwiftUI
import MapKit

/// UIKit-карта с управлением:
/// - дифф аннотаций
/// - синхронизация выделения по `selectedId`
/// - внешняя команда центрирования через `centerRequest`
struct MapViewRepresentable: UIViewRepresentable {
    let annotations: [POIAnnotation]
    let defaultRegionMeters: CLLocationDistance

    /// Единый источник правды для выделения пина
    @Binding var selectedId: Int?

    /// Внешняя команда центрирования карты (однократная) — после применения сбрасывается в nil
    @Binding var centerRequest: CLLocationCoordinate2D?

    /// Доп. коллбек (сохраняем для совместимости; чаще всего noop)
    let onSelect: (POIAnnotation) -> Void

    func makeCoordinator() -> Coordinator { Coordinator(self) }

    func makeUIView(context: Context) -> MKMapView {
        let map = MKMapView()
        map.delegate = context.coordinator
        map.register(MKMarkerAnnotationView.self, forAnnotationViewWithReuseIdentifier: "marker")
        map.register(MKMarkerAnnotationView.self, forAnnotationViewWithReuseIdentifier: "cluster")
        map.showsUserLocation = true
        map.pointOfInterestFilter = .excludingAll
        return map
    }

    func updateUIView(_ map: MKMapView, context: Context) {
        // --- дифф аннотаций ---
        let existing = map.annotations.compactMap { $0 as? POIAnnotation }
        let existingIDs = Set(existing.map { $0.poi.id })
        let incomingIDs = Set(annotations.map { $0.poi.id })

        let toRemove = existing.filter { !incomingIDs.contains($0.poi.id) }
        if !toRemove.isEmpty { map.removeAnnotations(toRemove) }

        let toAdd = annotations.filter { !existingIDs.contains($0.poi.id) }
        if !toAdd.isEmpty { map.addAnnotations(toAdd) }

        // --- первичная установка региона ---
        if !context.coordinator.hasSetInitialRegion, !map.annotations.isEmpty {
            context.coordinator.hasSetInitialRegion = true
            let poiAnnos = map.annotations.compactMap { $0 as? POIAnnotation }
            if poiAnnos.count == 1, let only = poiAnnos.first {
                let region = MKCoordinateRegion(
                    center: only.coordinate,
                    latitudinalMeters: defaultRegionMeters,
                    longitudinalMeters: defaultRegionMeters
                )
                map.setRegion(region, animated: false)
            } else {
                map.showAnnotations(poiAnnos, animated: false)
                let insets = UIEdgeInsets(top: 80, left: 40, bottom: 160, right: 40)
                map.setVisibleMapRect(map.visibleMapRect, edgePadding: insets, animated: false)
            }
        }

        // --- синхронизация выделения ---
        if let id = selectedId {
            if let anno = map.annotations
                .compactMap({ $0 as? POIAnnotation })
                .first(where: { $0.poi.id == id }) {
                let already = map.selectedAnnotations.contains {
                    guard let a = $0 as? POIAnnotation else { return false }
                    return a.poi.id == id
                }
                if !already { map.selectAnnotation(anno, animated: true) }
            }
        } else {
            if !map.selectedAnnotations.isEmpty {
                map.selectedAnnotations.forEach { map.deselectAnnotation($0, animated: true) }
            }
        }

        // --- внешняя команда центрирования (deeplink) ---
        if let center = centerRequest {
            // это и есть «наш» стартовый регион — запретим авто-инициализацию позже
            context.coordinator.hasSetInitialRegion = true
            let region = MKCoordinateRegion(
                center: center,
                latitudinalMeters: defaultRegionMeters,
                longitudinalMeters: defaultRegionMeters
            )
            map.setRegion(region, animated: true)
            // однократное действие — сбрасываем запрос в nil
            DispatchQueue.main.async {
                self.centerRequest = nil
            }
        }
    }

    // MARK: - Coordinator

    final class Coordinator: NSObject, MKMapViewDelegate {
        var hasSetInitialRegion = false
        let parent: MapViewRepresentable
        private var lastSelectedId: Int?

        init(_ parent: MapViewRepresentable) { self.parent = parent }

        func mapView(_ mapView: MKMapView, didSelect view: MKAnnotationView) {
            guard let anno = view.annotation as? POIAnnotation else { return }
            guard lastSelectedId != anno.poi.id else { return }
            lastSelectedId = anno.poi.id

            parent.selectedId = anno.poi.id
            parent.onSelect(anno)
        }

        func mapView(_ mapView: MKMapView, didDeselect view: MKAnnotationView) {
            guard let anno = view.annotation as? POIAnnotation else { return }
            if lastSelectedId == anno.poi.id { lastSelectedId = nil }
            if parent.selectedId == anno.poi.id { parent.selectedId = nil }
        }

        func mapView(_ mapView: MKMapView, viewFor annotation: MKAnnotation) -> MKAnnotationView? {
            if let cluster = annotation as? MKClusterAnnotation {
                let v = mapView.dequeueReusableAnnotationView(withIdentifier: "cluster", for: annotation) as! MKMarkerAnnotationView
                v.displayPriority = .required
                v.markerTintColor = .systemBlue
                v.glyphText = "\(cluster.memberAnnotations.count)"
                v.titleVisibility = .hidden
                v.subtitleVisibility = .hidden
                v.canShowCallout = false
                return v
            }
            guard annotation is POIAnnotation else { return nil }
            let v = mapView.dequeueReusableAnnotationView(withIdentifier: "marker", for: annotation) as! MKMarkerAnnotationView
            v.displayPriority      = .defaultHigh
            v.clusteringIdentifier = "poi"
            v.markerTintColor      = .systemBlue
            v.glyphImage           = UIImage(systemName: "mappin")
            v.canShowCallout       = false
            return v
        }
    }
}
//
//  POIMapView.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/7/25.
//

import SwiftUI
import MapKit

/// Владеет `AnyPOIMapViewModel`, показывает карту и сниппет.
/// Управление фокусом и центрированием приходит сверху через биндинги.
public struct POIMapView: View {
    @StateObject private var vm: AnyPOIMapViewModel
    @EnvironmentObject private var router: MapRouter
    private let defaultRegionMeters: CLLocationDistance

    /// Прокидываем из `MapContainer` запросы центра/фокуса
    @Binding private var centerRequest: CLLocationCoordinate2D?

    public init(
        viewModel: AnyPOIMapViewModel,
        defaultRegionMeters: CLLocationDistance,
        centerRequest: Binding<CLLocationCoordinate2D?>
    ) {
        _vm = StateObject(wrappedValue: viewModel)
        self.defaultRegionMeters = defaultRegionMeters
        self._centerRequest = centerRequest
    }

    public var body: some View {
        MapViewRepresentable(
            annotations: vm.annotations,
            defaultRegionMeters: defaultRegionMeters,
            selectedId: Binding(
                get: { vm.selectedPOI?.id },
                set: { newId in
                    vm.selectedPOI = newId.flatMap { id in
                        vm.annotations.first(where: { $0.poi.id == id })?.poi
                    }
                }
            ),
            centerRequest: $centerRequest,
            onSelect: { _ in }
        )
        .ignoresSafeArea()
        .onAppear { vm.fetch() }
        .sheet(item: Binding(
            get: { vm.selectedPOI },
            set: { vm.selectedPOI = $0 }
        ), onDismiss: {
            vm.selectedPOI = nil
        }) { poi in
            POISnippetView(
                poi: poi,
                onDetails: {
                    vm.selectedPOI = nil
                    DispatchQueue.main.async { router.goDetail(poi) }
                },
                onRoute: {
                    let coord = CLLocationCoordinate2D(latitude: poi.latitude, longitude: poi.longitude)
                    let item = MKMapItem(placemark: MKPlacemark(coordinate: coord))
                    item.name = poi.name
                    item.openInMaps()
                }
            )
            .presentationDetents([.height(200), .medium])
        }
    }
}
//
//  MapContainer.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/17/25.
//


import SwiftUI
import Combine
import Swinject
import MapKit

struct MapContainer: View {
    @State private var path: [MapRoute] = []
    @State private var prevPathCount: Int = 0

    @State private var lastPushedPOIId: Int?
    @State private var isNavigating = false

    @StateObject private var router: MapRouter
    @StateObject private var vm: AnyPOIMapViewModel

    private let defaultRegionMeters: CLLocationDistance
    private let makeDetail: (POI) -> AnyView

    @State private var centerRequest: CLLocationCoordinate2D? = nil

    @State private var pendingFocusId: Int? = nil
    @State private var focusTimeoutWorkItem: DispatchWorkItem? = nil
    @State private var failAlert: FailAlert? = nil

    private struct FailAlert: Identifiable {
        let id = UUID()
        let message: String
    }

    init(
        vm: AnyPOIMapViewModel,
        router: MapRouter,
        defaultRegionMeters: CLLocationDistance,
        makeDetail: @escaping (POI) -> AnyView
    ) {
        _vm = StateObject(wrappedValue: vm)
        _router = StateObject(wrappedValue: router)
        self.defaultRegionMeters = defaultRegionMeters
        self.makeDetail = makeDetail
    }

    var body: some View {
        NavigationStack(path: $path) {
            POIMapView(
                viewModel: vm,
                defaultRegionMeters: defaultRegionMeters,
                centerRequest: $centerRequest
            )
            .navigationDestination(for: MapRoute.self) { route in
                switch route {
                case .detail(let poi):
                    makeDetail(poi)
                }
            }
        }
        .onReceive(router.routes) { command in
            handle(command)
        }
        .onAppear {
            router.consumePending().forEach { handle($0) }
        }
        .onChange(of: path) { newValue in
            if newValue.count < prevPathCount {
                lastPushedPOIId = nil
                isNavigating = false
            }
            prevPathCount = newValue.count
        }
        .onChange(of: vm.annotations) { _ in
            if let id = pendingFocusId,
               let poi = vm.annotations.first(where: { $0.poi.id == id })?.poi {
                pendingFocusId = nil
                cancelFocusTimeout()
                vm.selectedPOI = poi
            }
        }
        .alert(item: $failAlert) { alert in
            Alert(
                title: Text(L10n.alertErrorTitle),
                message: Text(alert.message),
                dismissButton: .default(Text(L10n.alertOk))
            )
        }
        .environmentObject(router)
    }

    // MARK: - Helpers

    private func scheduleFocusTimeout(for id: Int, seconds: Double = 2.5) {
        cancelFocusTimeout()
        let work = DispatchWorkItem {
            if pendingFocusId == id, vm.selectedPOI?.id != id {
                // единый путь показа ошибки — через Router
                router.showError(.poiNotFound(id))

                // подвинем карту, чтобы не оставлять «никуда»
                if let anyAnno = vm.annotations.first {
                    centerRequest = anyAnno.coordinate
                }

                // (опционально) метрика
                DIContainer.shared.resolver
                    .resolve(AnalyticsServiceProtocol.self)?
                    .logEvent(name: "deeplink_poi_not_found", parameters: ["id": id])

                pendingFocusId = nil
            }
        }
        focusTimeoutWorkItem = work
        DispatchQueue.main.asyncAfter(deadline: .now() + seconds, execute: work)
    }

    private func cancelFocusTimeout() {
        focusTimeoutWorkItem?.cancel()
        focusTimeoutWorkItem = nil
    }

    private func handle(_ command: MapNavigationCommand) {
        switch command {
        case .detail(let poi):
            guard !isNavigating, lastPushedPOIId != poi.id else { return }
            isNavigating = true
            path.append(.detail(poi))
            lastPushedPOIId = poi.id
            DispatchQueue.main.async { isNavigating = false }

        case .back:
            if !path.isEmpty { path.removeLast() }
            lastPushedPOIId = nil
            isNavigating = false

        case .reset:
            path.removeAll()
            lastPushedPOIId = nil
            isNavigating = false

        case .center(let coord):
            centerRequest = coord

        case .focusPOI(let id):
            if let poi = vm.annotations.first(where: { $0.poi.id == id })?.poi {
                vm.selectedPOI = poi
                cancelFocusTimeout()
            } else {
                pendingFocusId = id
                vm.fetch()
                scheduleFocusTimeout(for: id)
            }

        case .showError(let uiError):
            // Всегда локализовано здесь, в UI-слое
            failAlert = .init(message: uiError.localizedMessage)
        }
    }
}
//
//  POIListViewModel.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/20/25.
//



import Combine
import CoreLocation
import MapKit

public protocol POIListViewModelProtocol: AnyObject {
    // Inputs
    var filter: POICategoryFilter { get set }
    func fetchPOIs()
    func openInMaps(poi: POI)
    
    // Outputs
    var pois: [POI] { get }
    var isLoading: Bool { get }
    var errorMessage: String? { get }
}

public final class POIListViewModel: ObservableObject, POIListViewModelProtocol {
    // MARK: Inputs
    @Published public var filter: POICategoryFilter = .all
    
    // MARK: Internal state
    private var allPois: [POI] = []
    
    // MARK: Outputs
    @Published public private(set) var pois: [POI] = []
    @Published public private(set) var isLoading: Bool = false
    @Published public private(set) var errorMessage: String? = nil
    
    private let repository: POIServiceProtocol
    private var cancellables = Set<AnyCancellable>()
    
    public init(repository: POIServiceProtocol) {
        self.repository = repository
        
        // Локальная фильтрация при смене filter
        $filter
            .dropFirst()
            .receive(on: DispatchQueue.main)
            .sink { [weak self] newFilter in
                self?.applyFilter(using: newFilter)
            }
            .store(in: &cancellables)
    }
    
    public func fetchPOIs() {
        if pois.isEmpty { isLoading = true }
        errorMessage = nil
        
        repository.fetchPOIs()
            .receive(on: DispatchQueue.main)
            .sink { [weak self] completion in
                guard let self = self else { return }
                self.isLoading = false
                if case let .failure(err) = completion {
                    self.errorMessage = err.localizedDescription
                }
            } receiveValue: { [weak self] list in
                guard let self = self else { return }
                self.allPois = list
                self.applyFilter()
            }
            .store(in: &cancellables)
    }
    
    private func applyFilter(using filter: POICategoryFilter? = nil) {
        let effective = filter ?? self.filter
        pois = (effective == .all)
        ? allPois
        : allPois.filter { $0.category == effective.rawValue }
    }
    
    public func openInMaps(poi: POI) {
        let coord = CLLocationCoordinate2D(latitude: poi.latitude,
                                           longitude: poi.longitude)
        let item = MKMapItem(placemark: MKPlacemark(coordinate: coord))
        item.name = poi.name
        item.openInMaps(launchOptions: nil)
    }
}
//
//  AnyPOIListViewModel.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/1/25.
//

import Foundation
import Combine

public final class AnyPOIListViewModel: ObservableObject {
    @Published public var filter: POICategoryFilter = .all
    @Published public var pois: [POI] = []
    @Published public var isLoading: Bool = false
    @Published public var errorMessage: String? = nil

    private let wrapped: POIListViewModelProtocol
    private var cancellables = Set<AnyCancellable>()

    public init(_ wrapped: POIListViewModelProtocol) {
        self.wrapped = wrapped
        self.filter = wrapped.filter

        // 1. Пробрасываем filter из wrapper в wrapped
        $filter
            .dropFirst()
            .sink { [weak self] newFilter in
                guard let self else { return }
                if self.wrapped.filter != newFilter {
                    self.wrapped.filter = newFilter
                }
            }
            .store(in: &cancellables)

        // 2. Пробрасываем filter из wrapped наружу (если вдруг он меняется)
        if let vm = wrapped as? POIListViewModel {
            vm.$filter
                .receive(on: DispatchQueue.main)
                .sink { [weak self] newFilter in
                    guard let self else { return }
                    if self.filter != newFilter {
                        self.filter = newFilter
                    }
                }
                .store(in: &cancellables)

            vm.$pois
                .receive(on: DispatchQueue.main)
                .assign(to: &$pois)
            vm.$isLoading
                .receive(on: DispatchQueue.main)
                .assign(to: &$isLoading)
            vm.$errorMessage
                .receive(on: DispatchQueue.main)
                .assign(to: &$errorMessage)
        }
    }

    public func fetchPOIs() { wrapped.fetchPOIs() }
    public func openInMaps(poi: POI) { wrapped.openInMaps(poi: poi) }
}
//
//  POIListRoute.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/11/25.
//



import SwiftUI
import Combine

enum POIListRoute: Hashable {
    case detail(POI)
}

enum POIListUIError: Hashable {
    case plain(String)
    var localizedMessage: String {
        switch self {
        case .plain(let m): return m
        }
    }
}

enum POIListNavigationCommand {
    case detail(POI)
    case back
    case reset
    case showError(POIListUIError)
}

@MainActor
final class POIListRouter: ObservableObject {
    let routes = PassthroughSubject<POIListNavigationCommand, Never>()
    var cancellables = Set<AnyCancellable>()

    func goDetail(_ poi: POI) { routes.send(.detail(poi)) }
    func goBack() { routes.send(.back) }
    func reset() { routes.send(.reset) }

    func showError(_ error: POIListUIError) { routes.send(.showError(error)) }
}
//
//  POIListRoute.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/10/25.
//


import SwiftUI

@MainActor
final class POIListCoordinator {
    private let viewModel: AnyPOIListViewModel
    private let router: POIListRouter
    private let makeDetail: (POI) -> AnyView
    
    init(viewModel: AnyPOIListViewModel, router: POIListRouter) {
        self.viewModel = viewModel
        self.router = router
        let resolver = DIContainer.shared.resolver
        self.makeDetail = { poi in
            guard let coord = resolver.resolve(POIDetailCoordinator.self, argument: poi) else {
                return AnyView(EmptyView())
            }
            return AnyView(coord.rootView())
        }
    }
    
    @ViewBuilder
    func rootView() -> some View {
        POIListContainer(vm: viewModel, router: router, makeDetail: makeDetail)
    }
}
//
//  POIImageView.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/2/25.
//

import SwiftUI

public struct POIImageView: View {
    let imagePath: String?

    public init(imagePath: String?) { self.imagePath = imagePath }

    public var body: some View {
        VStack {
            if let imagePath,
               let imageName = imagePath.split(separator: "/").last {
                let components = imageName.split(separator: ".")
                if components.count == 2 {
                    let name = String(components[0])
                    let ext = String(components[1])
                    if let url = Bundle.main.url(forResource: name, withExtension: ext),
                       let uiImage = UIImage(contentsOfFile: url.path) {
                        Image(uiImage: uiImage).resizable().scaledToFit()
                    } else {
                        Text(L10n.imageInvalidPath(imagePath))
                            .font(.caption)
                            .foregroundColor(.red)
                    }
                } else {
                    Text(L10n.imageInvalidPath(imagePath))
                        .font(.caption)
                        .foregroundColor(.red)
                }
            } else {
                Text(L10n.imageNoImage)
            }
        }
    }
}
//
//  POIListContainer.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 9/11/25.
//



import SwiftUI
import Combine

struct POIListContainer: View {
    @State private var path = NavigationPath()
    @StateObject private var vm: AnyPOIListViewModel
    @StateObject private var router: POIListRouter
    private let makeDetail: (POI) -> AnyView

    // единый алерт
    @State private var failAlert: FailAlert?
    private struct FailAlert: Identifiable { let id = UUID(); let message: String }

    private var bag = Set<AnyCancellable>() // не @State — но нам хватит onAppear/Disappear

    init(vm: AnyPOIListViewModel, router: POIListRouter, makeDetail: @escaping (POI) -> AnyView) {
        _vm = StateObject(wrappedValue: vm)
        _router = StateObject(wrappedValue: router)
        self.makeDetail = makeDetail
    }

    var body: some View {
        NavigationStack(path: $path) {
            POIListView(viewModel: vm)
                .navigationDestination(for: POIListRoute.self) { route in
                    switch route {
                    case .detail(let poi):
                        makeDetail(poi)
                    }
                }
        }
        .onReceive(router.routes) { cmd in
            switch cmd {
            case .detail(let poi): path.append(POIListRoute.detail(poi))
            case .back: if !path.isEmpty { path.removeLast() }
            case .reset: if !path.isEmpty { path.removeLast(path.count) }
            case .showError(let e):
                failAlert = .init(message: e.localizedMessage)
            }
        }
        .onAppear {
            // Транслируем VM.errorMessage -> роутер
            vm.$errorMessage
                .compactMap { $0 }
                .sink { msg in router.showError(.plain(msg)) }
                .store(in: &router.cancellables)
        }
        .alert(item: $failAlert) { alert in
            Alert(
                title: Text(L10n.alertErrorTitle),
                message: Text(alert.message),
                dismissButton: .default(Text(L10n.alertOk))
            )
        }
        .environmentObject(router)
    }
}
//
//  POIListView.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/1/25.
//


import SwiftUI

public struct POIListView: View {
    @ObservedObject var viewModel: AnyPOIListViewModel
    @EnvironmentObject var router: POIListRouter

    public init(viewModel: AnyPOIListViewModel) {
        self.viewModel = viewModel
    }

    public var body: some View {
        ZStack {
            content
            if viewModel.isLoading {
                if viewModel.pois.isEmpty {
                    ProgressView().scaleEffect(1.2)
                } else {
                    VStack { Spacer() }
                        .overlay(
                            ProgressView()
                                .padding(12)
                                .background(.ultraThinMaterial)
                                .clipShape(RoundedRectangle(cornerRadius: 12))
                                .padding(.bottom, 24),
                            alignment: .bottom
                        )
                }
            }
        }
        .navigationTitle(L10n.navPlacesTitle)
        .onAppear { viewModel.fetchPOIs() }
    }

    @ViewBuilder
    private var content: some View {
        if let err = viewModel.errorMessage {
            VStack(spacing: 16) {
                Text(err).multilineTextAlignment(.center)
                Button(L10n.commonRetry) { viewModel.fetchPOIs() }
            }
            .padding()
        } else {
            VStack {
                Picker(L10n.listCategoryTitle, selection: $viewModel.filter) {
                    ForEach(POICategoryFilter.allCases) { Text($0.localizedTitle).tag($0) }
                }
                .pickerStyle(.segmented)
                .padding(.vertical)

                // Пример использования plural (если хочешь — покажем над списком)
                if !viewModel.pois.isEmpty {
                    Text(L10n.listPlacesCount(viewModel.pois.count))
                        .font(.footnote).foregroundColor(.secondary)
                }

                List(viewModel.pois) { poi in
                    Button { router.goDetail(poi) } label: {
                        HStack {
                            POIImageView(imagePath: poi.imageURL?.path)
                                .frame(width: 48, height: 48)
                                .clipShape(RoundedRectangle(cornerRadius: 8))
                                .padding(.trailing, 4)
                            VStack(alignment: .leading) {
                                Text(poi.name).font(.headline)
                                if let c = poi.category {
                                    Text(c).font(.subheadline).foregroundColor(.secondary)
                                }
                            }
                        }
                        .padding(.vertical, 4)
                    }
                }
                .listStyle(.plain)
            }
        }
    }
}
//
//  AnyOnboardingViewModel.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/26/25.
//

import Combine

/// Универсальный Any-ViewModel для Onboarding, скрывает конкретный тип
public final class AnyOnboardingViewModel: OnboardingViewModelProtocol {
    // MARK: — ObservableObject conformance
    public let objectWillChange = ObservableObjectPublisher()
    private var cancellables = Set<AnyCancellable>()
    
    // MARK: — Outputs
    @Published public private(set) var pages: [OnboardingPage]
    @Published public private(set) var currentPage: Int
    @Published public private(set) var hasCompletedOnboarding: Bool
    
    
    // MARK: — Wrapped instance
    private let wrapped: any OnboardingViewModelProtocol
    
    /// Инициализируем тип-стирающую «обёртку»
    public init(_ wrapped: any OnboardingViewModelProtocol) {
        self.wrapped = wrapped
        // копируем начальные значения
        self.pages               = wrapped.pages
        self.currentPage         = wrapped.currentPage
        self.hasCompletedOnboarding = wrapped.hasCompletedOnboarding
        
        // подписываемся на objectWillChange wrapped-VM,
        // чтобы передавать события субъективного обновления и синхронизировать свойства
        wrapped.objectWillChange
            .sink { [weak self] _ in
                guard let self = self else { return }
                self.pages               = self.wrapped.pages
                self.currentPage         = self.wrapped.currentPage
                self.hasCompletedOnboarding = self.wrapped.hasCompletedOnboarding
                self.objectWillChange.send()
            }
            .store(in: &cancellables)
    }
    
    // MARK: — Inputs: просто делегируем вызовы
    public func next() {
        wrapped.next()
    }
    public func previous() {
        wrapped.previous()
    }
    public func skip() {
        wrapped.skip()
    }
}
//
//  OnboardingViewModel.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/26/25.
//


import Combine
import Foundation

public protocol OnboardingViewModelProtocol: ObservableObject {
    /// Чтобы View могла подписаться на любые изменения
    var objectWillChange: ObservableObjectPublisher { get }
    
    // MARK: — Outputs
    var pages: [OnboardingPage] { get }
    var currentPage: Int { get }
    var hasCompletedOnboarding: Bool { get }
    
    // MARK: — Inputs
    func next()
    func previous()
    func skip()
}

public final class OnboardingViewModel: OnboardingViewModelProtocol {
    // MARK: — ObservableObject conformance
    public let objectWillChange = ObservableObjectPublisher()
    
    // MARK: — Outputs
    @Published public private(set) var currentPage: Int = 0
    @Published public private(set) var hasCompletedOnboarding: Bool
    
    public let pages: [OnboardingPage]
    private var cancellables = Set<AnyCancellable>()
    
    public init() {
        // Страницы онбординга
        self.pages = [
                   OnboardingPage(id: 0, imageName: "onb1",
                                  title: L10n.onbPage1Title, description: L10n.onbPage1Desc),
                   OnboardingPage(id: 1, imageName: "onb2",
                                  title: L10n.onbPage2Title, description: L10n.onbPage2Desc),
                   OnboardingPage(id: 2, imageName: "onb3",
                                  title: L10n.onbPage3Title, description: L10n.onbPage3Desc)
               ]
        self.hasCompletedOnboarding = UserDefaults.standard.hasCompletedOnboarding
    }
    
    // MARK: — Inputs
    
    public func next() {
        guard currentPage < pages.count - 1 else {
            skip()
            return
        }
        currentPage += 1
        objectWillChange.send()                 // <-- уведомляем SwiftUI заранее
    }
    
    public func previous() {
        guard currentPage > 0 else { return }
        currentPage -= 1
        objectWillChange.send()
    }
    
    public func skip() {
        hasCompletedOnboarding = true
        UserDefaults.standard.hasCompletedOnboarding = true
        objectWillChange.send()
    }
}
//
//  OnboardingPage.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/26/25.
//


import Foundation

public struct OnboardingPage: Identifiable {
  public let id: Int
  public let imageName: String
  public let title: String
  public let description: String

  public init(
    id: Int,
    imageName: String,
    title: String,
    description: String
  ) {
    self.id = id
    self.imageName = imageName
    self.title = title
    self.description = description
  }
}
//
//  OnboardingView.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/26/25.
//

import SwiftUI

public struct OnboardingView<VM: OnboardingViewModelProtocol>: View {
    @ObservedObject private var vm: VM

    public init(vm: VM) { self.vm = vm }

    public var body: some View {
        ZStack {
            Color(DesignTokens.colorBackground).ignoresSafeArea()

            VStack(spacing: DesignTokens.spacingMedium) {
                Spacer()

                // Картинка текущей страницы (простая анимация)
                ForEach(vm.pages, id: \.id) { page in
                    if page.id == vm.currentPage {
                        Image(page.imageName)
                            .resizable()
                            .scaledToFit()
                            .frame(maxHeight: 300.scale)
                            .padding(.horizontal, DesignTokens.spacingMedium)
                            .transition(
                                .asymmetric(
                                    insertion: .scale.combined(with: .opacity),
                                    removal: .scale.combined(with: .opacity)
                                )
                            )
                    }
                }

                Text(vm.pages[vm.currentPage].title)
                    .font(.headline)
                    .multilineTextAlignment(.center)
                    .padding(.horizontal, DesignTokens.spacingMedium)

                Text(vm.pages[vm.currentPage].description)
                    .font(.body)
                    .multilineTextAlignment(.center)
                    .padding(.horizontal, DesignTokens.spacingMedium)

                Spacer()

                // Пейдж-индикатор
                HStack(spacing: 5.scale) {
                    ForEach(vm.pages.indices, id: \.self) { idx in
                        Circle()
                            .fill(idx == vm.currentPage
                                  ? Color(DesignTokens.colorPrimary)
                                  : Color.gray.opacity(0.4))
                            .frame(width: 5.scale, height: 5.scale)
                            .scaleEffect(idx == vm.currentPage ? 1.2 : 1.0)
                    }
                }

                // Кнопки
                HStack {
                    if vm.currentPage > 0 {
                        Button(L10n.onbBack) {
                            withAnimation(.easeInOut) { vm.previous() }
                        }
                        .font(.body)
                        .accessibilityIdentifier("onboarding.back")
                        .padding(.trailing, DesignTokens.spacingMedium)
                    }

                    Spacer()

                    Button(vm.currentPage == vm.pages.count - 1 ? L10n.onbGetStarted : L10n.onbNext) {
                        withAnimation(.easeInOut) { vm.next() }
                    }
                    .font(.body)
                    .accessibilityIdentifier(
                        vm.currentPage == vm.pages.count - 1
                        ? "onboarding.get_started" : "onboarding.next"
                    )
                }
                .padding(.horizontal, DesignTokens.spacingMedium)
            }
            .foregroundColor(.primary)
        }
        .animation(.spring(response: 0.5, dampingFraction: 0.7), value: vm.currentPage)
    }
}
