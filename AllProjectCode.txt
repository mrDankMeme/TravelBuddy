//
//  DesignTokens.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/20/25.
//

import UIKit

public enum DesignTokens {
    // MARK: Colors
    public static let colorPrimary = UIColor(hex: "#0055FF")!
    public static let colorBackground = UIColor { trait in
        trait.userInterfaceStyle == .dark
        ? UIColor(hex: "#000000")!
        : UIColor(hex: "#FFFFFF")!
    }
    
    // MARK: Typography
    public static let fontHeadline = UIFont.systemFont(ofSize: 24.scale, weight: .bold)
    public static let fontBody     = UIFont.systemFont(ofSize: 16.scale, weight: .regular)
    
    // MARK: Spacing
    public static let spacingSmall  = 8.scale
    public static let spacingMedium = 16.scale
    
}
//
//  AppConfig.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 9/19/25.
//


import Foundation
import CoreLocation

public struct AppConfig {
    // MARK: — Network
    public let apiBaseURL: URL
    public let httpTimeout: TimeInterval

    // MARK: — Repository / Cache
    public let poiCacheTTL: TimeInterval

    // MARK: — IAP
    public struct IAP {
        public let premiumProductID: String
    }
    public let iap: IAP

    // MARK: — Local data / mocks
    public let localPOIJSONName: String

    // MARK: — Map defaults
    public let defaultRegionMeters: CLLocationDistance

    // MARK: — Feature Flags
    public struct Flags {
        public let enableDebugLogs: Bool
        public let useAlamofireClient: Bool  // на будущее
        public let showBLETab: Bool          // на будущее
        public let enableAudioGuide: Bool    // на будущее
    }
    public let flags: Flags
}


public extension AppConfig {
    static func makeDefault() -> AppConfig {
        #if DEBUG
        return AppConfig(
            apiBaseURL: URL(string: "https://api.example.com")!,
            httpTimeout: 0.15 ,
            poiCacheTTL: 300,
            iap: .init(premiumProductID: "com.travelbuddy.premium"),
            localPOIJSONName: "mock_pois_local",
            defaultRegionMeters: 4000,
            flags: .init(
                enableDebugLogs: true,
                useAlamofireClient: false,
                showBLETab: false,
                enableAudioGuide: false
            )
        )
        #else
        return AppConfig(
            apiBaseURL: URL(string: "https://api.example.com")!,
            httpTimeout: 15,
            poiCacheTTL: 300,
            iap: .init(premiumProductID: "com.travelbuddy.premium"),
            localPOIJSONName: "mock_pois_local",
            defaultRegionMeters: 4000,
            flags: .init(
                enableDebugLogs: false,
                useAlamofireClient: false,
                showBLETab: false,
                enableAudioGuide: false
            )
        )
        #endif
    }
}
//
//  AppRouter.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 9/12/25.
//


import Combine

@MainActor
public final class AppRouter: ObservableObject {
    public let events = PassthroughSubject<AppRoute, Never>()
    public init() {}
    public func send(_ route: AppRoute) { events.send(route) }
}
//
//  AppRoute.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 9/12/25.
//


import Foundation

public enum AppRoute: Equatable {
    case openPOIDetail(POI)
    case openMapWithPOI(POI.ID)
    case openSettings
}
//
//  Scalable.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/26/25.
//

import UIKit

protocol Scalable {
    var scale: Self { get }
}

extension CGFloat: Scalable {
    var scale: CGFloat {
        let designScreenWidth: CGFloat = 375
        let currentScreenWidth = UIScreen.main.bounds.size.width
        return self * currentScreenWidth / designScreenWidth
    }
   
}

extension Int {
    var scale: CGFloat {
        CGFloat(self).scale
    }
}

extension Double {
    var scale: CGFloat {
        CGFloat(self).scale
    }
}

extension CGPoint: Scalable {
    var scale: CGPoint {
        CGPoint(x: x.scale, y: y.scale)
    }
}

extension CGSize: Scalable {
    var scale: CGSize {
        CGSize(width: width.scale, height: height.scale)
    }
}

extension CGRect: Scalable {
    var scale: CGRect {
        CGRect(origin: origin.scale, size: size.scale)
    }
}

extension UIFont {
    var scale: UIFont {
        UIFont(name: fontName, size: pointSize.scale) ?? UIFont.systemFont(ofSize: pointSize.scale)
    }
}

extension UIEdgeInsets: Scalable {
    var scale: UIEdgeInsets {
        UIEdgeInsets(top: top.scale, left: left.scale, bottom: bottom.scale, right: right.scale)
    }
}
//
//  ScreenSize.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/26/25.
//


import UIKit

enum ScreenSize {
    static let bounds: CGRect = (UIScreen.main.bounds)
    static let width: CGFloat = (bounds.width)
    static let height: CGFloat = (bounds.height)
    static let maxLength: CGFloat = (max(width, height))
    static let minLength: CGFloat = (min(width, height))
    
    static let isIphone = UIDevice.current.userInterfaceIdiom == .phone
    static let isRetina = (UIScreen.main.scale >= 2.0)
    static let isIphoneXFamily = (isIphone && maxLength / minLength > 2.0)
}
//
//  UIColor+Hex.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/20/25.
//

import UIKit

public extension UIColor {
  convenience init?(hex: String) {
    var hexSanitized = hex.trimmingCharacters(in: .whitespacesAndNewlines)
    hexSanitized = hexSanitized.replacingOccurrences(of: "#", with: "")
    var rgb: UInt64 = 0
    guard Scanner(string: hexSanitized).scanHexInt64(&rgb) else { return nil }
    let r = CGFloat((rgb & 0xFF0000) >> 16) / 255
    let g = CGFloat((rgb & 0x00FF00) >> 8) / 255
    let b = CGFloat(rgb & 0x0000FF) / 255
    self.init(red: r, green: g, blue: b, alpha: 1)
  }
}
//
//  Publisher+Extensions.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/20/25.
//

import Combine

public extension Publisher {
  func logError(_ tag: String) -> AnyPublisher<Output, Failure> {
    handleEvents(receiveCompletion: { completion in
      if case let .failure(error) = completion {
          Swift.print("[\(tag)] Error:", error)
      }
    })
    .eraseToAnyPublisher()
  }
}
//
//  UserDefaults+AppStorage.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/26/25.
//

import Foundation

extension UserDefaults {
  // MARK: — Ключи
  private enum Keys {
    static let hasCompletedOnboarding = "hasCompletedOnboarding"
    // в будущем сюда можно добавлять другие ключи
  }

  // MARK: — Свойства
  var hasCompletedOnboarding: Bool {
    get { bool(forKey: Keys.hasCompletedOnboarding) }
    set { set(newValue, forKey: Keys.hasCompletedOnboarding) }
  }
}
//
//  AppCoordinator.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/26/25.
//

import UIKit
import SwiftUI
import Combine
import Swinject

protocol Coordinator {
    func start()
}

@MainActor
final class AppCoordinator: Coordinator {
    // MARK: — Dependencies
    private let window: UIWindow
    private let container: DIContainer

    // IAP
    private let iapObserver: IAPObserver
    private let iapService: IAPServiceProtocol

    // MARK: — UI State
    private let tabBar = UITabBarController()
    private var cancellables = Set<AnyCancellable>()

    init(window: UIWindow, container: DIContainer? = nil) {
        self.window = window
        self.container = container ?? DIContainer.shared

        guard
            let observer = self.container.resolver.resolve(IAPObserver.self),
            let iapSvc   = self.container.resolver.resolve(IAPServiceProtocol.self)
        else {
            preconditionFailure("Swinject: IAPObserver/IAPServiceProtocol не зарегистрированы")
        }
        self.iapObserver = observer
        self.iapService  = iapSvc
    }

    // MARK: — Start
    func start() {
        window.makeKeyAndVisible()

        if UserDefaults.standard.hasCompletedOnboarding {
            showMainInterface()
        } else {
            showOnboarding()
        }
    }

    // MARK: — Onboarding Flow
    private func showOnboarding() {
        guard let onboardingVM = container.resolver.resolve(AnyOnboardingViewModel.self) else {
            preconditionFailure("Swinject: AnyOnboardingViewModel не зарегистрирован")
        }

        let onboardingHost = UIHostingController(rootView: OnboardingView(vm: onboardingVM))
        window.rootViewController = onboardingHost

        onboardingVM.$hasCompletedOnboarding
            .filter { $0 }
            .first()
            .receive(on: DispatchQueue.main)
            .sink { [weak self] _ in
                self?.showMainInterface()
            }
            .store(in: &cancellables)
    }

    // MARK: — Main Interface
    private func showMainInterface() {
        // AppRouter
        guard let appRouter = container.resolver.resolve(AppRouter.self) else {
            preconditionFailure("Swinject: AppRouter не зарегистрирован")
        }

        // — POIList Tab
        guard
            let poiListVM     = container.resolver.resolve(AnyPOIListViewModel.self),
            let poiListRouter = container.resolver.resolve(POIListRouter.self)
        else {
            preconditionFailure("Swinject: нет регистрации AnyPOIListViewModel или POIListRouter")
        }
        let poiListCoord = POIListCoordinator(viewModel: poiListVM, router: poiListRouter)
        let poiListHost  = UIHostingController(rootView: poiListCoord.rootView().environmentObject(appRouter))
        //let poiListNav   = UINavigationController(rootViewController: poiListHost)
        poiListHost.tabBarItem = UITabBarItem(title: "Places", image: UIImage(systemName: "map"), tag: 0)

        // — Map Tab
        guard
            let mapVM     = container.resolver.resolve(AnyPOIMapViewModel.self),
            let mapRouter = container.resolver.resolve(MapRouter.self)
        else {
            preconditionFailure("Swinject: нет регистрации AnyPOIMapViewModel или MapRouter")
        }
        let mapCoord = MapCoordinator(vm: mapVM, router: mapRouter)
        let mapHost  = UIHostingController(rootView: mapCoord.rootView().environmentObject(appRouter))
        //let mapNav   = UINavigationController(rootViewController: mapHost)
        mapHost.tabBarItem = UITabBarItem(title: "Map", image: UIImage(systemName: "map.fill"), tag: 1)

        
        guard let settingsVM = container.resolver.resolve(AnySettingsViewModel.self) else {
            preconditionFailure("Swinject: AnySettingsViewModel не зарегистрирован")
        }
        let settingsHost = UIHostingController(rootView: SettingsView(vm: settingsVM).environmentObject(appRouter))
        //let settingsNav  = UINavigationController(rootViewController: settingsHost)
        settingsHost.tabBarItem = UITabBarItem(title: "Settings", image: UIImage(systemName: "gearshape"), tag: 2)

        
        tabBar.viewControllers = [poiListHost, mapHost, settingsHost]
        window.rootViewController = tabBar

        
        bindAppRouter(appRouter)

        // ---- IAP: запускаем наблюдателя и делаем первичную синхронизацию прав
        iapObserver.start()

        iapService.readCurrentPremiumEntitlement()
            .receive(on: DispatchQueue.main)
            .sink { [weak self] hasPremium in
                // TODO: запиши флаг туда, где у тебя хранится глобальное состояние.
                // Например, прокинуть в SettingsViewModel через DI/стор,
                // или послать нотификацию об изменении entitlement'ов.
                _ = self // placeholder, если пока никуда не пишем
            }
            .store(in: &cancellables)
    }

    // MARK: — AppRouter binding
    private func bindAppRouter(_ appRouter: AppRouter) {
        appRouter.events
            .sink { [weak self] route in
                self?.handle(route)
            }
            .store(in: &cancellables)
    }

    // MARK: — Route handling
    private func handle(_ route: AppRoute) {
        switch route {
        case .openPOIDetail(let poi):
            tabBar.selectedIndex = 0

        case .openMapWithPOI(_):
            tabBar.selectedIndex = 1
            // при желании можно прокинуть команду в MapRouter для автофокуса/детали

        case .openSettings:
            tabBar.selectedIndex = 2
        }
    }
}
//
//  DIContainer.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/23/25.
//


// DIContainer.swift
import Foundation
import Swinject
import UIKit
import SwiftUI

@MainActor
public final class DIContainer {
    public static let shared = DIContainer()
    let container = Container()

    private init() {
        // 0) AppConfig —
        let config = AppConfig.makeDefault()
        container.register(AppConfig.self) { _ in config }
            .inObjectScope(.container)

        // 1) Core
        container.register(HTTPClientProtocol.self) { r in
            HTTPClient(timeout: r.resolve(AppConfig.self)!.httpTimeout)
        }.inObjectScope(.container)

        // 2) Services
        container.register(AnalyticsServiceProtocol.self) { _ in AnalyticsService() }
            .inObjectScope(.container)

        container.register(IAPServiceProtocol.self) { r in
            IAPService(config: r.resolve(AppConfig.self)!)
        }.inObjectScope(.container)

        container.register(IAPObserver.self) { r in
            IAPObserver(iap: r.resolve(IAPServiceProtocol.self)!)
        }.inObjectScope(.container)

        container.register(NotificationServiceProtocol.self) { _ in NotificationService() }
            .inObjectScope(.container)

        // 3) POI data stack
        container.register(RemotePOIService.self) { r in
            RemotePOIService(
                httpClient: r.resolve(HTTPClientProtocol.self)!,
                config: r.resolve(AppConfig.self)!
            )
        } // scope по умолчанию .graph — норм

        container.register(LocalPOIService.self) { r in
            LocalPOIService(config: r.resolve(AppConfig.self)!)
        }

        container.register(POICacheProtocol.self) { _ in RealmPOICache() }

        container.register(POIServiceProtocol.self) { r in
            POIRepository(
                remote: r.resolve(RemotePOIService.self)!,
                local:  r.resolve(LocalPOIService.self)!,
                cache:  r.resolve(POICacheProtocol.self)!,
                ttl:    r.resolve(AppConfig.self)!.poiCacheTTL
            )
        }.inObjectScope(.container)

        // 4) Onboarding
        container.register((any OnboardingViewModelProtocol).self) { _ in OnboardingViewModel() }
        container.register(AnyOnboardingViewModel.self) { r in
            AnyOnboardingViewModel(r.resolve((any OnboardingViewModelProtocol).self)!)
        }.inObjectScope(.graph)

        // 5) POIList scene
        container.register((any POIListViewModelProtocol).self) { r in
            POIListViewModel(repository: r.resolve(POIServiceProtocol.self)!)
        }.inObjectScope(.graph)

        container.register(AnyPOIListViewModel.self) { r in
            AnyPOIListViewModel(r.resolve((any POIListViewModelProtocol).self)!)
        }.inObjectScope(.graph)

        container.register(POIListRouter.self) { _ in POIListRouter() }
            .inObjectScope(.graph)

        // 6) Map scene
        container.register((any POIMapViewModelProtocol).self) { r in
            POIMapViewModel(
                service: r.resolve(POIServiceProtocol.self)!,
                factory: DefaultAnnotationFactory()
            )
        }.inObjectScope(.graph)

        container.register(AnyPOIMapViewModel.self) { r in
            AnyPOIMapViewModel(r.resolve((any POIMapViewModelProtocol).self)!)
        }.inObjectScope(.graph)

        container.register(MapRouter.self) { _ in MapRouter() }
            .inObjectScope(.graph)

        // 7) Settings scene
        container.register((any SettingsViewModelProtocol).self) { r in
            SettingsViewModel(
                iapService:   r.resolve(IAPServiceProtocol.self)!,
                analytics:    r.resolve(AnalyticsServiceProtocol.self)!,
                notification: r.resolve(NotificationServiceProtocol.self)!
            )
        }.inObjectScope(.graph)

        container.register(AnySettingsViewModel.self) { r in
            AnySettingsViewModel(r.resolve((any SettingsViewModelProtocol).self)!)
        }.inObjectScope(.graph)

        // 8) AppRouter и Detail
        container.register(AppRouter.self) { _ in AppRouter() }
            .inObjectScope(.container)

        container.register(POIDetailViewModel.self) { _, poi in
            POIDetailViewModel(poi: poi)
        }
        container.register(POIDetailCoordinator.self) { r, poi in
            POIDetailCoordinator(poi: poi, resolver: r)
        }.inObjectScope(.graph)
    }

    public var resolver: Resolver { container.synchronize() }
}
//
//  AppDelegate.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/19/25.
//

import UIKit

@main
class AppDelegate: UIResponder, UIApplicationDelegate {



    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        // Override point for customization after application launch.
        return true
    }

    // MARK: UISceneSession Lifecycle

    func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -> UISceneConfiguration {
        // Called when a new scene session is being created.
        // Use this method to select a configuration to create the new scene with.
        return UISceneConfiguration(name: "Default Configuration", sessionRole: connectingSceneSession.role)
    }

    func application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set<UISceneSession>) {
        // Called when the user discards a scene session.
        // If any sessions were discarded while the application was not running, this will be called shortly after application:didFinishLaunchingWithOptions.
        // Use this method to release any resources that were specific to the discarded scenes, as they will not return.
    }


}

//
//  SceneDelegate.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/19/25.
//

import UIKit

class SceneDelegate: UIResponder, UIWindowSceneDelegate {
    var window: UIWindow?
    var coordinator: AppCoordinator?
    func scene(_ scene: UIScene,
               willConnectTo session: UISceneSession,
               options connectionOptions: UIScene.ConnectionOptions) {
        guard let ws = (scene as? UIWindowScene) else { return }
        let window = UIWindow(windowScene: ws)
        self.window = window
        
        // Инициализируем и запускаем координатор
        coordinator = AppCoordinator(window: window)
        if let coordinator = coordinator {
            coordinator.start()
        }
    }
}

//
//  HTTPClient.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/28/25.
//

// Infrastructure/Networking/HTTPClient.swift
import Foundation
import Combine

public final class HTTPClient: HTTPClientProtocol {
    private let timeout: TimeInterval
    private let decoder: JSONDecoder

    public init(timeout: TimeInterval = 15,
                decoder: JSONDecoder = .init()) {
        self.timeout = timeout
        self.decoder = decoder
    }

    public func send<T: Decodable>(_ requestIn: URLRequest) -> AnyPublisher<T, Error> {
        var request = requestIn
        // если у запроса не задан таймаут – подставим дефолт из клиента
        if request.timeoutInterval == 0 {
            request.timeoutInterval = timeout
        }

        return URLSession.shared.dataTaskPublisher(for: request)
            .tryMap { output -> Data in
                // маппим network-ошибки и статусы
                if let http = output.response as? HTTPURLResponse,
                   !(200...299).contains(http.statusCode) {
                    throw URLError(.badServerResponse)
                }
                return output.data
            }
            .decode(type: T.self, decoder: decoder)
            .eraseToAnyPublisher()
    }
}
//
//  HTTPClientProtocol.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/20/25.
//


import Foundation
import Combine

public protocol HTTPClientProtocol {
  func send<T: Decodable>(_ request: URLRequest) -> AnyPublisher<T, Error>
}

//
//  POIRepository.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/1/25.
//


import Combine
import Foundation

public final class POIRepository: POIServiceProtocol {
    private let remote: POIServiceProtocol
    private let local: POIServiceProtocol
    private let cache: POICacheProtocol
    private let ttl: TimeInterval

    // in-flight общий publisher для дедупликации конкурентных запросов
    private let stateQueue = DispatchQueue(label: "poi.repo.state")
    private var inFlight: AnyPublisher<[POI], Error>?

    // хранение времени последнего успешного remote save (не меняем протокол кэша)
    private let lastRefreshKey = "poi.cache.lastRefreshAt"

    public init(remote: POIServiceProtocol,
                 local: POIServiceProtocol,
                 cache: POICacheProtocol,
                 ttl: TimeInterval) {
         self.remote = remote
         self.local  = local
         self.cache  = cache
         self.ttl    = ttl
     }

    public func fetchPOIs() -> AnyPublisher<[POI], Error> {
        let cached = loadCacheAsync()

        // если кэш свежий — отдаём его и выходим
        if isFresh() {
            return cached
        }

        // иначе: сразу отдаём содержимое кэша (если есть) и затем — обновление из сети
        // (если in-flight уже идёт — переиспользуем)
        let refresh = remoteOnceShared()
            .catch { [weak self] _ -> AnyPublisher<[POI], Error> in
                guard let self else {
                    return Fail(error: URLError(.unknown)).eraseToAnyPublisher()
                }
                // fallback: локальный JSON (и одновременно обновим кэш)
                return self.local.fetchPOIs()
                    .handleEvents(receiveOutput: { [weak self] pois in
                        self?.saveToCache(pois)
                    })
                    .eraseToAnyPublisher()
            }

        // cacheThenRefresh: сначала кэш, затем сеть
        return cached
            .filter { !$0.isEmpty }
            .append(refresh)
            .eraseToAnyPublisher()
    }

    // MARK: - Helpers

    private func loadCacheAsync() -> AnyPublisher<[POI], Error> {
        Deferred {
            Future<[POI], Error> { [weak self] promise in
                guard let self else {
                    promise(.failure(URLError(.unknown))); return
                }
                DispatchQueue.global(qos: .userInitiated).async {
                    let pois = self.cache.load()
                    promise(.success(pois))
                }
            }
        }
        .eraseToAnyPublisher()
    }

    private func remoteOnceShared() -> AnyPublisher<[POI], Error> {
        // 1) если уже есть общий in-flight, вернём его
        if let shared = stateQueue.sync(execute: { inFlight }) {
            return shared
        }

        // 2) создаём новый, сохраняем в inFlight и шарим
        let publisher = remote.fetchPOIs()
            .handleEvents(receiveOutput: { [weak self] pois in
                self?.saveToCache(pois)
                self?.setLastRefresh(Date())
            }, receiveCompletion: { [weak self] _ in
                self?.stateQueue.async { self?.inFlight = nil }
            }, receiveCancel: { [weak self] in
                self?.stateQueue.async { self?.inFlight = nil }
            })
            .share()
            .eraseToAnyPublisher()

        stateQueue.async { [weak self] in self?.inFlight = publisher }
        return publisher
    }

    private func saveToCache(_ pois: [POI]) {
        // запись синхронная внутри реализаций; если будет дисковая — они уже у тебя в autoreleasepool
        cache.save(pois)
    }

    // MARK: - TTL

    private func isFresh(now: Date = Date()) -> Bool {
        guard let last = getLastRefresh() else { return false }
        return now.timeIntervalSince(last) < ttl
    }

    private func getLastRefresh() -> Date? {
        let t = UserDefaults.standard.double(forKey: lastRefreshKey)
        return t > 0 ? Date(timeIntervalSince1970: t) : nil
    }

    private func setLastRefresh(_ date: Date) {
        UserDefaults.standard.set(date.timeIntervalSince1970, forKey: lastRefreshKey)
    }
}
//
//  RealmPOICache.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/30/25.
//

import Foundation
import RealmSwift

public final class RealmPOICache: POICacheProtocol {
    public func save(_ pois: [POI]) {
        autoreleasepool {
            do {
                let realm = try Realm()
                let objects = pois.map { RealmPOI(poi: $0) }
                try realm.write { realm.add(objects, update: .modified) }
            } catch { /* лог при желании */ }
        }
    }

    public func load() -> [POI] {
        autoreleasepool {
            (try? Realm()).map { Array($0.objects(RealmPOI.self)).map { $0.toPOI() } } ?? []
        }
    }
}

public final class RealmPOI: Object {
    @objc dynamic var id = 0
    @objc dynamic var name = ""
    @objc dynamic var latitude = 0.0
    @objc dynamic var longitude = 0.0
    @objc dynamic var category: String? = nil
    @objc dynamic var descriptionText: String? = nil
    @objc dynamic var imageURLString: String? = nil

    public override static func primaryKey() -> String? { "id" }

    convenience init(poi: POI) {
        self.init()
        id = poi.id; name = poi.name
        latitude = poi.latitude; longitude = poi.longitude
        category = poi.category
        descriptionText = poi.description
        imageURLString = poi.imageURL?.absoluteString
    }

    func toPOI() -> POI {
        POI(
          id: id, name: name,
          latitude: latitude, longitude: longitude,
          category: category,
          description: descriptionText,
          imageURL: imageURLString.flatMap(URL.init)
        )
    }
}

//
//  RemotePOIService.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/28/25.
//

import Foundation
import Combine

public final class RemotePOIService: POIServiceProtocol {
    private let httpClient: HTTPClientProtocol
    private let baseURL: URL

    public init(httpClient: HTTPClientProtocol, config: AppConfig) {
        self.httpClient = httpClient
        self.baseURL = config.apiBaseURL
    }

    public func fetchPOIs() -> AnyPublisher<[POI], Error> {
        let url = baseURL.appendingPathComponent("pois")
        return httpClient.send(URLRequest(url: url))
    }
}
//
//  LocalPOIService.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/28/25.
//

import Foundation
import Combine

public final class LocalPOIService: POIServiceProtocol {
    private let jsonName: String
    
    public init(config: AppConfig) {
        self.jsonName = config.localPOIJSONName
    }
    
    
    public func fetchPOIs() -> AnyPublisher<[POI], Error> {
        Deferred {
            Future<[POI], Error> { promise in
                DispatchQueue.global(qos: .background).async {
                    do {
                        guard let url = Bundle.main.url(forResource: self.jsonName, withExtension: "json") else {
                            promise(.failure(URLError(.fileDoesNotExist)))
                            return
                        }
                        let data = try Data(contentsOf: url)
                        let pois = try JSONDecoder().decode([POI].self, from: data)
                        //Thread.sleep(forTimeInterval: 0)
                        promise(.success(pois))
                    } catch {
                        promise(.failure(error))
                    }
                }
            }
        }
        .eraseToAnyPublisher()
    }
}
//
//  NotificationServiceProtocol.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/28/25.
//


import UserNotifications
import Combine

public protocol NotificationServiceProtocol {
  func requestAuthorization() -> AnyPublisher<Bool, Never>
  func schedule(_ content: UNNotificationContent, at date: Date)
}
//
//  NotificationService.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/20/25.
//


import UserNotifications
import Combine


public final class NotificationService: NotificationServiceProtocol {
  public init() {}

  public func requestAuthorization() -> AnyPublisher<Bool, Never> {
    Future { promise in
      UNUserNotificationCenter.current()
        .requestAuthorization(options: [.alert, .sound]) { granted, _ in
          promise(.success(granted))
        }
    }
    .eraseToAnyPublisher()
  }

  public func schedule(_ content: UNNotificationContent, at date: Date) {
    let interval = max(1, date.timeIntervalSinceNow)
    let trigger = UNTimeIntervalNotificationTrigger(timeInterval: interval, repeats: false)
    let req = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)
    UNUserNotificationCenter.current().add(req)
  }
}
//
//  IAPObserver.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 9/17/25.
//


import StoreKit
import Combine

extension Notification.Name {
  static let iapEntitlementsChanged = Notification.Name("iapEntitlementsChanged")
}

public final class IAPObserver {
  private let iap: IAPServiceProtocol
  private var task: Task<Void, Never>?

  public init(iap: IAPServiceProtocol) { self.iap = iap }

  public func start() {
    guard task == nil else { return }
    task = Task.detached { [weak self] in
      await self?.observeTransactions()
    }
  }

  public func stop() { task?.cancel(); task = nil }
  deinit { stop() }

  private func observeTransactions() async {
    for await update in Transaction.updates {
      do {
        let tx: Transaction = try iap.verify(update)
        // выдаю право пользователю на использование
        await tx.finish()
        // сообщим UI, что энтитлменты могли измениться
        NotificationCenter.default.post(name: .iapEntitlementsChanged, object: nil)
      } catch {
        // опционально: лог/метрики
      }
    }
  }
}
//
//  IAPServiceProtocol.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/28/25.
//



import StoreKit
import Combine


public protocol IAPServiceProtocol {
  func fetchProducts() -> AnyPublisher<[Product], Error>
  func purchase(_ product: Product) -> AnyPublisher<Transaction, Error>
  func verify<T>(_ result: VerificationResult<T>) throws -> T
  func readCurrentPremiumEntitlement() -> AnyPublisher<Bool, Never>
}
//
//  IAPService.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/20/25.
//


import StoreKit
import Combine

public final class IAPService: IAPServiceProtocol {
    private let productID: String
    public init(config: AppConfig) {
        self.productID = config.iap.premiumProductID
    }
    
    public func fetchProducts() -> AnyPublisher<[Product], Error> {
        Deferred {
            Future { promise in
                Task {
                    do {
                        let ids: Set<String> = [self.productID]
                        let products = try await Product.products(for: ids)
                        promise(.success(products))
                    } catch { promise(.failure(error)) }
                }
            }
        }
        .eraseToAnyPublisher()
    }
    
    public func purchase(_ product: Product) -> AnyPublisher<Transaction, Error> {
        Deferred {
            Future { promise in
                Task {
                    do {
                        let result = try await product.purchase()
                        switch result {
                        case .success(let verification):
                            let tx: Transaction = try self.verify(verification)
                            await tx.finish()
                            promise(.success(tx))
                        case .userCancelled:
                            let err = NSError(domain: "IAP", code: NSUserCancelledError,
                                              userInfo: [NSLocalizedDescriptionKey: "Purchase cancelled"])
                            promise(.failure(err))
                        case .pending:
                            let err = NSError(domain: "IAP", code: -1,
                                              userInfo: [NSLocalizedDescriptionKey: "Purchase pending"])
                            promise(.failure(err))
                        @unknown default:
                            let err = NSError(domain: "IAP", code: -2,
                                              userInfo: [NSLocalizedDescriptionKey: "Unknown purchase result"])
                            promise(.failure(err))
                        }
                    } catch { promise(.failure(error)) }
                }
            }
        }
        .eraseToAnyPublisher()
    }
    
    // MARK: - NEW
    public func verify<T>(_ result: VerificationResult<T>) throws -> T {
        switch result {
        case .verified(let safe): return safe
        case .unverified(_, let error): throw error
        }
    }
    
    public func readCurrentPremiumEntitlement() -> AnyPublisher<Bool, Never> {
        Deferred {
            Future<Bool, Never> { promise in
                Task {
                    var hasPremium = false
                    for await entitlement in Transaction.currentEntitlements {
                        if case .verified(let tx) = entitlement,
                           tx.productID == self.productID {
                            hasPremium = true
                            break
                        }
                    }
                    promise(.success(hasPremium))
                }
            }
        }
        .eraseToAnyPublisher()
    }
}
//
//  AnalyticsServiceProtocol.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/28/25.
//


import Foundation

public protocol AnalyticsServiceProtocol {
  func logEvent(name: String, parameters: [String: Any]?)
  func recordError(_ error: Error)
}
//
//  AnalyticsService.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/20/25.
//

import FirebaseAnalytics
import FirebaseCrashlytics


public final class AnalyticsService: AnalyticsServiceProtocol {
  public init() {}
  public func logEvent(name: String, parameters: [String: Any]?) {
    Analytics.logEvent(name, parameters: parameters)
  }
  public func recordError(_ error: Error) {
    Crashlytics.crashlytics().record(error: error)
  }
}
//
//  POICategoryFilter.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/1/25.
//

import Foundation

public enum POICategoryFilter: String, CaseIterable, Identifiable {
    case all = "All", monument = "Monument", museum = "Museum", cafe = "Cafe"
    public var id: String { rawValue }
}


//
//  POI.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/20/25.
//

import Foundation

public struct POI: Identifiable, Decodable, Hashable {
    public let id: Int
    public let name: String
    public let latitude: Double
    public let longitude: Double
    public let category: String?
    public let description: String?
    public let imageURL: URL?
}
//
//  POIServiceProtocol.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/11/25.
//


import Foundation
import Combine

public protocol POIServiceProtocol {
  func fetchPOIs() -> AnyPublisher<[POI], Error>
}//
//  POICacheProtocol.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/28/25.
//


import Foundation

public protocol POICacheProtocol: AnyObject {
    func save(_ pois: [POI])
    func load() -> [POI]
}
//
//  SettingsView.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/23/25.
//

import SwiftUI

public struct SettingsView<VM: SettingsViewModelProtocol>: View {
  @ObservedObject var vm: VM

  public init(vm: VM) { self.vm = vm }

  public var body: some View {
    NavigationView {
      Form {
          Toggle("Dark Mode", isOn: Binding(
            get:  { vm.isDarkMode },
            set:  { vm.setDarkMode($0) }
          ))

          Toggle("Notifications", isOn: Binding(
            get:  { vm.notificationsEnabled },
            set:  { vm.setNotifications($0) }
          ))

        Button(action: { vm.purchasePremium() }) {
          Text(vm.premiumUnlocked ? "Premium Unlocked" : "Unlock Premium")
        }
        .disabled(vm.premiumUnlocked)
      }
      .navigationTitle("Settings")
      .alert(item: Binding(
        get: { vm.errorMessage.map { AlertError(message: $0) } },
        set: { _ in vm.clearError() }
      )) { alertError in
        Alert(title: Text("Error"), message: Text(alertError.message))
      }
    }
  }
}

private struct AlertError: Identifiable {
  let id = UUID()
  let message: String
}
//
//  SettingsViewModel.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/20/25.
//

import Combine
import StoreKit
import SwiftUI

public protocol SettingsViewModelProtocol: ObservableObject {
    var objectWillChange: ObservableObjectPublisher { get }
    
    var isDarkMode: Bool { get }
    var notificationsEnabled: Bool { get }
    var premiumUnlocked: Bool { get }
    var errorMessage: String? { get }
    
    func setDarkMode(_ isOn: Bool)
    func setNotifications(_ isOn: Bool)
    
    func purchasePremium()
    func clearError()
}


public final class SettingsViewModel: SettingsViewModelProtocol {
    public let objectWillChange = ObservableObjectPublisher()
    
    private enum Keys {
        static let darkMode = "settings.darkMode"
        static let notificationsEnabled = "settings.notificationsEnabled"
    }
    
    @Published public private(set) var isDarkMode = UserDefaults.standard.bool(forKey: Keys.darkMode)
    @Published public private(set) var notificationsEnabled = UserDefaults.standard.bool(forKey: Keys.notificationsEnabled)
    @Published public private(set) var premiumUnlocked = false
    @Published public private(set) var errorMessage: String?
    
    private let iapService: IAPServiceProtocol
    private let analytics: AnalyticsServiceProtocol
    private let notification: NotificationServiceProtocol
    private var bag = Set<AnyCancellable>()
    
    public init(iapService: IAPServiceProtocol,
                analytics: AnalyticsServiceProtocol,
                notification: NotificationServiceProtocol) {
        self.iapService = iapService
        self.analytics  = analytics
        self.notification = notification
        
        iapService.readCurrentPremiumEntitlement()
            .receive(on: DispatchQueue.main)
            .sink { [weak self] has in self?.premiumUnlocked = has }
            .store(in: &bag)
        
        NotificationCenter.default.publisher(for: .iapEntitlementsChanged)
            .flatMap { [iapService] _ in iapService.readCurrentPremiumEntitlement() }
            .receive(on: DispatchQueue.main)
            .sink { [weak self] has in self?.premiumUnlocked = has }
            .store(in: &bag)
    }
    
    public func setDarkMode(_ isOn: Bool) {
        guard isDarkMode != isOn else { return }
        isDarkMode = isOn
        UserDefaults.standard.set(isOn, forKey: Keys.darkMode)
        analytics.logEvent(name: "settings_dark_mode_changed", parameters: ["value": isOn])
    }
    
    public func setNotifications(_ isOn: Bool) {
        guard notificationsEnabled != isOn else { return }
        notificationsEnabled = isOn
        UserDefaults.standard.set(isOn, forKey: Keys.notificationsEnabled )
        analytics.logEvent(name: "settings_notifications_changed", parameters: ["value": isOn])
        if isOn {
            notification.requestAuthorization().sink { _ in }.store(in: &bag)
        }
    }
    // — остальной код IAP без изменений
    public func purchasePremium() {
        errorMessage = nil
        
        iapService.fetchProducts()
            .tryMap { products -> Product in
                guard let p = products.first else {
                    throw NSError(domain: "IAP", code: -3, userInfo: [NSLocalizedDescriptionKey: "Product not found"])
                }
                return p
            }
            .flatMap { [iapService] product in
                iapService.purchase(product)
            }
            .flatMap { [iapService] _ in
                iapService.readCurrentPremiumEntitlement()
            }
            .receive(on: DispatchQueue.main)
            .sink(receiveCompletion: { [weak self] comp in
                if case let .failure(err) = comp { self?.errorMessage = err.localizedDescription }
            }, receiveValue: { [weak self] has in
                self?.premiumUnlocked = has
            })
            .store(in: &bag)
    }
    
    public func clearError() { errorMessage = nil }
}
//
//  AnySettingsViewModel.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/24/25.


import Combine
import StoreKit
import SwiftUI

final class AnySettingsViewModel: ObservableObject, SettingsViewModelProtocol {
    private let wrapped: any SettingsViewModelProtocol
    private var cancellables = Set<AnyCancellable>()

    let objectWillChange = ObservableObjectPublisher()

    @Published private(set) var isDarkMode: Bool = false
    @Published private(set) var notificationsEnabled: Bool = false
    @Published private(set) var premiumUnlocked: Bool = false
    @Published private(set) var errorMessage: String?

    init(_ wrapped: any SettingsViewModelProtocol) {
        self.wrapped = wrapped

        // Важно: objectWillChange у wrapped — это willSet.
        // Синхронизируемся на следующий runloop-так, чтобы читать уже обновлённые значения.
        wrapped.objectWillChange
            .receive(on: DispatchQueue.main)
            .sink { [weak self] _ in
                DispatchQueue.main.async {
                    guard let self else { return }
                    self.syncProperties()
                    self.objectWillChange.send()
                }
            }
            .store(in: &cancellables)

        syncProperties()
    }

    private func syncProperties() {
        isDarkMode = wrapped.isDarkMode
        notificationsEnabled = wrapped.notificationsEnabled
        premiumUnlocked = wrapped.premiumUnlocked
        errorMessage = wrapped.errorMessage
    }

    func setDarkMode(_ isOn: Bool) {
        if isDarkMode != isOn {
            isDarkMode = isOn          // мгновенно для SwiftUI
            objectWillChange.send()    // на случай, если где-то нужен немедленный импульс
        }
        wrapped.setDarkMode(isOn)      // источник истины
    }

    func setNotifications(_ isOn: Bool) {
        if notificationsEnabled != isOn {
            notificationsEnabled = isOn
            objectWillChange.send()
        }
        wrapped.setNotifications(isOn)
    }

    func purchasePremium() { wrapped.purchasePremium() }
    func clearError()      { wrapped.clearError() }
}
//
//  POIDetailViewModelProtocol.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/11/25.
//


import Combine
import MapKit

public protocol POIDetailViewModelProtocol: AnyObject {
  // Outputs
  var model: POIDetailModel { get }
  var isLoadingAddress: Bool { get }
  var address: String? { get }
  var errorMessage: String? { get }

  // User actions
  func onAppear()
  func didTapShare()
  func didTapOpenInMaps()
  func didTapClose()

  // Publishers for Coordinator/Router
  var sharePublisher: AnyPublisher<URL, Never> { get }
  var openInMapsPublisher: AnyPublisher<MKMapItem, Never> { get }
  var closePublisher: AnyPublisher<Void, Never> { get }

  // Publisher for model updates
  var modelPublisher: AnyPublisher<POIDetailModel, Never> { get }
}

@MainActor
public final class POIDetailViewModel: ObservableObject, POIDetailViewModelProtocol {
  @Published public private(set) var model: POIDetailModel
  @Published public private(set) var isLoadingAddress = false
  @Published public private(set) var address: String?
  @Published public private(set) var errorMessage: String?

  private let geocoder = CLGeocoder()
  private var cancellables = Set<AnyCancellable>()

  public init(poi: POI) {
    self.model = POIDetailModel(poi: poi,
                                address: nil,
                                imageData: nil)
  }

  public func onAppear() {
    guard address == nil else { return }
    isLoadingAddress = true
    let loc = CLLocation(latitude: model.poi.latitude,
                         longitude: model.poi.longitude)
    geocoder.reverseGeocodeLocation(loc) { [weak self] places, error in
      DispatchQueue.main.async {
          self?.isLoadingAddress = false
        if let err = error {
          self?.errorMessage = err.localizedDescription
        } else {
          self?.address = places?.first?.compactAddress
        }
      }
    }
  }

  public func didTapShare() {
    let p = model.poi
    let url = URL(string: "https://maps.apple.com/?ll=\(p.latitude),\(p.longitude)")!
    shareSubject.send(url)
  }

  public func didTapOpenInMaps() {
    let p = model.poi
    let coord = CLLocationCoordinate2D(latitude: p.latitude,
                                       longitude: p.longitude)
    let item = MKMapItem(placemark: MKPlacemark(coordinate: coord))
    item.name = p.name
    openInMapsSubject.send(item)
  }

  public func didTapClose() {
    closeSubject.send(())
  }

  // Internal subjects
  private let shareSubject      = PassthroughSubject<URL, Never>()
  private let openInMapsSubject = PassthroughSubject<MKMapItem, Never>()
  private let closeSubject      = PassthroughSubject<Void, Never>()

  // Protocol publishers
  public var sharePublisher: AnyPublisher<URL, Never> {
    shareSubject.eraseToAnyPublisher()
  }
  public var openInMapsPublisher: AnyPublisher<MKMapItem, Never> {
    openInMapsSubject.eraseToAnyPublisher()
  }
  public var closePublisher: AnyPublisher<Void, Never> {
    closeSubject.eraseToAnyPublisher()
  }

  public var modelPublisher: AnyPublisher<POIDetailModel, Never> {
    $model.eraseToAnyPublisher()
  }
}

private extension CLPlacemark {
  var compactAddress: String {
    [subThoroughfare, thoroughfare, locality, administrativeArea]
      .compactMap { $0 }
      .joined(separator: ", ")
  }
}
//
//  POIDetailRoute.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/11/25.
//


import Combine
import MapKit

public enum POIDetailRoute: Hashable, Identifiable {
  case share(URL)
  case openInMaps(MKMapItem)
  case close

  public var id: String {
    switch self {
    case .share(let url):
      return "share:\(url.absoluteString)"
    case .openInMaps(let item):
      let c = item.placemark.coordinate
      return "open:\(c.latitude),\(c.longitude)"
    case .close:
      return "close"
    }
  }
}

@MainActor
public final class POIDetailRouter: ObservableObject {
  public let routes = PassthroughSubject<POIDetailRoute, Never>()
  private var cancellables = Set<AnyCancellable>()

  public init(viewModel: POIDetailViewModel) {
    // мы теперь используем конкретную ViewModel
    viewModel.sharePublisher
      .map(POIDetailRoute.share)
      .sink { [routes] in routes.send($0) }
      .store(in: &cancellables)

    viewModel.openInMapsPublisher
      .map(POIDetailRoute.openInMaps)
      .sink { [routes] in routes.send($0) }
      .store(in: &cancellables)

    viewModel.closePublisher
      .map { _ in POIDetailRoute.close }
      .sink { [routes] in routes.send($0) }
      .store(in: &cancellables)
  }
}
// Presentation/Scenes/POIDetail/Navigation/POIDetailCoordinator.swift
import SwiftUI
import Combine
import Swinject

@MainActor
public final class POIDetailCoordinator: ObservableObject {
    @Published private(set) var sheetRoute: POIDetailRoute?
    @Published private(set) var model: POIDetailModel

    private let viewModel: POIDetailViewModel
    private let router: POIDetailRouter
    private var cancellables = Set<AnyCancellable>()

    
    public init(poi: POI, resolver: Resolver? = nil) {
        let r = resolver ?? DIContainer.shared.resolver
        // получаем конкретную VM через переданный resolver
        guard let vm = r.resolve(POIDetailViewModel.self, argument: poi) else {
            preconditionFailure("Swinject: POIDetailViewModel не зарегистрирован для \(POI.self)")
        }

        self.viewModel = vm
        self.router    = POIDetailRouter(viewModel: vm)
        self.model     = vm.model

        // Навигация
        router.routes
            .sink { [weak self] route in
                switch route {
                case .share(let url):       self?.sheetRoute = .share(url)
                case .openInMaps(let item): item.openInMaps(launchOptions: nil)
                case .close:                self?.sheetRoute = nil
                }
            }
            .store(in: &cancellables)

        // Синхронизация модели
        vm.modelPublisher
            .sink { [weak self] newModel in
                self?.model = newModel
            }
            .store(in: &cancellables)
    }

    @ViewBuilder
    public func rootView() -> some View {
        let binding = Binding<POIDetailRoute?>(
            get: { self.sheetRoute },
            set: { self.sheetRoute = $0 }
        )
        POIDetailView(viewModel: viewModel, sheetRoute: binding)
    }
}
//
//  POIDetailModel.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/11/25.
//


import Foundation

public struct POIDetailModel {
  public let poi: POI
  public let address: String?
  public let imageData: Data?

  public init(
    poi: POI,
    address: String?,
    imageData: Data?
  ) {
    self.poi = poi
    self.address = address
    self.imageData = imageData
  }
}
//
//  POIDetailView.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/11/25.
//


import SwiftUI
import MapKit

public struct POIDetailView: View {
  @ObservedObject private var vm: POIDetailViewModel
  @Binding private var sheetRoute: POIDetailRoute?

  public init(
    viewModel: POIDetailViewModel,
    sheetRoute: Binding<POIDetailRoute?>
  ) {
    self.vm = viewModel
    self._sheetRoute = sheetRoute
  }

  public var body: some View {
    VStack(spacing: 16) {
      HStack { Spacer()
        Button(action: vm.didTapClose) {
          Image(systemName: "xmark.circle.fill")
            .font(.title2)
        }
      }

      Text(vm.model.poi.name)
        .font(.largeTitle)

      if vm.isLoadingAddress {
        ProgressView("Loading address…")
      } else if let addr = vm.address {
        Text(addr).italic()
      } else if let err = vm.errorMessage {
        Text(err).foregroundColor(.red)
      }

      Button("Share",        action: vm.didTapShare)
      Button("Open in Maps", action: vm.didTapOpenInMaps)
      Spacer()
    }
    .padding()
    .onAppear(perform: vm.onAppear)
    .navigationTitle(vm.model.poi.name)
    .sheet(item: $sheetRoute) { route in
      switch route {
      case .share(let url):
        ActivityViewController(activityItems: [url])
      default:
        EmptyView()
      }
    }
  }
}

// UIKit wrapper
struct ActivityViewController: UIViewControllerRepresentable {
  let activityItems: [Any]

  func makeUIViewController(
    context: Context
  ) -> UIActivityViewController {
    UIActivityViewController(
      activityItems: activityItems,
      applicationActivities: nil
    )
  }

  func updateUIViewController(
    _ vc: UIActivityViewController,
    context: Context
  ) {}
}
//
//  POIMapViewModelProtocol.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/7/25.
//


import Combine
import MapKit

public protocol POIMapViewModelProtocol: ObservableObject {
    var annotations: [POIAnnotation] { get }
    var selectedPOI: POI? { get }
    func fetch()
    func select(annotation: POIAnnotation)
}

public final class POIMapViewModel: POIMapViewModelProtocol {
    // Output
    @Published public private(set) var annotations: [POIAnnotation] = []
    @Published public private(set) var selectedPOI: POI?

    // Deps
    private let service: POIServiceProtocol
    private let factory: AnnotationFactory
    private var bag = Set<AnyCancellable>()

    init(service: POIServiceProtocol,
                factory: AnnotationFactory = DefaultAnnotationFactory()) {
        self.service  = service
        self.factory  = factory
    }

    public func fetch() {
        service.fetchPOIs()
            .map(factory.makeAnnotations)
            .receive(on: DispatchQueue.main)
            .sink(receiveCompletion: { _ in },
                  receiveValue: { [weak self] in self?.annotations = $0 })
            .store(in: &bag)
    }

    public func select(annotation: POIAnnotation) {
        selectedPOI = annotation.poi
    }
}
//
//  AnyPOIMapViewModel.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/7/25.
//


import Combine
import SwiftUI

public final class AnyPOIMapViewModel: ObservableObject {
    // -------- SwiftUI bindings --------
    @Published public var annotations: [POIAnnotation] = []
    @Published public var selectedPOI: POI?            = nil

    // -------- Internals --------
    private let wrapped: any POIMapViewModelProtocol
    private var bag = Set<AnyCancellable>()

    // MARK: – init
    public init(_ wrapped: any POIMapViewModelProtocol) {
        self.wrapped      = wrapped
        self.annotations  = wrapped.annotations
        self.selectedPOI  = wrapped.selectedPOI

        // Если это именно POIMapViewModel, подписываемся на его @Published-поля
        if let concrete = wrapped as? POIMapViewModel {
            concrete.$annotations
                .receive(on: DispatchQueue.main)
                .assign(to: &$annotations)

            concrete.$selectedPOI
                .receive(on: DispatchQueue.main)
                .assign(to: &$selectedPOI)
        }
    }

    // MARK: – Facade
    public func fetch()                           { wrapped.fetch() }
    public func select(annotation: POIAnnotation) { wrapped.select(annotation: annotation) }
}
//
//  MapRoute.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/11/25.
//


import SwiftUI
import Combine

enum MapRoute: Hashable {
    case detail(POI)
}

enum MapNavigationCommand {
    case detail(POI)
    case back
    case reset
}

@MainActor
final class MapRouter: ObservableObject {
    fileprivate var cancellables = Set<AnyCancellable>()
    let routes = PassthroughSubject<MapNavigationCommand, Never>()

    func goDetail(_ poi: POI) {
        routes.send(MapNavigationCommand.detail(poi))
    }

    func goBack() {
        routes.send(MapNavigationCommand.back)
    }

    func reset() {
        routes.send(MapNavigationCommand.reset)
    }
}//
//  MapCoordinator.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/10/25.
//


import SwiftUI
import Combine
import MapKit

@MainActor
final class MapCoordinator {
    private let vm: AnyPOIMapViewModel
    private let router: MapRouter
    private let defaultRegionMeters: CLLocationDistance
    private let makeDetail: (POI) -> AnyView
   
    
    init(vm: AnyPOIMapViewModel, router: MapRouter) {
        self.vm     = vm
        self.router = router
        
        let config = DIContainer.shared.resolver.resolve(AppConfig.self)!
        self.defaultRegionMeters = config.defaultRegionMeters
        let resolver = DIContainer.shared.resolver
        self.makeDetail = { poi in
            guard let coord = resolver.resolve(POIDetailCoordinator.self, argument: poi) else {
                return AnyView(EmptyView())
            }
            return AnyView(coord.rootView())
        }
    }
    
    func rootView() -> some View {
        MapContainer(vm: vm, router: router, defaultRegionMeters: defaultRegionMeters, makeDetail: makeDetail)
    }
}

//
//  POIAnnotation.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/7/25.
//


import MapKit

/// Простая обёртка над POI, чтобы стать MKAnnotation
public final class POIAnnotation: NSObject, MKAnnotation {
    let poi: POI

    // локально собираем координату, модель POI не меняем
    public var coordinate: CLLocationCoordinate2D {
        .init(latitude: poi.latitude, longitude: poi.longitude)
    }

    public var title: String?    { poi.name      }
    public var subtitle: String? { poi.category  }

    init(poi: POI) { self.poi = poi }
}

/// SRP-фабрика для тестов и явной зависимости
protocol AnnotationFactory {
    func makeAnnotations(from pois: [POI]) -> [POIAnnotation]
}

struct DefaultAnnotationFactory: AnnotationFactory {
    func makeAnnotations(from pois: [POI]) -> [POIAnnotation] {
        pois.map(POIAnnotation.init)
    }
}
//
//  POISnippetView.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/7/25.
//



import SwiftUI
import MapKit

struct POISnippetView: View {
    let poi: POI
    var onDetails: () -> Void
    var onRoute:   () -> Void

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text(poi.name).font(.title2).bold()
            if let cat = poi.category { Text(cat).foregroundColor(.secondary) }
            if let desc = poi.description { Text(desc).lineLimit(3) }

            HStack {
                Button("Details", action: onDetails)
                    .buttonStyle(.borderedProminent)

                Spacer()
                Button("Route", action: onRoute)
            }
        }
        .padding()
    }
}
//
//  MapViewRepresentable.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/7/25.
//


import SwiftUI
import MapKit

struct MapViewRepresentable: UIViewRepresentable {
    let annotations: [POIAnnotation]
    let defaultRegionMeters: CLLocationDistance
    let onSelect: (POIAnnotation) -> Void

    func makeCoordinator() -> Coordinator { Coordinator(self) }

    func makeUIView(context: Context) -> MKMapView {
        let map = MKMapView()
        map.delegate = context.coordinator
        map.register(MKMarkerAnnotationView.self,
                     forAnnotationViewWithReuseIdentifier: "marker")
        map.register(MKMarkerAnnotationView.self,
                     forAnnotationViewWithReuseIdentifier: "cluster")
        map.showsUserLocation = true
        map.pointOfInterestFilter = .excludingAll
        return map
    }

    func updateUIView(_ map: MKMapView, context: Context) {
        
        let existing = map.annotations.compactMap { $0 as? POIAnnotation }
        let existingIDs = Set(existing.map { $0.poi.id })
        let incomingIDs = Set(annotations.map { $0.poi.id })

        
        let toRemove = existing.filter { !incomingIDs.contains($0.poi.id) }
        if !toRemove.isEmpty { map.removeAnnotations(toRemove) }

        
        let toAdd = annotations.filter { !existingIDs.contains($0.poi.id) }
        if !toAdd.isEmpty { map.addAnnotations(toAdd) }

        
        if !context.coordinator.hasSetInitialRegion, !map.annotations.isEmpty {
               context.coordinator.hasSetInitialRegion = true

               let poiAnnos = map.annotations.compactMap { $0 as? POIAnnotation }
               if poiAnnos.count == 1, let only = poiAnnos.first {
                   let region = MKCoordinateRegion(
                       center: only.coordinate,
                       latitudinalMeters: defaultRegionMeters,
                       longitudinalMeters: defaultRegionMeters
                   )
                   map.setRegion(region, animated: false)
               } else {
                   map.showAnnotations(poiAnnos, animated: false)
                   let insets = UIEdgeInsets(top: 80, left: 40, bottom: 160, right: 40)
                   map.setVisibleMapRect(map.visibleMapRect, edgePadding: insets, animated: false)
               }
           }
    }

    final class Coordinator: NSObject, MKMapViewDelegate {
        var hasSetInitialRegion = false
        let parent: MapViewRepresentable
        
        init(_ parent: MapViewRepresentable) { self.parent = parent }
        
        

        func mapView(_ mapView: MKMapView, didSelect view: MKAnnotationView) {
            guard let anno = view.annotation as? POIAnnotation else { return }
            parent.onSelect(anno)
        }

        func mapView(_ mapView: MKMapView,
                     viewFor annotation: MKAnnotation) -> MKAnnotationView? {
            // 1) Кластеры — свой вид с числом
            if let cluster = annotation as? MKClusterAnnotation {
                let v = mapView.dequeueReusableAnnotationView(withIdentifier: "cluster",
                                                              for: annotation) as! MKMarkerAnnotationView
                v.displayPriority = .required
                v.markerTintColor = .systemBlue
                v.glyphText       = "\(cluster.memberAnnotations.count)"
                v.titleVisibility = .hidden
                v.subtitleVisibility = .hidden
                v.canShowCallout  = false
                return v
            }

            // 2) Обычные POI — маркер с пином и включённой кластеризацией
            guard annotation is POIAnnotation else { return nil }
            let v = mapView.dequeueReusableAnnotationView(withIdentifier: "marker",
                                                          for: annotation) as! MKMarkerAnnotationView
            v.displayPriority      = .defaultHigh
            v.clusteringIdentifier = "poi"
            v.markerTintColor      = .systemBlue
            v.glyphImage           = UIImage(systemName: "mappin")
            v.canShowCallout       = false
            return v
            
        }
    }
}
//
//  POIMapView.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/7/25.
//



import SwiftUI
import MapKit

public struct POIMapView: View {
    @StateObject private var vm: AnyPOIMapViewModel
    @EnvironmentObject private var router: MapRouter
    private let defaultRegionMeters: CLLocationDistance
    
    public init(viewModel: AnyPOIMapViewModel,
                defaultRegionMeters: CLLocationDistance) {
        _vm = StateObject(wrappedValue: viewModel)
        self.defaultRegionMeters = defaultRegionMeters
    }
    
    public var body: some View {
        MapViewRepresentable(
            annotations: vm.annotations,
            defaultRegionMeters: defaultRegionMeters,
            onSelect: { annotation in
                vm.select(annotation: annotation)
            }
        )
        .ignoresSafeArea()
        .onAppear { vm.fetch() }
        .sheet(item: Binding(
            get: {
                vm.selectedPOI
            },
            set: { newValue in
                vm.selectedPOI = newValue
            }
        )) { poi in
            POISnippetView(
                poi: poi,
                onDetails: {
                    vm.selectedPOI = nil
                    DispatchQueue.main.async {
                        router.goDetail(poi)
                    }
                },
                onRoute: {
                    let coord = CLLocationCoordinate2D(latitude: poi.latitude, longitude: poi.longitude)
                    let item = MKMapItem(placemark: MKPlacemark(coordinate: coord))
                    item.name = poi.name
                    item.openInMaps(launchOptions: nil)
                }
            )
            .presentationDetents([.height(200), .medium])
        }
        
    }
}
//
//  MapContainer.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/17/25.
//


import SwiftUI
import Combine
import Swinject
import MapKit

struct MapContainer: View {
    // ---------- State ----------
    @State private var navPath = NavigationPath()
    @State private var lastPushedPOIId: Int?
    @State private var isNavigating = false
    
    @StateObject private var router: MapRouter
    @StateObject private var vm: AnyPOIMapViewModel
    
    private let defaultRegionMeters: CLLocationDistance
    private let makeDetail: (POI) -> AnyView
    
    init(vm: AnyPOIMapViewModel, router: MapRouter, defaultRegionMeters: CLLocationDistance,makeDetail: @escaping (POI) -> AnyView) {
        _vm = StateObject(wrappedValue: vm)
        _router = StateObject(wrappedValue: router)
        self.defaultRegionMeters = defaultRegionMeters
        self.makeDetail = makeDetail
    }
    
    // ---------- UI ----------
    var body: some View {
        NavigationStack(path: $navPath) {
            POIMapView(viewModel: vm, defaultRegionMeters: defaultRegionMeters)
                .navigationDestination(for: MapRoute.self) { route in
                    switch route {
                    case .detail(let poi):
                        let r = DIContainer.shared.resolver
                        r.resolve(POIDetailCoordinator.self, argument: poi)?
                            .rootView()
                        makeDetail(poi)
                    }
                }
        }
        // -------- Router → NavigationPath --------
        .onReceive(router.routes) { command in
            switch command {
            case .detail(let poi):
                // анти-дубль: не пушим тот же POI в один "тик" и подряд
                guard !isNavigating, lastPushedPOIId != poi.id else { return }
                
                isNavigating = true
                navPath.append(MapRoute.detail(poi))
                lastPushedPOIId = poi.id
                
                // сбросим флажок сразу в следующий runloop-тик
                DispatchQueue.main.async { isNavigating = false }
            case .back:
                if !navPath.isEmpty { navPath.removeLast() }
                
            case .reset:
                navPath.removeLast(navPath.count)
            }
        }
        .environmentObject(router)   // нужен внутри POIMapView
    }
}
//
//  POIListViewModel.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/20/25.
//



import Combine
import CoreLocation
import MapKit

public protocol POIListViewModelProtocol: AnyObject {
    // Inputs
    var filter: POICategoryFilter { get set }
    func fetchPOIs()
    func openInMaps(poi: POI)
    
    // Outputs
    var pois: [POI] { get }
    var isLoading: Bool { get }
    var errorMessage: String? { get }
}

public final class POIListViewModel: ObservableObject, POIListViewModelProtocol {
    // MARK: Inputs
    @Published public var filter: POICategoryFilter = .all
    
    // MARK: Internal state
    private var allPois: [POI] = []
    
    // MARK: Outputs
    @Published public private(set) var pois: [POI] = []
    @Published public private(set) var isLoading: Bool = false
    @Published public private(set) var errorMessage: String? = nil
    
    private let repository: POIServiceProtocol
    private var cancellables = Set<AnyCancellable>()
    
    public init(repository: POIServiceProtocol) {
        self.repository = repository
        
        // Локальная фильтрация при смене filter
        $filter
            .dropFirst()
            .receive(on: DispatchQueue.main)
            .sink { [weak self] newFilter in
                self?.applyFilter(using: newFilter)
            }
            .store(in: &cancellables)
    }
    
    public func fetchPOIs() {
        if pois.isEmpty { isLoading = true }
        errorMessage = nil
        
        repository.fetchPOIs()
            .receive(on: DispatchQueue.main)
            .sink { [weak self] completion in
                guard let self = self else { return }
                self.isLoading = false
                if case let .failure(err) = completion {
                    self.errorMessage = err.localizedDescription
                }
            } receiveValue: { [weak self] list in
                guard let self = self else { return }
                self.allPois = list
                self.applyFilter()
            }
            .store(in: &cancellables)
    }
    
    private func applyFilter(using filter: POICategoryFilter? = nil) {
        let effective = filter ?? self.filter
        pois = (effective == .all)
        ? allPois
        : allPois.filter { $0.category == effective.rawValue }
    }
    
    public func openInMaps(poi: POI) {
        let coord = CLLocationCoordinate2D(latitude: poi.latitude,
                                           longitude: poi.longitude)
        let item = MKMapItem(placemark: MKPlacemark(coordinate: coord))
        item.name = poi.name
        item.openInMaps(launchOptions: nil)
    }
}
//
//  AnyPOIListViewModel.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/1/25.
//

import Foundation
import Combine

public final class AnyPOIListViewModel: ObservableObject {
    @Published public var filter: POICategoryFilter = .all
    @Published public var pois: [POI] = []
    @Published public var isLoading: Bool = false
    @Published public var errorMessage: String? = nil

    private let wrapped: POIListViewModelProtocol
    private var cancellables = Set<AnyCancellable>()

    public init(_ wrapped: POIListViewModelProtocol) {
        self.wrapped = wrapped
        self.filter = wrapped.filter

        // 1. Пробрасываем filter из wrapper в wrapped
        $filter
            .dropFirst()
            .sink { [weak self] newFilter in
                guard let self else { return }
                if self.wrapped.filter != newFilter {
                    self.wrapped.filter = newFilter
                }
            }
            .store(in: &cancellables)

        // 2. Пробрасываем filter из wrapped наружу (если вдруг он меняется)
        if let vm = wrapped as? POIListViewModel {
            vm.$filter
                .receive(on: DispatchQueue.main)
                .sink { [weak self] newFilter in
                    guard let self else { return }
                    if self.filter != newFilter {
                        self.filter = newFilter
                    }
                }
                .store(in: &cancellables)

            vm.$pois
                .receive(on: DispatchQueue.main)
                .assign(to: &$pois)
            vm.$isLoading
                .receive(on: DispatchQueue.main)
                .assign(to: &$isLoading)
            vm.$errorMessage
                .receive(on: DispatchQueue.main)
                .assign(to: &$errorMessage)
        }
    }

    public func fetchPOIs() { wrapped.fetchPOIs() }
    public func openInMaps(poi: POI) { wrapped.openInMaps(poi: poi) }
}
//
//  POIListRoute.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/11/25.
//


import SwiftUI
import Combine

enum POIListRoute: Hashable {
    case detail(POI)
}

enum POIListNavigationCommand {
    case detail(POI)
    case back
    case reset
}

@MainActor
final class POIListRouter: ObservableObject {
    let routes = PassthroughSubject<POIListNavigationCommand, Never>()
    fileprivate var cancellables = Set<AnyCancellable>()
    
    func goDetail(_ poi: POI){
        routes.send(.detail(poi))
    }
    func goBack(){
        routes.send(.back)
    }
    func reset(){
        routes.send(.reset)
    }
}
//
//  POIListRoute.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/10/25.
//


import SwiftUI

@MainActor
final class POIListCoordinator {
    private let viewModel: AnyPOIListViewModel
    private let router: POIListRouter
    private let makeDetail: (POI) -> AnyView
    
    init(viewModel: AnyPOIListViewModel, router: POIListRouter) {
        self.viewModel = viewModel
        self.router = router
        let resolver = DIContainer.shared.resolver
        self.makeDetail = { poi in
            guard let coord = resolver.resolve(POIDetailCoordinator.self, argument: poi) else {
                return AnyView(EmptyView())
            }
            return AnyView(coord.rootView())
        }
    }
    
    @ViewBuilder
    func rootView() -> some View {
        POIListContainer(vm: viewModel, router: router, makeDetail: makeDetail)
    }
}
//
//  POIImageView.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/2/25.
//

import SwiftUI

public struct POIImageView: View {
    let imagePath: String?

    public init(imagePath: String?) {
        self.imagePath = imagePath
    }

    public var body: some View {
        VStack {
            if let imagePath,
               let imageName = imagePath.split(separator: "/").last {
                let components = imageName.split(separator: ".")
                if components.count == 2 {
                    let name = String(components[0])
                    let ext = String(components[1])
                    if let url = Bundle.main.url(forResource: name, withExtension: ext),
                       let uiImage = UIImage(contentsOfFile: url.path) {
                        Image(uiImage: uiImage)
                            .resizable()
                            .scaledToFit()
                    } else {
                        Text("❌ \(name).\(ext)")
                            .foregroundColor(.red)
                        Text("Path: \(imagePath)")
                            .font(.caption)
                    }
                } else {
                    Text("❌ Invalid path: \(imagePath)")
                }
            } else {
                Text("No image")
            }
        }
    }
}
//
//  POIListContainer.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 9/11/25.
//


import SwiftUI
import Combine


struct POIListContainer: View {
    @State private var path = NavigationPath()
    @StateObject private var vm: AnyPOIListViewModel
    @StateObject private var router: POIListRouter
    private let makeDetail: (POI) -> AnyView
    
    init(vm: AnyPOIListViewModel, router: POIListRouter, makeDetail: @escaping (POI) -> AnyView) {
        _vm = StateObject(wrappedValue: vm)
        _router = StateObject(wrappedValue: router)
        self.makeDetail = makeDetail
    }

    var body: some View {
        NavigationStack(path: $path) {
            POIListView(viewModel: vm)
                .navigationDestination(for: POIListRoute.self) { route in
                    switch route {
                    case .detail(let poi):
                        DIContainer.shared.resolver
                            .resolve(POIDetailCoordinator.self, argument: poi)!
                            .rootView()
                        makeDetail(poi)
                    }
                }
        }
        .onReceive(router.routes) { cmd in
            switch cmd {
            case .detail(let poi): path.append(POIListRoute.detail(poi))
            case .back: if !path.isEmpty { path.removeLast() }
            case .reset: if !path.isEmpty { path.removeLast(path.count) }
            }
        }
        .environmentObject(router)
    }
}
//
//  POIListView.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/1/25.
//


import SwiftUI

public struct POIListView: View {
    @ObservedObject var viewModel: AnyPOIListViewModel
    @EnvironmentObject var router: POIListRouter
    
    public init(viewModel: AnyPOIListViewModel) {
        self.viewModel = viewModel
    }
    
    public var body: some View {
        ZStack {
            content
            if viewModel.isLoading {
                // Полноэкранный индикатор, когда пусто
                if viewModel.pois.isEmpty {
                    ProgressView().scaleEffect(1.2)
                } else {
                    // Компактный индикатор поверх уже показанного списка
                    VStack { Spacer() }
                        .overlay(
                            ProgressView()
                                .padding(12)
                                .background(.ultraThinMaterial)
                                .clipShape(RoundedRectangle(cornerRadius: 12))
                                .padding(.bottom, 24),
                            alignment: .bottom
                        )
                }
            }
        }
        .navigationTitle("Places")
        .onAppear { viewModel.fetchPOIs() }
    }
    
    @ViewBuilder
    private var content: some View {
        if let err = viewModel.errorMessage {
            VStack(spacing: 16) {
                Text("Error: \(err)").multilineTextAlignment(.center)
                Button("Retry") { viewModel.fetchPOIs() }
            }
            .padding()
        } else {
            VStack {
                Picker("Category", selection: $viewModel.filter) {
                    ForEach(POICategoryFilter.allCases) { Text($0.rawValue).tag($0) }
                }
                .pickerStyle(.segmented)
                .padding(.vertical)
                
                List(viewModel.pois) { poi in
                    Button { router.goDetail(poi) } label: {
                        HStack {
                            POIImageView(imagePath: poi.imageURL?.path)
                                .frame(width: 48, height: 48)
                                .clipShape(RoundedRectangle(cornerRadius: 8))
                                .padding(.trailing, 4)
                            VStack(alignment: .leading) {
                                Text(poi.name).font(.headline)
                                if let c = poi.category {
                                    Text(c).font(.subheadline).foregroundColor(.secondary)
                                }
                            }
                        }
                        .padding(.vertical, 4)
                    }
                }
                .listStyle(.plain)
            }
        }
    }
}
//
//  AnyOnboardingViewModel.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/26/25.
//

import Combine

/// Универсальный Any-ViewModel для Onboarding, скрывает конкретный тип
public final class AnyOnboardingViewModel: OnboardingViewModelProtocol {
    // MARK: — ObservableObject conformance
    public let objectWillChange = ObservableObjectPublisher()
    private var cancellables = Set<AnyCancellable>()
    
    // MARK: — Outputs
    @Published public private(set) var pages: [OnboardingPage]
    @Published public private(set) var currentPage: Int
    @Published public private(set) var hasCompletedOnboarding: Bool
    
    
    // MARK: — Wrapped instance
    private let wrapped: any OnboardingViewModelProtocol
    
    /// Инициализируем тип-стирающую «обёртку»
    public init(_ wrapped: any OnboardingViewModelProtocol) {
        self.wrapped = wrapped
        // копируем начальные значения
        self.pages               = wrapped.pages
        self.currentPage         = wrapped.currentPage
        self.hasCompletedOnboarding = wrapped.hasCompletedOnboarding
        
        // подписываемся на objectWillChange wrapped-VM,
        // чтобы передавать события субъективного обновления и синхронизировать свойства
        wrapped.objectWillChange
            .sink { [weak self] _ in
                guard let self = self else { return }
                self.pages               = self.wrapped.pages
                self.currentPage         = self.wrapped.currentPage
                self.hasCompletedOnboarding = self.wrapped.hasCompletedOnboarding
                self.objectWillChange.send()
            }
            .store(in: &cancellables)
    }
    
    // MARK: — Inputs: просто делегируем вызовы
    public func next() {
        wrapped.next()
    }
    public func previous() {
        wrapped.previous()
    }
    public func skip() {
        wrapped.skip()
    }
}
//
//  OnboardingViewModel.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/26/25.
//


import Combine
import Foundation

public protocol OnboardingViewModelProtocol: ObservableObject {
    /// Чтобы View могла подписаться на любые изменения
    var objectWillChange: ObservableObjectPublisher { get }
    
    // MARK: — Outputs
    var pages: [OnboardingPage] { get }
    var currentPage: Int { get }
    var hasCompletedOnboarding: Bool { get }
    
    // MARK: — Inputs
    func next()
    func previous()
    func skip()
}

public final class OnboardingViewModel: OnboardingViewModelProtocol {
    // MARK: — ObservableObject conformance
    public let objectWillChange = ObservableObjectPublisher()
    
    // MARK: — Outputs
    @Published public private(set) var currentPage: Int = 0
    @Published public private(set) var hasCompletedOnboarding: Bool
    
    public let pages: [OnboardingPage]
    private var cancellables = Set<AnyCancellable>()
    
    public init() {
        // Страницы онбординга
        self.pages = [
            OnboardingPage(
                id: 0,
                imageName: "onb1",
                title: "Welcome to TravelBuddy",
                description: "Discover new places and plan your journeys with ease."
            ),
            OnboardingPage(
                id: 1,
                imageName: "onb2",
                title: "Track Your Route",
                description: "Use our interactive map to mark and save your favorite spots."
            ),
            OnboardingPage(
                id: 2,
                imageName: "onb3",
                title: "Stay Notified",
                description: "Get reminders about upcoming trips and special offers."
            )
        ]
        self.hasCompletedOnboarding = UserDefaults.standard.hasCompletedOnboarding
    }
    
    // MARK: — Inputs
    
    public func next() {
        guard currentPage < pages.count - 1 else {
            skip()
            return
        }
        currentPage += 1
        objectWillChange.send()                 // <-- уведомляем SwiftUI заранее
    }
    
    public func previous() {
        guard currentPage > 0 else { return }
        currentPage -= 1
        objectWillChange.send()
    }
    
    public func skip() {
        hasCompletedOnboarding = true
        UserDefaults.standard.hasCompletedOnboarding = true
        objectWillChange.send()
    }
}
//
//  OnboardingPage.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/26/25.
//


import Foundation

public struct OnboardingPage: Identifiable {
  public let id: Int
  public let imageName: String
  public let title: String
  public let description: String

  public init(
    id: Int,
    imageName: String,
    title: String,
    description: String
  ) {
    self.id = id
    self.imageName = imageName
    self.title = title
    self.description = description
  }
}
//
//  OnboardingView.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/26/25.
//

import SwiftUI

public struct OnboardingView<VM: OnboardingViewModelProtocol>: View {
    @ObservedObject private var vm: VM
    @Namespace private var imageNamespace
    
    public init(vm: VM) {
        self.vm = vm
    }
    
    public var body: some View {
      ZStack {
        Color(DesignTokens.colorBackground)
          .ignoresSafeArea()

        VStack(spacing: DesignTokens.spacingMedium) {
          Spacer()

          // картинка
            ForEach(vm.pages, id: \.id) { page in
                if page.id == vm.currentPage {
                    Image(page.imageName)
                        .resizable()
                        .scaledToFit()
                        .frame(maxHeight: 300.scale)
                        .padding(.horizontal, DesignTokens.spacingMedium)
                        .transition(
                            .asymmetric(
                                insertion: .scale.combined(with: .opacity),
                                removal: .scale.combined(with: .opacity)
                            )
                        )
                }
            }

          Text(vm.pages[vm.currentPage].title)
            .font(.headline)
            .multilineTextAlignment(.center)
            .padding(.horizontal, DesignTokens.spacingMedium)

          Text(vm.pages[vm.currentPage].description)
            .font(.body)
            .multilineTextAlignment(.center)
            .padding(.horizontal, DesignTokens.spacingMedium)

          Spacer()

          HStack(spacing: 5.scale) {
            ForEach(vm.pages.indices, id: \.self) { idx in
              Circle()
                .fill(idx == vm.currentPage
                      ? Color(DesignTokens.colorPrimary)
                      : Color.gray.opacity(0.4))
                .frame(width: 5.scale, height: 5.scale)
                .scaleEffect(idx == vm.currentPage ? 1.2 : 1.0)
            }
          }

          HStack {
            if vm.currentPage > 0 {
              Button("Back") {
                withAnimation(.easeInOut) {
                  vm.previous()
                }
              }
              .font(.body)
              .padding(.trailing, DesignTokens.spacingMedium)
            }

            Spacer()

            Button(vm.currentPage == vm.pages.count - 1 ? "Get Started" : "Next") {
              withAnimation(.easeInOut) {
                vm.next()
                
              }
            }
            .font(.body)
          }
          .padding(.horizontal, DesignTokens.spacingMedium)
        }
        .foregroundColor(.primary)
      }
      // анимация на уровень выше
      .animation(.spring(response: 0.5, dampingFraction: 0.7), value: vm.currentPage)
    }

}
