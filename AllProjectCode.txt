//
//  TravelBuddyUITestsLaunchTests.swift
//  TravelBuddyUITests
//
//  Created by Niiaz Khasanov on 10/1/25.
//

import XCTest

final class TravelBuddyUITestsLaunchTests: XCTestCase {

    override class var runsForEachTargetApplicationUIConfiguration: Bool {
        true
    }

    override func setUpWithError() throws {
        continueAfterFailure = false
    }

    @MainActor
    func testLaunch() throws {
        let app = XCUIApplication()
        app.launch()

        // Insert steps here to perform after app launch but before taking a screenshot,
        // such as logging into a test account or navigating somewhere in the app

        let attachment = XCTAttachment(screenshot: app.screenshot())
        attachment.name = "Launch Screen"
        attachment.lifetime = .keepAlways
        add(attachment)
    }
}
//
//  SnapshotHelper.swift
//  Example
//
//  Created by Felix Krause on 10/8/15.
//

// -----------------------------------------------------
// IMPORTANT: When modifying this file, make sure to
//            increment the version number at the very
//            bottom of the file to notify users about
//            the new SnapshotHelper.swift
// -----------------------------------------------------

import Foundation
import XCTest

@MainActor
func setupSnapshot(_ app: XCUIApplication, waitForAnimations: Bool = true) {
    Snapshot.setupSnapshot(app, waitForAnimations: waitForAnimations)
}

@MainActor
func snapshot(_ name: String, waitForLoadingIndicator: Bool) {
    if waitForLoadingIndicator {
        Snapshot.snapshot(name)
    } else {
        Snapshot.snapshot(name, timeWaitingForIdle: 0)
    }
}

/// - Parameters:
///   - name: The name of the snapshot
///   - timeout: Amount of seconds to wait until the network loading indicator disappears. Pass `0` if you don't want to wait.
@MainActor
func snapshot(_ name: String, timeWaitingForIdle timeout: TimeInterval = 20) {
    Snapshot.snapshot(name, timeWaitingForIdle: timeout)
}

enum SnapshotError: Error, CustomDebugStringConvertible {
    case cannotFindSimulatorHomeDirectory
    case cannotRunOnPhysicalDevice

    var debugDescription: String {
        switch self {
        case .cannotFindSimulatorHomeDirectory:
            return "Couldn't find simulator home location. Please, check SIMULATOR_HOST_HOME env variable."
        case .cannotRunOnPhysicalDevice:
            return "Can't use Snapshot on a physical device."
        }
    }
}

@objcMembers
@MainActor
open class Snapshot: NSObject {
    static var app: XCUIApplication?
    static var waitForAnimations = true
    static var cacheDirectory: URL?
    static var screenshotsDirectory: URL? {
        return cacheDirectory?.appendingPathComponent("screenshots", isDirectory: true)
    }
    static var deviceLanguage = ""
    static var currentLocale = ""

    open class func setupSnapshot(_ app: XCUIApplication, waitForAnimations: Bool = true) {

        Snapshot.app = app
        Snapshot.waitForAnimations = waitForAnimations

        do {
            let cacheDir = try getCacheDirectory()
            Snapshot.cacheDirectory = cacheDir
            setLanguage(app)
            setLocale(app)
            setLaunchArguments(app)
        } catch let error {
            NSLog(error.localizedDescription)
        }
    }

    class func setLanguage(_ app: XCUIApplication) {
        guard let cacheDirectory = self.cacheDirectory else {
            NSLog("CacheDirectory is not set - probably running on a physical device?")
            return
        }

        let path = cacheDirectory.appendingPathComponent("language.txt")

        do {
            let trimCharacterSet = CharacterSet.whitespacesAndNewlines
            deviceLanguage = try String(contentsOf: path, encoding: .utf8).trimmingCharacters(in: trimCharacterSet)
            app.launchArguments += ["-AppleLanguages", "(\(deviceLanguage))"]
        } catch {
            NSLog("Couldn't detect/set language...")
        }
    }

    class func setLocale(_ app: XCUIApplication) {
        guard let cacheDirectory = self.cacheDirectory else {
            NSLog("CacheDirectory is not set - probably running on a physical device?")
            return
        }

        let path = cacheDirectory.appendingPathComponent("locale.txt")

        do {
            let trimCharacterSet = CharacterSet.whitespacesAndNewlines
            currentLocale = try String(contentsOf: path, encoding: .utf8).trimmingCharacters(in: trimCharacterSet)
        } catch {
            NSLog("Couldn't detect/set locale...")
        }

        if currentLocale.isEmpty && !deviceLanguage.isEmpty {
            currentLocale = Locale(identifier: deviceLanguage).identifier
        }

        if !currentLocale.isEmpty {
            app.launchArguments += ["-AppleLocale", "\"\(currentLocale)\""]
        }
    }

    class func setLaunchArguments(_ app: XCUIApplication) {
        guard let cacheDirectory = self.cacheDirectory else {
            NSLog("CacheDirectory is not set - probably running on a physical device?")
            return
        }

        let path = cacheDirectory.appendingPathComponent("snapshot-launch_arguments.txt")
        app.launchArguments += ["-FASTLANE_SNAPSHOT", "YES", "-ui_testing"]

        do {
            let launchArguments = try String(contentsOf: path, encoding: String.Encoding.utf8)
            let regex = try NSRegularExpression(pattern: "(\\\".+?\\\"|\\S+)", options: [])
            let matches = regex.matches(in: launchArguments, options: [], range: NSRange(location: 0, length: launchArguments.count))
            let results = matches.map { result -> String in
                (launchArguments as NSString).substring(with: result.range)
            }
            app.launchArguments += results
        } catch {
            NSLog("Couldn't detect/set launch_arguments...")
        }
    }

    open class func snapshot(_ name: String, timeWaitingForIdle timeout: TimeInterval = 20) {
        if timeout > 0 {
            waitForLoadingIndicatorToDisappear(within: timeout)
        }

        NSLog("snapshot: \(name)") // more information about this, check out https://docs.fastlane.tools/actions/snapshot/#how-does-it-work

        if Snapshot.waitForAnimations {
            sleep(1) // Waiting for the animation to be finished (kind of)
        }

        #if os(OSX)
            guard let app = self.app else {
                NSLog("XCUIApplication is not set. Please call setupSnapshot(app) before snapshot().")
                return
            }

            app.typeKey(XCUIKeyboardKeySecondaryFn, modifierFlags: [])
        #else

            guard self.app != nil else {
                NSLog("XCUIApplication is not set. Please call setupSnapshot(app) before snapshot().")
                return
            }

            let screenshot = XCUIScreen.main.screenshot()
            #if os(iOS) && !targetEnvironment(macCatalyst)
            let image = XCUIDevice.shared.orientation.isLandscape ?  fixLandscapeOrientation(image: screenshot.image) : screenshot.image
            #else
            let image = screenshot.image
            #endif

            guard var simulator = ProcessInfo().environment["SIMULATOR_DEVICE_NAME"], let screenshotsDir = screenshotsDirectory else { return }

            do {
                // The simulator name contains "Clone X of " inside the screenshot file when running parallelized UI Tests on concurrent devices
                let regex = try NSRegularExpression(pattern: "Clone [0-9]+ of ")
                let range = NSRange(location: 0, length: simulator.count)
                simulator = regex.stringByReplacingMatches(in: simulator, range: range, withTemplate: "")

                let path = screenshotsDir.appendingPathComponent("\(simulator)-\(name).png")
                #if swift(<5.0)
                    try UIImagePNGRepresentation(image)?.write(to: path, options: .atomic)
                #else
                    try image.pngData()?.write(to: path, options: .atomic)
                #endif
            } catch let error {
                NSLog("Problem writing screenshot: \(name) to \(screenshotsDir)/\(simulator)-\(name).png")
                NSLog(error.localizedDescription)
            }
        #endif
    }

    class func fixLandscapeOrientation(image: UIImage) -> UIImage {
        #if os(watchOS)
            return image
        #else
            if #available(iOS 10.0, *) {
                let format = UIGraphicsImageRendererFormat()
                format.scale = image.scale
                let renderer = UIGraphicsImageRenderer(size: image.size, format: format)
                return renderer.image { context in
                    image.draw(in: CGRect(x: 0, y: 0, width: image.size.width, height: image.size.height))
                }
            } else {
                return image
            }
        #endif
    }

    class func waitForLoadingIndicatorToDisappear(within timeout: TimeInterval) {
        #if os(tvOS)
            return
        #endif

        guard let app = self.app else {
            NSLog("XCUIApplication is not set. Please call setupSnapshot(app) before snapshot().")
            return
        }

        let networkLoadingIndicator = app.otherElements.deviceStatusBars.networkLoadingIndicators.element
        let networkLoadingIndicatorDisappeared = XCTNSPredicateExpectation(predicate: NSPredicate(format: "exists == false"), object: networkLoadingIndicator)
        _ = XCTWaiter.wait(for: [networkLoadingIndicatorDisappeared], timeout: timeout)
    }

    class func getCacheDirectory() throws -> URL {
        let cachePath = "Library/Caches/tools.fastlane"
        // on OSX config is stored in /Users/<username>/Library
        // and on iOS/tvOS/WatchOS it's in simulator's home dir
        #if os(OSX)
            let homeDir = URL(fileURLWithPath: NSHomeDirectory())
            return homeDir.appendingPathComponent(cachePath)
        #elseif arch(i386) || arch(x86_64) || arch(arm64)
            guard let simulatorHostHome = ProcessInfo().environment["SIMULATOR_HOST_HOME"] else {
                throw SnapshotError.cannotFindSimulatorHomeDirectory
            }
            let homeDir = URL(fileURLWithPath: simulatorHostHome)
            return homeDir.appendingPathComponent(cachePath)
        #else
            throw SnapshotError.cannotRunOnPhysicalDevice
        #endif
    }
}

private extension XCUIElementAttributes {
    var isNetworkLoadingIndicator: Bool {
        if hasAllowListedIdentifier { return false }

        let hasOldLoadingIndicatorSize = frame.size == CGSize(width: 10, height: 20)
        let hasNewLoadingIndicatorSize = frame.size.width.isBetween(46, and: 47) && frame.size.height.isBetween(2, and: 3)

        return hasOldLoadingIndicatorSize || hasNewLoadingIndicatorSize
    }

    var hasAllowListedIdentifier: Bool {
        let allowListedIdentifiers = ["GeofenceLocationTrackingOn", "StandardLocationTrackingOn"]

        return allowListedIdentifiers.contains(identifier)
    }

    func isStatusBar(_ deviceWidth: CGFloat) -> Bool {
        if elementType == .statusBar { return true }
        guard frame.origin == .zero else { return false }

        let oldStatusBarSize = CGSize(width: deviceWidth, height: 20)
        let newStatusBarSize = CGSize(width: deviceWidth, height: 44)

        return [oldStatusBarSize, newStatusBarSize].contains(frame.size)
    }
}

private extension XCUIElementQuery {
    var networkLoadingIndicators: XCUIElementQuery {
        let isNetworkLoadingIndicator = NSPredicate { (evaluatedObject, _) in
            guard let element = evaluatedObject as? XCUIElementAttributes else { return false }

            return element.isNetworkLoadingIndicator
        }

        return self.containing(isNetworkLoadingIndicator)
    }

    @MainActor
    var deviceStatusBars: XCUIElementQuery {
        guard let app = Snapshot.app else {
            fatalError("XCUIApplication is not set. Please call setupSnapshot(app) before snapshot().")
        }

        let deviceWidth = app.windows.firstMatch.frame.width

        let isStatusBar = NSPredicate { (evaluatedObject, _) in
            guard let element = evaluatedObject as? XCUIElementAttributes else { return false }

            return element.isStatusBar(deviceWidth)
        }

        return self.containing(isStatusBar)
    }
}

private extension CGFloat {
    func isBetween(_ numberA: CGFloat, and numberB: CGFloat) -> Bool {
        return numberA...numberB ~= self
    }
}

// Please don't remove the lines below
// They are used to detect outdated configuration files
// SnapshotHelperVersion [1.30]
//
//  TravelBuddySnapshotUITests.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 10/1/25.
//


import XCTest

@MainActor
final class TravelBuddySnapshotUITests: XCTestCase {
    private var app: XCUIApplication!

    override func setUp() {
        super.setUp()
        continueAfterFailure = false
        app = XCUIApplication()

        // init fastlane-snapshot (–∏–∑ SnapshotHelper.swift)
        setupSnapshot(app)

        // fastlane snapshot —Å–∞–º –≤—ã—Å—Ç–∞–≤–∏—Ç AppleLanguages/AppleLocale
        app.launch()
    }

    func testSnapshot_Onboarding_List_Map_Settings() {
        // --- Onboarding ---
        snapshot("01-Onboarding-Page1")

        tapIfExists(app.buttons["Next"])
        tapIfExists(app.buttons["Get Started"])
        if app.buttons["Get Started"].exists { app.buttons["Get Started"].tap() }

        // --- Main Tabs ---
        XCTAssertTrue(
            app.navigationBars["Places"].exists ||
            app.navigationBars["–ú–µ—Å—Ç–∞"].exists
        )
        snapshot("02-Places-List")

        // –û—Ç–∫—Ä—ã—Ç—å –ø–µ—Ä–≤—É—é —è—á–µ–π–∫—É –∏ —Å–¥–µ–ª–∞—Ç—å —Å–∫—Ä–∏–Ω –¥–µ—Ç–∞–ª–∏ (–µ—Å–ª–∏ –µ—Å—Ç—å)
        if app.tables.firstMatch.cells.count > 0 {
            app.tables.firstMatch.cells.element(boundBy: 0).tap()
            snapshot("03-POI-Detail")
            let close = app.buttons["xmark.circle.fill"]
            if close.exists { close.tap() }
        }

        // --- Map ---
        tapTab(labelEn: "Map", labelRu: "–ö–∞—Ä—Ç–∞")
        sleep(1)
        snapshot("04-Map")

        // --- Settings ---
        tapTab(labelEn: "Settings", labelRu: "–ù–∞—Å—Ç—Ä–æ–π–∫–∏")
        snapshot("05-Settings")
    }

    // MARK: - Helpers

    private func tapIfExists(_ el: XCUIElement, timeout: TimeInterval = 0.5) {
        if el.waitForExistence(timeout: timeout) { el.tap() }
    }

    private func tapTab(labelEn: String, labelRu: String) {
        let tabBar = app.tabBars.firstMatch
        if tabBar.buttons[labelEn].exists {
            tabBar.buttons[labelEn].tap()
        } else if tabBar.buttons[labelRu].exists {
            tabBar.buttons[labelRu].tap()
        } else if tabBar.buttons.count > 0 {
            tabBar.buttons.element(boundBy: 0).tap()
        }
    }
}
//
//  TravelBuddyUITests.swift
//  TravelBuddyUITests
//
//  Created by Niiaz Khasanov on 10/1/25.
//

import XCTest

final class TravelBuddyUITests: XCTestCase {

    override func setUpWithError() throws {
        // Put setup code here. This method is called before the invocation of each test method in the class.

        // In UI tests it is usually best to stop immediately when a failure occurs.
        continueAfterFailure = false

        // In UI tests it‚Äôs important to set the initial state - such as interface orientation - required for your tests before they run. The setUp method is a good place to do this.
    }

    override func tearDownWithError() throws {
        // Put teardown code here. This method is called after the invocation of each test method in the class.
    }

    @MainActor
    func testExample() throws {
        // UI tests must launch the application that they test.
        let app = XCUIApplication()
        app.launch()

        // Use XCTAssert and related functions to verify your tests produce the correct results.
    }

    @MainActor
    func testLaunchPerformance() throws {
        // This measures how long it takes to launch your application.
        measure(metrics: [XCTApplicationLaunchMetric()]) {
            XCUIApplication().launch()
        }
    }
}
excluded:
  - Carthage
  - Pods
  - build
  - fastlane
  - TravelBuddy/Generated
  - TravelBuddy/**/Generated

disabled_rules:
  - force_cast
  - force_unwrapping
  - implicit_optional_initialization
  - vertical_whitespace
  - trailing_newline
  - vertical_parameter_alignment
  - opening_brace
  - operator_usage_whitespace
  - comma
  - colon
  - comment_spacing
  - identifier_name
  - line_length
  - trailing_whitespace

included:
  - TravelBuddy
  
opt_in_rules:
  - empty_count
  - closure_end_indentation
  - redundant_nil_coalescing
  - operator_usage_whitespace
  - force_unwrapping

reporter: "xcode"

cyclomatic_complexity:
  warning: 15
  error: 20

type_body_length:
  warning: 400
  error: 600

file_length:
  warning: 800
  error: 1200

function_body_length:
  warning: 80
  error: 120

//
//  DesignTokens.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/20/25.
//

import UIKit

public enum DesignTokens {
    // MARK: Colors
    public static let colorPrimary = UIColor(hex: "#0055FF")!
    public static let colorBackground = UIColor { trait in
        trait.userInterfaceStyle == .dark
        ? UIColor(hex: "#000000")!
        : UIColor(hex: "#FFFFFF")!
    }
    
    // MARK: Typography
    public static let fontHeadline = UIFont.systemFont(ofSize: 24.scale, weight: .bold)
    public static let fontBody     = UIFont.systemFont(ofSize: 16.scale, weight: .regular)
    
    // MARK: Spacing
    public static let spacingSmall  = 8.scale
    public static let spacingMedium = 16.scale
    
}
//
//  L10n.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 9/28/25.
//


import Foundation

enum L10n {

    // MARK: - Common
    static var alertOk: String { NSLocalizedString("alert.ok", comment: "OK button") }
    static var alertErrorTitle: String { NSLocalizedString("alert.error.title", comment: "Generic error alert title") }

    // MARK: - Tabs / Titles
    static var tabPlaces: String { NSLocalizedString("tab.places", comment: "Tab title: Places") }
    static var tabMap: String { NSLocalizedString("tab.map", comment: "Tab title: Map") }
    static var tabSettings: String { NSLocalizedString("tab.settings", comment: "Tab title: Settings") }

    static var navSettingsTitle: String { NSLocalizedString("nav.settings.title", comment: "Navigation title for Settings") }
    static var navPlacesTitle: String { NSLocalizedString("nav.places.title", comment: "Navigation title for Places") }
    
    // MARK: - Settings
    static var settingsDarkMode: String {
        NSLocalizedString("settings.darkmode", comment: "Dark mode toggle in Settings")
    }

    static var settingsNotifications: String {
        NSLocalizedString("settings.notifications", comment: "Notifications toggle in Settings")
    }

    static var settingsPremiumUnlock: String {
        NSLocalizedString("settings.premium.unlock", comment: "Unlock Premium button")
    }

    static var settingsPremiumUnlocked: String {
        NSLocalizedString("settings.premium.unlocked", comment: "Premium already unlocked label")
    }


    // MARK: - List screen
    static var listCategoryTitle: String { NSLocalizedString("list.category.title", comment: "Category picker title") }
    static var listRetry: String { NSLocalizedString("list.retry", comment: "Retry button") }
    static func listPlacesCount(_ n: Int) -> String {
        let fmt = NSLocalizedString("list.places.count", comment: "Pluralized count of places")
        return String.localizedStringWithFormat(fmt, n)
    }

    // Category display names
    static var catAll: String { NSLocalizedString("category.all", comment: "All category") }
    static var catMonument: String { NSLocalizedString("category.monument", comment: "Monument category") }
    static var catMuseum: String { NSLocalizedString("category.museum", comment: "Museum category") }
    static var catCafe: String { NSLocalizedString("category.cafe", comment: "Cafe category") }

    // MARK: - POI Detail
    static var detailLoadingAddress: String { NSLocalizedString("detail.loading.address", comment: "Loading address‚Ä¶") }
    static var detailShare: String { NSLocalizedString("detail.share", comment: "Share button") }
    static var detailOpenInMaps: String { NSLocalizedString("detail.openinmaps", comment: "Open in Maps button") }

    // MARK: - Onboarding
    static var onbNext: String { NSLocalizedString("onb.next", comment: "Next button") }
    static var onbBack: String { NSLocalizedString("onb.back", comment: "Back button") }
    static var onbGetStarted: String { NSLocalizedString("onb.getstarted", comment: "Get Started button") }

    static var onbPage1Title: String { NSLocalizedString("onb.p1.title", comment: "Onboarding page 1 title") }
    static var onbPage1Desc: String { NSLocalizedString("onb.p1.desc", comment: "Onboarding page 1 description") }
    static var onbPage2Title: String { NSLocalizedString("onb.p2.title", comment: "Onboarding page 2 title") }
    static var onbPage2Desc: String { NSLocalizedString("onb.p2.desc", comment: "Onboarding page 2 description") }
    static var onbPage3Title: String { NSLocalizedString("onb.p3.title", comment: "Onboarding page 3 title") }
    static var onbPage3Desc: String { NSLocalizedString("onb.p3.desc", comment: "Onboarding page 3 description") }

    // MARK: - DeepLink parsing errors
    static var deeplinkUnknownHost: String { NSLocalizedString("deeplink.unknown_host", comment: "Unsupported link host") }
    static var deeplinkInvalidCoords: String { NSLocalizedString("deeplink.invalid_coords", comment: "Invalid coordinates in deeplink") }
    static var deeplinkUnsupportedScheme: String { NSLocalizedString("deeplink.unsupported_scheme", comment: "Unsupported url scheme") }

    // MARK: - DeepLink business errors
    static func deeplinkPoiNotFound(_ id: Int) -> String {
        let format = NSLocalizedString("deeplink.poi.not_found", comment: "POI not found by ID")
        return String(format: format, locale: Locale.current, arguments: [id])
    }

    // MARK: - Misc UI
    static var imageNoImage: String { NSLocalizedString("image.noimage", comment: "No image placeholder") }
    static func imageInvalidPath(_ path: String) -> String {
        let format = NSLocalizedString("image.invalid.path", comment: "Invalid image path message")
        return String(format: format, path)
    }
}
//
//  AppConfig.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 9/19/25.
//


import Foundation
import CoreLocation

public struct AppConfig {
    // MARK: ‚Äî Network
    public let apiBaseURL: URL
    public let httpTimeout: TimeInterval

    // MARK: ‚Äî Repository / Cache
    public let poiCacheTTL: TimeInterval

    // MARK: ‚Äî IAP
    public struct IAP {
        public let premiumProductID: String
    }
    public let iap: IAP

    // MARK: ‚Äî Local data / mocks
    public let localPOIJSONName: String

    // MARK: ‚Äî Map defaults
    public let defaultRegionMeters: CLLocationDistance

    // MARK: ‚Äî Feature Flags
    public struct Flags {
        public let enableDebugLogs: Bool
        public let useAlamofireClient: Bool  // –Ω–∞ –±—É–¥—É—â–µ–µ
        public let showBLETab: Bool          // –Ω–∞ –±—É–¥—É—â–µ–µ
        public let enableAudioGuide: Bool    // –Ω–∞ –±—É–¥—É—â–µ–µ
    }
    public let flags: Flags
}


public extension AppConfig {
    static func makeDefault() -> AppConfig {
        #if DEBUG
        return AppConfig(
            apiBaseURL: URL(string: "https://api.example.com")!,
            httpTimeout: 0.15 ,
            poiCacheTTL: 300,
            iap: .init(premiumProductID: "com.travelbuddy.premium"),
            localPOIJSONName: "mock_pois_local",
            defaultRegionMeters: 4000,
            flags: .init(
                enableDebugLogs: true,
                useAlamofireClient: false,
                showBLETab: false,
                enableAudioGuide: false
            )
        )
        #else
        return AppConfig(
            apiBaseURL: URL(string: "https://api.example.com")!,
            httpTimeout: 15,
            poiCacheTTL: 300,
            iap: .init(premiumProductID: "com.travelbuddy.premium"),
            localPOIJSONName: "mock_pois_local",
            defaultRegionMeters: 4000,
            flags: .init(
                enableDebugLogs: false,
                useAlamofireClient: false,
                showBLETab: false,
                enableAudioGuide: false
            )
        )
        #endif
    }
}
//
//  AppRouter.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 9/12/25.
//


import Combine

@MainActor
public final class AppRouter: ObservableObject {
    public let events = PassthroughSubject<AppRoute, Never>()
    public init() {}
    public func send(_ route: AppRoute) { events.send(route) }
}
//
//  AppRoute.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 9/12/25.
//


import Foundation

public enum AppRoute: Equatable {
    case openPOIDetail(POI)
    case openMapWithPOI(POI.ID)
    case openSettings
}
//
//  Scalable.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/26/25.
//

import UIKit

protocol Scalable {
    var scale: Self { get }
}

extension CGFloat: Scalable {
    var scale: CGFloat {
        let designScreenWidth: CGFloat = 375
        let currentScreenWidth = UIScreen.main.bounds.size.width
        return self * currentScreenWidth / designScreenWidth
    }
   
}

extension Int {
    var scale: CGFloat {
        CGFloat(self).scale
    }
}

extension Double {
    var scale: CGFloat {
        CGFloat(self).scale
    }
}

extension CGPoint: Scalable {
    var scale: CGPoint {
        CGPoint(x: x.scale, y: y.scale)
    }
}

extension CGSize: Scalable {
    var scale: CGSize {
        CGSize(width: width.scale, height: height.scale)
    }
}

extension CGRect: Scalable {
    var scale: CGRect {
        CGRect(origin: origin.scale, size: size.scale)
    }
}

extension UIFont {
    var scale: UIFont {
        UIFont(name: fontName, size: pointSize.scale) ?? UIFont.systemFont(ofSize: pointSize.scale)
    }
}

extension UIEdgeInsets: Scalable {
    var scale: UIEdgeInsets {
        UIEdgeInsets(top: top.scale, left: left.scale, bottom: bottom.scale, right: right.scale)
    }
}
//
//  ScreenSize.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/26/25.
//


import UIKit

enum ScreenSize {
    static let bounds: CGRect = (UIScreen.main.bounds)
    static let width: CGFloat = (bounds.width)
    static let height: CGFloat = (bounds.height)
    static let maxLength: CGFloat = (max(width, height))
    static let minLength: CGFloat = (min(width, height))
    
    static let isIphone = UIDevice.current.userInterfaceIdiom == .phone
    static let isRetina = (UIScreen.main.scale >= 2.0)
    static let isIphoneXFamily = (isIphone && maxLength / minLength > 2.0)
}
//
//  UIColor+Hex.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/20/25.
//

import UIKit

public extension UIColor {
  convenience init?(hex: String) {
    var hexSanitized = hex.trimmingCharacters(in: .whitespacesAndNewlines)
    hexSanitized = hexSanitized.replacingOccurrences(of: "#", with: "")
    var rgb: UInt64 = 0
    guard Scanner(string: hexSanitized).scanHexInt64(&rgb) else { return nil }
    let r = CGFloat((rgb & 0xFF0000) >> 16) / 255
    let g = CGFloat((rgb & 0x00FF00) >> 8) / 255
    let b = CGFloat(rgb & 0x0000FF) / 255
    self.init(red: r, green: g, blue: b, alpha: 1)
  }
}
//
//  Publisher+Extensions.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/20/25.
//

import Combine

public extension Publisher {
  func logError(_ tag: String) -> AnyPublisher<Output, Failure> {
    handleEvents(receiveCompletion: { completion in
      if case let .failure(error) = completion {
          Swift.print("[\(tag)] Error:", error)
      }
    })
    .eraseToAnyPublisher()
  }
}
//
//  UserDefaults+AppStorage.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/26/25.
//

import Foundation

extension UserDefaults {
  // MARK: ‚Äî –ö–ª—é—á–∏
  private enum Keys {
    static let hasCompletedOnboarding = "hasCompletedOnboarding"
    // –≤ –±—É–¥—É—â–µ–º —Å—é–¥–∞ –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–ª—è—Ç—å –¥—Ä—É–≥–∏–µ –∫–ª—é—á–∏
  }

  // MARK: ‚Äî –°–≤–æ–π—Å—Ç–≤–∞
  var hasCompletedOnboarding: Bool {
    get { bool(forKey: Keys.hasCompletedOnboarding) }
    set { set(newValue, forKey: Keys.hasCompletedOnboarding) }
  }
}
//
//  UITabBarController+Alert.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 9/28/25.
//


import UIKit

extension UITabBarController {
    func presentAlert(title: String, message: String, okTitle: String) {
        let alert = UIAlertController(title: title, message: message, preferredStyle: .alert)
        alert.addAction(UIAlertAction(title: okTitle, style: .default))
        (selectedViewController ?? presentedViewController ?? self).present(alert, animated: true)
    }
}
//
//  AppCoordinator.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/26/25.
//

import UIKit
import SwiftUI
import Combine
import Swinject
import CoreLocation

protocol Coordinator {
    func start()
}

@MainActor
final class AppCoordinator: Coordinator {
    // MARK: - Dependencies
    private let window: UIWindow
    private let container: DIContainer

    // IAP
    private let iapObserver: IAPObserver
    private let iapService: IAPServiceProtocol

    // MARK: - UI State
    private let tabBar = UITabBarController()
    private var cancellables = Set<AnyCancellable>()

    // –ù–∞–≤–∏–≥–∞—Ü–∏—è/—Ä–æ—É—Ç–µ—Ä—ã, –¥–æ—Å—Ç—É–ø–Ω—ã–µ –∏–∑ —Ä–∞–∑–Ω—ã—Ö –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤
    private var appRouter: AppRouter!
    private var mapRouter: MapRouter!      // –æ–±—â–∏–π —ç–∫–∑–µ–º–ø–ª—è—Ä –¥–ª—è –≤–∫–ª–∞–¥–∫–∏ "Map"

    // MARK: - Init
    init(window: UIWindow, container: DIContainer? = nil) {
        self.window = window
        self.container = container ?? DIContainer.shared

        guard
            let observer = self.container.resolver.resolve(IAPObserver.self),
            let iapSvc   = self.container.resolver.resolve(IAPServiceProtocol.self)
        else {
            preconditionFailure("Swinject: IAPObserver/IAPServiceProtocol –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã")
        }
        self.iapObserver = observer
        self.iapService  = iapSvc
    }

    // MARK: - Start
    func start() {
        window.makeKeyAndVisible()

        if UserDefaults.standard.hasCompletedOnboarding {
            showMainInterface()
        } else {
            showOnboarding()
        }
    }

    // MARK: - Onboarding
    private func showOnboarding() {
        guard let onboardingVM = container.resolver.resolve(AnyOnboardingViewModel.self) else {
            preconditionFailure("Swinject: AnyOnboardingViewModel –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω")
        }

        let onboardingHost = UIHostingController(rootView: OnboardingView(vm: onboardingVM))
        window.rootViewController = onboardingHost

        onboardingVM.$hasCompletedOnboarding
            .filter { $0 }
            .first()
            .receive(on: DispatchQueue.main)
            .sink { [weak self] _ in
                self?.showMainInterface()
            }
            .store(in: &cancellables)
    }

    // MARK: - Main UI
    private func showMainInterface() {
        // AppRouter ‚Äî –æ–¥–∏–Ω –Ω–∞ –≤—Å–µ —Ç–∞–±—ã
        guard let appRouter = container.resolver.resolve(AppRouter.self) else {
            preconditionFailure("Swinject: AppRouter –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω")
        }
        self.appRouter = appRouter

        // --- Places tab
        guard
            let poiListVM     = container.resolver.resolve(AnyPOIListViewModel.self),
            let poiListRouter = container.resolver.resolve(POIListRouter.self)
        else {
            preconditionFailure("Swinject: –Ω–µ—Ç —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ AnyPOIListViewModel –∏–ª–∏ POIListRouter")
        }
        let poiListCoord = POIListCoordinator(viewModel: poiListVM, router: poiListRouter)
        let placesVC = UIHostingController(
            rootView: poiListCoord.rootView().environmentObject(appRouter)
        )
        placesVC.tabBarItem = UITabBarItem(title: L10n.tabPlaces, image: UIImage(systemName: "map"), tag: 0)

        // --- Map tab
        guard
            let mapVM     = container.resolver.resolve(AnyPOIMapViewModel.self),
            let mapRouter = container.resolver.resolve(MapRouter.self)
        else {
            preconditionFailure("Swinject: –Ω–µ—Ç —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ AnyPOIMapViewModel –∏–ª–∏ MapRouter")
        }
        self.mapRouter = mapRouter // <‚Äî —Å–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Å—ã–ª–∫—É –¥–ª—è –¥–∏–ø–ª–∏–Ω–∫–æ–≤/—Ä–æ—É—Ç–∏–Ω–≥–∞
        let mapCoord = MapCoordinator(vm: mapVM, router: mapRouter)
        let mapVC = UIHostingController(
            rootView: mapCoord.rootView().environmentObject(appRouter)
        )
        mapVC.tabBarItem    = UITabBarItem(title: L10n.tabMap, image: UIImage(systemName: "map.fill"), tag: 1)
        
        // --- Settings tab
        guard let settingsVM = container.resolver.resolve(AnySettingsViewModel.self) else {
            preconditionFailure("Swinject: AnySettingsViewModel –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω")
        }
        let settingsVC = UIHostingController(
            rootView: SettingsView(vm: settingsVM).environmentObject(appRouter)
        )
        settingsVC.tabBarItem = UITabBarItem(title: L10n.tabSettings, image: UIImage(systemName: "gearshape"), tag: 2)

        // --- Assemble
        tabBar.viewControllers = [placesVC, mapVC, settingsVC]
        window.rootViewController = tabBar

        // --- Bindings
        bindAppRouter(appRouter)
        bindDeepLinks()

        // --- IAP
        iapObserver.start()
        iapService.readCurrentPremiumEntitlement()
            .receive(on: DispatchQueue.main)
            .sink { _ in }
            .store(in: &cancellables)
    }

    // MARK: - Bind AppRouter
    private func bindAppRouter(_ appRouter: AppRouter) {
        appRouter.events
            .receive(on: DispatchQueue.main)
            .sink { [weak self] route in
                self?.handle(route)
            }
            .store(in: &cancellables)
    }

    // MARK: - Bind Deep Links
    private func bindDeepLinks() {
        guard let deeplinkService = container.resolver.resolve(DeepLinkHandling.self) else { return }

        // –£—Å–ø–µ—Ö ‚Äî –º–∞—Ä—à—Ä—É—Ç–∏–∑–∏—Ä—É–µ–º –≤ –∫–∞—Ä—Ç—É/—Ç–∞–±—ã
        deeplinkService
            .events
            .receive(on: DispatchQueue.main)
            .sink { [weak self] link in
                self?.handleDeepLink(link)
            }
            .store(in: &cancellables)

        // –û—à–∏–±–∫–∏ –ø–∞—Ä—Å–∏–Ω–≥–∞/–≤–∞–ª–∏–¥–∞—Ü–∏–∏ –¥–∏–ø–ª–∏–Ω–∫–æ–≤ ‚Äî –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–π –∞–ª–µ—Ä—Ç
        deeplinkService
            .errors
            .receive(on: DispatchQueue.main)
            .sink { [weak self] err in
                self?.presentDeepLinkError(err)
            }
            .store(in: &cancellables)
    }

    // MARK: - Show errors (GLOBAL)
    /// –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –æ—à–∏–±–∫–∏ –¥–∏–ø–ª–∏–Ω–∫–æ–≤ (scheme/host/coords) ‚Äî –≤–Ω–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ Map-—Å—Ü–µ–Ω—ã.
    private func presentDeepLinkError(_ error: DeepLinkError) {
        let message: String
        switch error {
        case .unsupportedScheme:
            message = L10n.deeplinkUnsupportedScheme
        case .unknownHost:
            message = L10n.deeplinkUnknownHost
        case .invalidCoordinates:
            message = L10n.deeplinkInvalidCoords
        }

        tabBar.presentAlert(
            title: L10n.alertErrorTitle,
            message: message,
            okTitle: L10n.alertOk
        )
    }

    // MARK: - Handle AppRoute (–∏–∑ —Å–ø–∏—Å–∫–æ–≤/–Ω–∞—Å—Ç—Ä–æ–µ–∫ –∏ —Ç.–ø.)
    private func handle(_ route: AppRoute) {
        switch route {
        case .openPOIDetail:
            tabBar.selectedIndex = 0

        case .openMapWithPOI(let id):
            tabBar.selectedIndex = 1
            mapRouter?.focusPOI(id)

        case .openSettings:
            tabBar.selectedIndex = 2
        }
    }

    // MARK: - Handle Deep Link (SUCCESS)
    private func handleDeepLink(_ deeplink: DeepLink) {
        switch deeplink {
        case .mapCenter(let coord):
            tabBar.selectedIndex = 1
            mapRouter?.center(on: coord)

        case .poi(let id):
            tabBar.selectedIndex = 1
            // –µ—Å–ª–∏ —Ç–∞–∫–æ–≥–æ POI –≤ –∏—Ç–æ–≥–µ –Ω–µ—Ç ‚Äî MapContainer —Å–∞–º –ø–æ–∫–∞–∂–µ—Ç –ª–æ–∫–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π –∞–ª–µ—Ä—Ç
            // —á–µ—Ä–µ–∑ router.showError(.poiNotFound(id)) –ø–æ —Ç–∞–π–º–∞—É—Ç—É
            mapRouter?.focusPOI(id)
        }
    }
}
//
//  DIContainer.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/23/25.
//


// DIContainer.swift
import Foundation
import Swinject
import UIKit
import SwiftUI

@MainActor
public final class DIContainer {
    public static let shared = DIContainer()
    let container = Container()

    private init() {
        // 0) AppConfig ‚Äî
        let config = AppConfig.makeDefault()
        container.register(AppConfig.self) { _ in config }
            .inObjectScope(.container)
      
        // DeepLink
        container.register(DeepLinkHandling.self) { _ in
            DeepLinkService()
        }.inObjectScope(.container)

        // 1) Core
        container.register(HTTPClientProtocol.self) { r in
            HTTPClient(timeout: r.resolve(AppConfig.self)!.httpTimeout)
        }.inObjectScope(.container)

        // 2) Services
        container.register(AnalyticsServiceProtocol.self) { _ in AnalyticsService() }
            .inObjectScope(.container)

        container.register(IAPServiceProtocol.self) { r in
            IAPService(config: r.resolve(AppConfig.self)!)
        }.inObjectScope(.container)

        container.register(IAPObserver.self) { r in
            IAPObserver(iap: r.resolve(IAPServiceProtocol.self)!)
        }.inObjectScope(.container)

        container.register(NotificationServiceProtocol.self) { _ in NotificationService() }
            .inObjectScope(.container)

        // 3) POI data stack
        container.register(RemotePOIService.self) { r in
            RemotePOIService(
                httpClient: r.resolve(HTTPClientProtocol.self)!,
                config: r.resolve(AppConfig.self)!
            )
        } // scope –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é .graph ‚Äî –Ω–æ—Ä–º

        container.register(LocalPOIService.self) { r in
            LocalPOIService(config: r.resolve(AppConfig.self)!)
        }

        container.register(POICacheProtocol.self) { _ in RealmPOICache() }

        container.register(POIServiceProtocol.self) { r in
            POIRepository(
                remote: r.resolve(RemotePOIService.self)!,
                local:  r.resolve(LocalPOIService.self)!,
                cache:  r.resolve(POICacheProtocol.self)!,
                ttl:    r.resolve(AppConfig.self)!.poiCacheTTL
            )
        }.inObjectScope(.container)

        // 4) Onboarding
        container.register((any OnboardingViewModelProtocol).self) { _ in OnboardingViewModel() }
        container.register(AnyOnboardingViewModel.self) { r in
            AnyOnboardingViewModel(r.resolve((any OnboardingViewModelProtocol).self)!)
        }.inObjectScope(.graph)

        // 5) POIList scene
        container.register((any POIListViewModelProtocol).self) { r in
            POIListViewModel(repository: r.resolve(POIServiceProtocol.self)!)
        }.inObjectScope(.graph)

        container.register(AnyPOIListViewModel.self) { r in
            AnyPOIListViewModel(r.resolve((any POIListViewModelProtocol).self)!)
        }.inObjectScope(.graph)

        container.register(POIListRouter.self) { _ in POIListRouter() }
            .inObjectScope(.graph)

        // 6) Map scene
        container.register((any POIMapViewModelProtocol).self) { r in
            POIMapViewModel(
                service: r.resolve(POIServiceProtocol.self)!,
                factory: DefaultAnnotationFactory()
            )
        }.inObjectScope(.graph)

        container.register(AnyPOIMapViewModel.self) { r in
            AnyPOIMapViewModel(r.resolve((any POIMapViewModelProtocol).self)!)
        }.inObjectScope(.graph)

        container.register(MapRouter.self) { _ in MapRouter() }
            .inObjectScope(.graph)

        // 7) Settings scene
        container.register((any SettingsViewModelProtocol).self) { r in
            SettingsViewModel(
                iapService:   r.resolve(IAPServiceProtocol.self)!,
                analytics:    r.resolve(AnalyticsServiceProtocol.self)!,
                notification: r.resolve(NotificationServiceProtocol.self)!
            )
        }.inObjectScope(.graph)

        container.register(AnySettingsViewModel.self) { r in
            AnySettingsViewModel(r.resolve((any SettingsViewModelProtocol).self)!)
        }.inObjectScope(.graph)

        // 8) AppRouter –∏ Detail
        container.register(AppRouter.self) { _ in AppRouter() }
            .inObjectScope(.container)

        container.register(POIDetailViewModel.self) { _, poi in
            POIDetailViewModel(poi: poi)
        }
        container.register(POIDetailCoordinator.self) { r, poi in
            POIDetailCoordinator(poi: poi, resolver: r)
        }.inObjectScope(.graph)
    }

    public var resolver: Resolver { container.synchronize() }
}
//
//  AppDelegate.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/19/25.
//

import UIKit

@main
class AppDelegate: UIResponder, UIApplicationDelegate {



    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        // Override point for customization after application launch.
        return true
    }

    // MARK: UISceneSession Lifecycle

    func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -> UISceneConfiguration {
        // Called when a new scene session is being created.
        // Use this method to select a configuration to create the new scene with.
        return UISceneConfiguration(name: "Default Configuration", sessionRole: connectingSceneSession.role)
    }

    func application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set<UISceneSession>) {
        // Called when the user discards a scene session.
        // If any sessions were discarded while the application was not running, this will be called shortly after application:didFinishLaunchingWithOptions.
        // Use this method to release any resources that were specific to the discarded scenes, as they will not return.
    }


}

//
//  DeepLinkParser.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/17/25.
//


import CoreLocation

public enum DeepLink {
    case mapCenter(CLLocationCoordinate2D)
    case poi(id: Int)
}

public enum DeepLinkError: Error {
    case unsupportedScheme
    case unknownHost
    case invalidCoordinates
}



public struct DeepLinkParser {
    public init() {}

    public func parse(url: URL) -> Result<DeepLink, DeepLinkError> {
        let scheme = url.scheme?.lowercased()
        if scheme == "travelbuddy" {
            return parseCustomScheme(url)
        }
        return .failure(.unsupportedScheme)
    }

    private func parseCustomScheme(_ url: URL) -> Result<DeepLink, DeepLinkError> {
        switch url.host?.lowercased() {
        case "map":
            return parseMap(url)
        case "poi":
            guard let id = Int(url.lastPathComponent) else {
                return .failure(.unknownHost)
            }
            return .success(.poi(id: id))
        default:
            return .failure(.unknownHost)
        }
    }

    private func parseMap(_ url: URL) -> Result<DeepLink, DeepLinkError> {
        guard
            let comps = URLComponents(url: url, resolvingAgainstBaseURL: false),
            let latStr = comps.queryItems?.first(where: { $0.name == "lat" })?.value,
            let lonStr = comps.queryItems?.first(where: { $0.name == "lon" })?.value,
            let lat = Double(latStr),
            let lon = Double(lonStr)
        else {
            return .failure(.invalidCoordinates)
        }
        return .success(.mapCenter(.init(latitude: lat, longitude: lon)))
    }
}
//
//  DeepLinkService.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/7/25.
//

import Foundation
import CoreLocation
import Combine

public protocol DeepLinkHandling {
    func handle(url: URL)
    var events: AnyPublisher<DeepLink, Never> { get }
    var errors: AnyPublisher<DeepLinkError, Never> { get }
}

public final class DeepLinkService: DeepLinkHandling {
    private let parser = DeepLinkParser()

    private let successSubject = CurrentValueSubject<DeepLink?, Never>(nil)
    private let errorSubject = PassthroughSubject<DeepLinkError, Never>()

    public init() {}

    public func handle(url: URL) {
        switch parser.parse(url: url) {
        case .success(let dl):
            successSubject.value = dl
        case .failure(let err):
            errorSubject.send(err)
        }
    }

    public var events: AnyPublisher<DeepLink, Never> {
        successSubject.compactMap { $0 }.eraseToAnyPublisher()
    }

    public var errors: AnyPublisher<DeepLinkError, Never> {
        errorSubject.eraseToAnyPublisher()
    }
}
//
//  SceneDelegate.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/19/25.
//

import UIKit

class SceneDelegate: UIResponder, UIWindowSceneDelegate {
    var window: UIWindow?
    var coordinator: AppCoordinator?

    func scene(_ scene: UIScene,
               willConnectTo session: UISceneSession,
               options connectionOptions: UIScene.ConnectionOptions) {
        guard let ws = (scene as? UIWindowScene) else { return }
        let window = UIWindow(windowScene: ws)
        self.window = window

        coordinator = AppCoordinator(window: window)
        coordinator?.start()

        // üîó –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –¥–∏–ø–ª–∏–Ω–∫ –ø—Ä–∏ —Ö–æ–ª–æ–¥–Ω–æ–º —Å—Ç–∞—Ä—Ç–µ
        if let url = connectionOptions.urlContexts.first?.url {
            DIContainer.shared.resolver
                .resolve(DeepLinkHandling.self)?
                .handle(url: url)
        }
    }

    // üîó –¥–∏–ø–ª–∏–Ω–∫–∏ –≤ —É–∂–µ –∑–∞–ø—É—â–µ–Ω–Ω–æ–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
    func scene(_ scene: UIScene, openURLContexts URLContexts: Set<UIOpenURLContext>) {
        guard let url = URLContexts.first?.url else { return }
        DIContainer.shared.resolver
            .resolve(DeepLinkHandling.self)?
            .handle(url: url)
    }
}

# üîó Deep Links (—Ç–µ—Å—Ç–æ–≤—ã–π –Ω–∞–±–æ—Ä)

### –¶–µ–Ω—Ç—Ä –∫–∞—Ä—Ç—ã
- `travelbuddy://map?lat=48.8584&lon=2.2945` ‚Äî —Ü–µ–Ω—Ç—Ä –Ω–∞ Eiffel Tower  
- `travelbuddy://map?lat=48.8606&lon=2.3376` ‚Äî —Ü–µ–Ω—Ç—Ä –Ω–∞ Louvre Museum  
- `travelbuddy://map?lat=48.8867&lon=2.3431` ‚Äî —Ü–µ–Ω—Ç—Ä –Ω–∞ Sacr√©-C≈ìur Basilica  

### –û—Ç–∫—Ä—ã—Ç—å POI
- `travelbuddy://poi/1` ‚Äî Eiffel Tower (Monument)  
- `travelbuddy://poi/2` ‚Äî Louvre Museum (Museum)  
- `travelbuddy://poi/3` ‚Äî Cafe de Flore (Cafe)  
- `travelbuddy://poi/18` ‚Äî Caf√© Marly (–ø–æ—Å–ª–µ–¥–Ω–∏–π —ç–ª–µ–º–µ–Ω—Ç —Å–ø–∏—Å–∫–∞)  

### –ù–µ–≤–∞–ª–∏–¥–Ω—ã–µ
- `travelbuddy://poi/999` ‚Äî –Ω–µ—Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π POI  
- `travelbuddy://map?lat=abc&lon=123` ‚Äî –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã  
- `travelbuddy://unknown` ‚Äî –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ö–æ—Å—Ç  
//
//  HTTPClient.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/28/25.
//

// Infrastructure/Networking/HTTPClient.swift
import Foundation
import Combine

public final class HTTPClient: HTTPClientProtocol {
    private let timeout: TimeInterval
    private let decoder: JSONDecoder

    public init(timeout: TimeInterval = 15,
                decoder: JSONDecoder = .init()) {
        self.timeout = timeout
        self.decoder = decoder
    }

    public func send<T: Decodable>(_ requestIn: URLRequest) -> AnyPublisher<T, Error> {
        var request = requestIn
        // –µ—Å–ª–∏ —É –∑–∞–ø—Ä–æ—Å–∞ –Ω–µ –∑–∞–¥–∞–Ω —Ç–∞–π–º–∞—É—Ç ‚Äì –ø–æ–¥—Å—Ç–∞–≤–∏–º –¥–µ—Ñ–æ–ª—Ç –∏–∑ –∫–ª–∏–µ–Ω—Ç–∞
        if request.timeoutInterval == 0 {
            request.timeoutInterval = timeout
        }

        return URLSession.shared.dataTaskPublisher(for: request)
            .tryMap { output -> Data in
                // –º–∞–ø–ø–∏–º network-–æ—à–∏–±–∫–∏ –∏ —Å—Ç–∞—Ç—É—Å—ã
                if let http = output.response as? HTTPURLResponse,
                   !(200...299).contains(http.statusCode) {
                    throw URLError(.badServerResponse)
                }
                return output.data
            }
            .decode(type: T.self, decoder: decoder)
            .eraseToAnyPublisher()
    }
}
//
//  HTTPClientProtocol.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/20/25.
//


import Foundation
import Combine

public protocol HTTPClientProtocol {
  func send<T: Decodable>(_ request: URLRequest) -> AnyPublisher<T, Error>
}

//
//  POIRepository.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/1/25.
//


import Combine
import Foundation

public final class POIRepository: POIServiceProtocol {
    private let remote: POIServiceProtocol
    private let local: POIServiceProtocol
    private let cache: POICacheProtocol
    private let ttl: TimeInterval

    // in-flight –æ–±—â–∏–π publisher –¥–ª—è –¥–µ–¥—É–ø–ª–∏–∫–∞—Ü–∏–∏ –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
    private let stateQueue = DispatchQueue(label: "poi.repo.state")
    private var inFlight: AnyPublisher<[POI], Error>?

    // —Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —É—Å–ø–µ—à–Ω–æ–≥–æ remote save (–Ω–µ –º–µ–Ω—è–µ–º –ø—Ä–æ—Ç–æ–∫–æ–ª –∫—ç—à–∞)
    private let lastRefreshKey = "poi.cache.lastRefreshAt"

    public init(remote: POIServiceProtocol,
                 local: POIServiceProtocol,
                 cache: POICacheProtocol,
                 ttl: TimeInterval) {
         self.remote = remote
         self.local  = local
         self.cache  = cache
         self.ttl    = ttl
     }

    public func fetchPOIs() -> AnyPublisher<[POI], Error> {
        let cached = loadCacheAsync()

        // –µ—Å–ª–∏ –∫—ç—à —Å–≤–µ–∂–∏–π ‚Äî –æ—Ç–¥–∞—ë–º –µ–≥–æ –∏ –≤—ã—Ö–æ–¥–∏–º
        if isFresh() {
            return cached
        }

        // –∏–Ω–∞—á–µ: —Å—Ä–∞–∑—É –æ—Ç–¥–∞—ë–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –∫—ç—à–∞ (–µ—Å–ª–∏ –µ—Å—Ç—å) –∏ –∑–∞—Ç–µ–º ‚Äî –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–∑ —Å–µ—Ç–∏
        // (–µ—Å–ª–∏ in-flight —É–∂–µ –∏–¥—ë—Ç ‚Äî –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º)
        let refresh = remoteOnceShared()
            .catch { [weak self] _ -> AnyPublisher<[POI], Error> in
                guard let self else {
                    return Fail(error: URLError(.unknown)).eraseToAnyPublisher()
                }
                // fallback: –ª–æ–∫–∞–ª—å–Ω—ã–π JSON (–∏ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ –æ–±–Ω–æ–≤–∏–º –∫—ç—à)
                return self.local.fetchPOIs()
                    .handleEvents(receiveOutput: { [weak self] pois in
                        self?.saveToCache(pois)
                    })
                    .eraseToAnyPublisher()
            }

        // cacheThenRefresh: —Å–Ω–∞—á–∞–ª–∞ –∫—ç—à, –∑–∞—Ç–µ–º —Å–µ—Ç—å
        return cached
            .filter { !$0.isEmpty }
            .append(refresh)
            .eraseToAnyPublisher()
    }

    // MARK: - Helpers

    private func loadCacheAsync() -> AnyPublisher<[POI], Error> {
        Deferred {
            Future<[POI], Error> { [weak self] promise in
                guard let self else {
                    promise(.failure(URLError(.unknown))); return
                }
                DispatchQueue.global(qos: .userInitiated).async {
                    let pois = self.cache.load()
                    promise(.success(pois))
                }
            }
        }
        .eraseToAnyPublisher()
    }

    private func remoteOnceShared() -> AnyPublisher<[POI], Error> {
        // 1) –µ—Å–ª–∏ —É–∂–µ –µ—Å—Ç—å –æ–±—â–∏–π in-flight, –≤–µ—Ä–Ω—ë–º –µ–≥–æ
        if let shared = stateQueue.sync(execute: { inFlight }) {
            return shared
        }

        // 2) —Å–æ–∑–¥–∞—ë–º –Ω–æ–≤—ã–π, —Å–æ—Ö—Ä–∞–Ω—è–µ–º –≤ inFlight –∏ —à–∞—Ä–∏–º
        let publisher = remote.fetchPOIs()
            .handleEvents(receiveOutput: { [weak self] pois in
                self?.saveToCache(pois)
                self?.setLastRefresh(Date())
            }, receiveCompletion: { [weak self] _ in
                self?.stateQueue.async { self?.inFlight = nil }
            }, receiveCancel: { [weak self] in
                self?.stateQueue.async { self?.inFlight = nil }
            })
            .share()
            .eraseToAnyPublisher()

        stateQueue.async { [weak self] in self?.inFlight = publisher }
        return publisher
    }

    private func saveToCache(_ pois: [POI]) {
        // –∑–∞–ø–∏—Å—å —Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –≤–Ω—É—Ç—Ä–∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–π; –µ—Å–ª–∏ –±—É–¥–µ—Ç –¥–∏—Å–∫–æ–≤–∞—è ‚Äî –æ–Ω–∏ —É–∂–µ —É —Ç–µ–±—è –≤ autoreleasepool
        cache.save(pois)
    }

    // MARK: - TTL

    private func isFresh(now: Date = Date()) -> Bool {
        guard let last = getLastRefresh() else { return false }
        return now.timeIntervalSince(last) < ttl
    }

    private func getLastRefresh() -> Date? {
        let t = UserDefaults.standard.double(forKey: lastRefreshKey)
        return t > 0 ? Date(timeIntervalSince1970: t) : nil
    }

    private func setLastRefresh(_ date: Date) {
        UserDefaults.standard.set(date.timeIntervalSince1970, forKey: lastRefreshKey)
    }
}
//
//  RealmPOICache.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/30/25.
//

import Foundation
import RealmSwift

public final class RealmPOICache: POICacheProtocol {
    public func save(_ pois: [POI]) {
        autoreleasepool {
            do {
                let realm = try Realm()
                let objects = pois.map { RealmPOI(poi: $0) }
                try realm.write { realm.add(objects, update: .modified) }
            } catch { /* –ª–æ–≥ –ø—Ä–∏ –∂–µ–ª–∞–Ω–∏–∏ */ }
        }
    }

    public func load() -> [POI] {
        autoreleasepool {
            (try? Realm()).map { Array($0.objects(RealmPOI.self)).map { $0.toPOI() } } ?? []
        }
    }
}

public final class RealmPOI: Object {
    @objc dynamic var id = 0
    @objc dynamic var name = ""
    @objc dynamic var latitude = 0.0
    @objc dynamic var longitude = 0.0
    @objc dynamic var category: String? = nil
    @objc dynamic var descriptionText: String? = nil
    @objc dynamic var imageURLString: String? = nil

    public override static func primaryKey() -> String? { "id" }

    convenience init(poi: POI) {
        self.init()
        id = poi.id; name = poi.name
        latitude = poi.latitude; longitude = poi.longitude
        category = poi.category
        descriptionText = poi.description
        imageURLString = poi.imageURL?.absoluteString
    }

    func toPOI() -> POI {
        POI(
          id: id, name: name,
          latitude: latitude, longitude: longitude,
          category: category,
          description: descriptionText,
          imageURL: imageURLString.flatMap(URL.init)
        )
    }
}

//
//  RemotePOIService.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/28/25.
//

import Foundation
import Combine

public final class RemotePOIService: POIServiceProtocol {
    private let httpClient: HTTPClientProtocol
    private let baseURL: URL

    public init(httpClient: HTTPClientProtocol, config: AppConfig) {
        self.httpClient = httpClient
        self.baseURL = config.apiBaseURL
    }

    public func fetchPOIs() -> AnyPublisher<[POI], Error> {
        let url = baseURL.appendingPathComponent("pois")
        return httpClient.send(URLRequest(url: url))
    }
}
//
//  LocalPOIService.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/28/25.
//

import Foundation
import Combine

public final class LocalPOIService: POIServiceProtocol {
    private let jsonName: String
    
    public init(config: AppConfig) {
        self.jsonName = config.localPOIJSONName
    }
    
    
    public func fetchPOIs() -> AnyPublisher<[POI], Error> {
        Deferred {
            Future<[POI], Error> { promise in
                DispatchQueue.global(qos: .background).async {
                    do {
                        guard let url = Bundle.main.url(forResource: self.jsonName, withExtension: "json") else {
                            promise(.failure(URLError(.fileDoesNotExist)))
                            return
                        }
                        let data = try Data(contentsOf: url)
                        let pois = try JSONDecoder().decode([POI].self, from: data)
                        //Thread.sleep(forTimeInterval: 0)
                        promise(.success(pois))
                    } catch {
                        promise(.failure(error))
                    }
                }
            }
        }
        .eraseToAnyPublisher()
    }
}
//
//  NotificationServiceProtocol.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/28/25.
//


import UserNotifications
import Combine

public protocol NotificationServiceProtocol {
  func requestAuthorization() -> AnyPublisher<Bool, Never>
  func schedule(_ content: UNNotificationContent, at date: Date)
}
//
//  NotificationService.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/20/25.
//


import UserNotifications
import Combine


public final class NotificationService: NotificationServiceProtocol {
  public init() {}

  public func requestAuthorization() -> AnyPublisher<Bool, Never> {
    Future { promise in
      UNUserNotificationCenter.current()
        .requestAuthorization(options: [.alert, .sound]) { granted, _ in
          promise(.success(granted))
        }
    }
    .eraseToAnyPublisher()
  }

  public func schedule(_ content: UNNotificationContent, at date: Date) {
    let interval = max(1, date.timeIntervalSinceNow)
    let trigger = UNTimeIntervalNotificationTrigger(timeInterval: interval, repeats: false)
    let req = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)
    UNUserNotificationCenter.current().add(req)
  }
}
//
//  IAPObserver.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 9/17/25.
//


import StoreKit
import Combine

extension Notification.Name {
  static let iapEntitlementsChanged = Notification.Name("iapEntitlementsChanged")
}

public final class IAPObserver {
  private let iap: IAPServiceProtocol
  private var task: Task<Void, Never>?

  public init(iap: IAPServiceProtocol) { self.iap = iap }

  public func start() {
    guard task == nil else { return }
    task = Task.detached { [weak self] in
      await self?.observeTransactions()
    }
  }

  public func stop() { task?.cancel(); task = nil }
  deinit { stop() }

  private func observeTransactions() async {
    for await update in Transaction.updates {
      do {
        let tx: Transaction = try iap.verify(update)
        // –≤—ã–¥–∞—é –ø—Ä–∞–≤–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –Ω–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
        await tx.finish()
        // —Å–æ–æ–±—â–∏–º UI, —á—Ç–æ —ç–Ω—Ç–∏—Ç–ª–º–µ–Ω—Ç—ã –º–æ–≥–ª–∏ –∏–∑–º–µ–Ω–∏—Ç—å—Å—è
        NotificationCenter.default.post(name: .iapEntitlementsChanged, object: nil)
      } catch {
        // –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ: –ª–æ–≥/–º–µ—Ç—Ä–∏–∫–∏
      }
    }
  }
}
//
//  IAPServiceProtocol.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/28/25.
//



import StoreKit
import Combine


public protocol IAPServiceProtocol {
  func fetchProducts() -> AnyPublisher<[Product], Error>
  func purchase(_ product: Product) -> AnyPublisher<Transaction, Error>
  func verify<T>(_ result: VerificationResult<T>) throws -> T
  func readCurrentPremiumEntitlement() -> AnyPublisher<Bool, Never>
}
//
//  IAPService.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/20/25.
//


import StoreKit
import Combine

public final class IAPService: IAPServiceProtocol {
    private let productID: String
    public init(config: AppConfig) {
        self.productID = config.iap.premiumProductID
    }
    
    public func fetchProducts() -> AnyPublisher<[Product], Error> {
        Deferred {
            Future { promise in
                Task {
                    do {
                        let ids: Set<String> = [self.productID]
                        let products = try await Product.products(for: ids)
                        promise(.success(products))
                    } catch { promise(.failure(error)) }
                }
            }
        }
        .eraseToAnyPublisher()
    }
    
    public func purchase(_ product: Product) -> AnyPublisher<Transaction, Error> {
        Deferred {
            Future { promise in
                Task {
                    do {
                        let result = try await product.purchase()
                        switch result {
                        case .success(let verification):
                            let tx: Transaction = try self.verify(verification)
                            await tx.finish()
                            promise(.success(tx))
                        case .userCancelled:
                            let err = NSError(domain: "IAP", code: NSUserCancelledError,
                                              userInfo: [NSLocalizedDescriptionKey: "Purchase cancelled"])
                            promise(.failure(err))
                        case .pending:
                            let err = NSError(domain: "IAP", code: -1,
                                              userInfo: [NSLocalizedDescriptionKey: "Purchase pending"])
                            promise(.failure(err))
                        @unknown default:
                            let err = NSError(domain: "IAP", code: -2,
                                              userInfo: [NSLocalizedDescriptionKey: "Unknown purchase result"])
                            promise(.failure(err))
                        }
                    } catch { promise(.failure(error)) }
                }
            }
        }
        .eraseToAnyPublisher()
    }
    
    // MARK: - NEW
    public func verify<T>(_ result: VerificationResult<T>) throws -> T {
        switch result {
        case .verified(let safe): return safe
        case .unverified(_, let error): throw error
        }
    }
    
    public func readCurrentPremiumEntitlement() -> AnyPublisher<Bool, Never> {
        Deferred {
            Future<Bool, Never> { promise in
                Task {
                    var hasPremium = false
                    for await entitlement in Transaction.currentEntitlements {
                        if case .verified(let tx) = entitlement,
                           tx.productID == self.productID {
                            hasPremium = true
                            break
                        }
                    }
                    promise(.success(hasPremium))
                }
            }
        }
        .eraseToAnyPublisher()
    }
}
//
//  AnalyticsServiceProtocol.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/28/25.
//


import Foundation

public protocol AnalyticsServiceProtocol {
  func logEvent(name: String, parameters: [String: Any]?)
  func recordError(_ error: Error)
}
//
//  AnalyticsService.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/20/25.
//

import FirebaseAnalytics
import FirebaseCrashlytics


public final class AnalyticsService: AnalyticsServiceProtocol {
  public init() {}
  public func logEvent(name: String, parameters: [String: Any]?) {
    Analytics.logEvent(name, parameters: parameters)
  }
  public func recordError(_ error: Error) {
    Crashlytics.crashlytics().record(error: error)
  }
}
//
//  POICategoryFilter.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/1/25.
//


import Foundation

public enum POICategoryFilter: String, CaseIterable, Identifiable {
    case all = "All", monument = "Monument", museum = "Museum", cafe = "Cafe"
    public var id: String { rawValue }
}

public extension POICategoryFilter {
    var localizedTitle: String {
        switch self {
        case .all: return L10n.catAll
        case .monument: return L10n.catMonument
        case .museum: return L10n.catMuseum
        case .cafe: return L10n.catCafe
        }
    }
}
//
//  POI.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/20/25.
//

import Foundation

public struct POI: Identifiable, Decodable, Hashable {
    public let id: Int
    public let name: String
    public let latitude: Double
    public let longitude: Double
    public let category: String?
    public let description: String?
    public let imageURL: URL?
}
//
//  POIServiceProtocol.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/11/25.
//


import Foundation
import Combine

public protocol POIServiceProtocol {
  func fetchPOIs() -> AnyPublisher<[POI], Error>
}//
//  POICacheProtocol.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/28/25.
//


import Foundation

public protocol POICacheProtocol: AnyObject {
    func save(_ pois: [POI])
    func load() -> [POI]
}
//
//  SettingsView.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/23/25.
//

import SwiftUI

public struct SettingsView<VM: SettingsViewModelProtocol>: View {
    @ObservedObject private var vm: VM

    public init(vm: VM) { self.vm = vm }

    public var body: some View {
        NavigationView {
            Form {
                // Dark Mode
                Toggle(L10n.settingsDarkMode, isOn: Binding(
                    get:  { vm.isDarkMode },
                    set:  { vm.setDarkMode($0) }
                ))
                .accessibilityIdentifier("settings.darkmode.toggle")

                // Notifications
                Toggle(L10n.settingsNotifications, isOn: Binding(
                    get:  { vm.notificationsEnabled },
                    set:  { vm.setNotifications($0) }
                ))
                .accessibilityIdentifier("settings.notifications.toggle")

                // Premium
                Button(action: { vm.purchasePremium() }) {
                    Text(vm.premiumUnlocked
                         ? L10n.settingsPremiumUnlocked
                         : L10n.settingsPremiumUnlock)
                }
                .disabled(vm.premiumUnlocked)
                .accessibilityIdentifier("settings.premium.button")
            }
            .navigationTitle(L10n.navSettingsTitle)
            .alert(item: Binding(
                get: { vm.errorMessage.map { AlertError(message: $0) } },
                set: { _ in vm.clearError() }
            )) { alertError in
                Alert(
                    title: Text(L10n.alertErrorTitle),
                    message: Text(alertError.message),
                    dismissButton: .default(Text(L10n.alertOk))
                )
            }
        }
    }
}

private struct AlertError: Identifiable {
    let id = UUID()
    let message: String
}
//
//  SettingsViewModel.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/20/25.
//

import Combine
import StoreKit
import SwiftUI

public protocol SettingsViewModelProtocol: ObservableObject {
    var objectWillChange: ObservableObjectPublisher { get }
    
    var isDarkMode: Bool { get }
    var notificationsEnabled: Bool { get }
    var premiumUnlocked: Bool { get }
    var errorMessage: String? { get }
    
    func setDarkMode(_ isOn: Bool)
    func setNotifications(_ isOn: Bool)
    
    func purchasePremium()
    func clearError()
}


public final class SettingsViewModel: SettingsViewModelProtocol {
    public let objectWillChange = ObservableObjectPublisher()
    
    private enum Keys {
        static let darkMode = "settings.darkMode"
        static let notificationsEnabled = "settings.notificationsEnabled"
    }
    
    @Published public private(set) var isDarkMode = UserDefaults.standard.bool(forKey: Keys.darkMode)
    @Published public private(set) var notificationsEnabled = UserDefaults.standard.bool(forKey: Keys.notificationsEnabled)
    @Published public private(set) var premiumUnlocked = false
    @Published public private(set) var errorMessage: String?
    
    private let iapService: IAPServiceProtocol
    private let analytics: AnalyticsServiceProtocol
    private let notification: NotificationServiceProtocol
    private var bag = Set<AnyCancellable>()
    
    public init(iapService: IAPServiceProtocol,
                analytics: AnalyticsServiceProtocol,
                notification: NotificationServiceProtocol) {
        self.iapService = iapService
        self.analytics  = analytics
        self.notification = notification
        
        iapService.readCurrentPremiumEntitlement()
            .receive(on: DispatchQueue.main)
            .sink { [weak self] has in self?.premiumUnlocked = has }
            .store(in: &bag)
        
        NotificationCenter.default.publisher(for: .iapEntitlementsChanged)
            .flatMap { [iapService] _ in iapService.readCurrentPremiumEntitlement() }
            .receive(on: DispatchQueue.main)
            .sink { [weak self] has in self?.premiumUnlocked = has }
            .store(in: &bag)
    }
    
    public func setDarkMode(_ isOn: Bool) {
        guard isDarkMode != isOn else { return }
        isDarkMode = isOn
        UserDefaults.standard.set(isOn, forKey: Keys.darkMode)
        analytics.logEvent(name: "settings_dark_mode_changed", parameters: ["value": isOn])
    }
    
    public func setNotifications(_ isOn: Bool) {
        guard notificationsEnabled != isOn else { return }
        notificationsEnabled = isOn
        UserDefaults.standard.set(isOn, forKey: Keys.notificationsEnabled )
        analytics.logEvent(name: "settings_notifications_changed", parameters: ["value": isOn])
        if isOn {
            notification.requestAuthorization().sink { _ in }.store(in: &bag)
        }
    }
    // ‚Äî –æ—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–¥ IAP –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π
    public func purchasePremium() {
        errorMessage = nil
        
        iapService.fetchProducts()
            .tryMap { products -> Product in
                guard let p = products.first else {
                    throw NSError(domain: "IAP", code: -3, userInfo: [NSLocalizedDescriptionKey: "Product not found"])
                }
                return p
            }
            .flatMap { [iapService] product in
                iapService.purchase(product)
            }
            .flatMap { [iapService] _ in
                iapService.readCurrentPremiumEntitlement()
            }
            .receive(on: DispatchQueue.main)
            .sink(receiveCompletion: { [weak self] comp in
                if case let .failure(err) = comp { self?.errorMessage = err.localizedDescription }
            }, receiveValue: { [weak self] has in
                self?.premiumUnlocked = has
            })
            .store(in: &bag)
    }
    
    public func clearError() { errorMessage = nil }
}
//
//  AnySettingsViewModel.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/24/25.


import Combine
import StoreKit
import SwiftUI

final class AnySettingsViewModel: ObservableObject, SettingsViewModelProtocol {
    private let wrapped: any SettingsViewModelProtocol
    private var cancellables = Set<AnyCancellable>()

    let objectWillChange = ObservableObjectPublisher()

    @Published private(set) var isDarkMode: Bool = false
    @Published private(set) var notificationsEnabled: Bool = false
    @Published private(set) var premiumUnlocked: Bool = false
    @Published private(set) var errorMessage: String?

    init(_ wrapped: any SettingsViewModelProtocol) {
        self.wrapped = wrapped

        // –í–∞–∂–Ω–æ: objectWillChange —É wrapped ‚Äî —ç—Ç–æ willSet.
        // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º—Å—è –Ω–∞ —Å–ª–µ–¥—É—é—â–∏–π runloop-—Ç–∞–∫, —á—Ç–æ–±—ã —á–∏—Ç–∞—Ç—å —É–∂–µ –æ–±–Ω–æ–≤–ª—ë–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è.
        wrapped.objectWillChange
            .receive(on: DispatchQueue.main)
            .sink { [weak self] _ in
                DispatchQueue.main.async {
                    guard let self else { return }
                    self.syncProperties()
                    self.objectWillChange.send()
                }
            }
            .store(in: &cancellables)

        syncProperties()
    }

    private func syncProperties() {
        isDarkMode = wrapped.isDarkMode
        notificationsEnabled = wrapped.notificationsEnabled
        premiumUnlocked = wrapped.premiumUnlocked
        errorMessage = wrapped.errorMessage
    }

    func setDarkMode(_ isOn: Bool) {
        if isDarkMode != isOn {
            isDarkMode = isOn          // –º–≥–Ω–æ–≤–µ–Ω–Ω–æ –¥–ª—è SwiftUI
            objectWillChange.send()    // –Ω–∞ —Å–ª—É—á–∞–π, –µ—Å–ª–∏ –≥–¥–µ-—Ç–æ –Ω—É–∂–µ–Ω –Ω–µ–º–µ–¥–ª–µ–Ω–Ω—ã–π –∏–º–ø—É–ª—å—Å
        }
        wrapped.setDarkMode(isOn)      // –∏—Å—Ç–æ—á–Ω–∏–∫ –∏—Å—Ç–∏–Ω—ã
    }

    func setNotifications(_ isOn: Bool) {
        if notificationsEnabled != isOn {
            notificationsEnabled = isOn
            objectWillChange.send()
        }
        wrapped.setNotifications(isOn)
    }

    func purchasePremium() { wrapped.purchasePremium() }
    func clearError()      { wrapped.clearError() }
}
//
//  POIDetailViewModelProtocol.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/11/25.
//


import Combine
import MapKit

public protocol POIDetailViewModelProtocol: AnyObject {
  // Outputs
  var model: POIDetailModel { get }
  var isLoadingAddress: Bool { get }
  var address: String? { get }
  var errorMessage: String? { get }

  // User actions
  func onAppear()
  func didTapShare()
  func didTapOpenInMaps()
  func didTapClose()

  // Publishers for Coordinator/Router
  var sharePublisher: AnyPublisher<URL, Never> { get }
  var openInMapsPublisher: AnyPublisher<MKMapItem, Never> { get }
  var closePublisher: AnyPublisher<Void, Never> { get }

  // Publisher for model updates
  var modelPublisher: AnyPublisher<POIDetailModel, Never> { get }
}

@MainActor
public final class POIDetailViewModel: ObservableObject, POIDetailViewModelProtocol {
  @Published public private(set) var model: POIDetailModel
  @Published public private(set) var isLoadingAddress = false
  @Published public private(set) var address: String?
  @Published public private(set) var errorMessage: String?

  private let geocoder = CLGeocoder()
  private var cancellables = Set<AnyCancellable>()

  public init(poi: POI) {
    self.model = POIDetailModel(poi: poi,
                                address: nil,
                                imageData: nil)
  }

  public func onAppear() {
    guard address == nil else { return }
    isLoadingAddress = true
    let loc = CLLocation(latitude: model.poi.latitude,
                         longitude: model.poi.longitude)
    geocoder.reverseGeocodeLocation(loc) { [weak self] places, error in
      DispatchQueue.main.async {
          self?.isLoadingAddress = false
        if let err = error {
          self?.errorMessage = err.localizedDescription
        } else {
          self?.address = places?.first?.compactAddress
        }
      }
    }
  }

  public func didTapShare() {
    let p = model.poi
    let url = URL(string: "https://maps.apple.com/?ll=\(p.latitude),\(p.longitude)")!
    shareSubject.send(url)
  }

  public func didTapOpenInMaps() {
    let p = model.poi
    let coord = CLLocationCoordinate2D(latitude: p.latitude,
                                       longitude: p.longitude)
    let item = MKMapItem(placemark: MKPlacemark(coordinate: coord))
    item.name = p.name
    openInMapsSubject.send(item)
  }

  public func didTapClose() {
    closeSubject.send(())
  }

  // Internal subjects
  private let shareSubject      = PassthroughSubject<URL, Never>()
  private let openInMapsSubject = PassthroughSubject<MKMapItem, Never>()
  private let closeSubject      = PassthroughSubject<Void, Never>()

  // Protocol publishers
  public var sharePublisher: AnyPublisher<URL, Never> {
    shareSubject.eraseToAnyPublisher()
  }
  public var openInMapsPublisher: AnyPublisher<MKMapItem, Never> {
    openInMapsSubject.eraseToAnyPublisher()
  }
  public var closePublisher: AnyPublisher<Void, Never> {
    closeSubject.eraseToAnyPublisher()
  }

  public var modelPublisher: AnyPublisher<POIDetailModel, Never> {
    $model.eraseToAnyPublisher()
  }
}

private extension CLPlacemark {
  var compactAddress: String {
    [subThoroughfare, thoroughfare, locality, administrativeArea]
      .compactMap { $0 }
      .joined(separator: ", ")
  }
}
//
//  POIDetailRoute.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/11/25.
//



import Combine
import MapKit

public enum POIDetailRoute: Hashable, Identifiable {
  case share(URL)
  case openInMaps(MKMapItem)
  case close

  public var id: String {
    switch self {
    case .share(let url): return "share:\(url.absoluteString)"
    case .openInMaps(let item):
      let c = item.placemark.coordinate
      return "open:\(c.latitude),\(c.longitude)"
    case .close: return "close"
    }
  }
}

public enum POIDetailUIError: Hashable {
  case plain(String)
  var localizedMessage: String {
    switch self {
    case .plain(let m): return m
    }
  }
}

@MainActor
public final class POIDetailRouter: ObservableObject {
  public let routes = PassthroughSubject<POIDetailRoute, Never>()
  public let uiErrors = PassthroughSubject<POIDetailUIError, Never>()
  private var cancellables = Set<AnyCancellable>()

  public init(viewModel: POIDetailViewModel) {
    viewModel.sharePublisher
      .map(POIDetailRoute.share)
      .sink { [routes] in routes.send($0) }
      .store(in: &cancellables)

    viewModel.openInMapsPublisher
      .map(POIDetailRoute.openInMaps)
      .sink { [routes] in routes.send($0) }
      .store(in: &cancellables)

    viewModel.closePublisher
      .map { _ in POIDetailRoute.close }
      .sink { [routes] in routes.send($0) }
      .store(in: &cancellables)

    // –¢—Ä–∞–Ω—Å–ª–∏—Ä—É–µ–º –æ—à–∏–±–∫–∏ VM –≤ UIError-–∫–∞–Ω–∞–ª
    viewModel.$errorMessage
      .compactMap { $0 }
      .map { POIDetailUIError.plain($0) }
      .sink { [uiErrors] in uiErrors.send($0) }
      .store(in: &cancellables)
  }
}
//
//  POIDetailCoordinator.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/11/25.
//


import SwiftUI
import Combine
import Swinject

@MainActor
public final class POIDetailCoordinator: ObservableObject {
    @Published private(set) var sheetRoute: POIDetailRoute?
    @Published private(set) var model: POIDetailModel

    private let viewModel: POIDetailViewModel
    private let router: POIDetailRouter
    private var cancellables = Set<AnyCancellable>()

    // UI error state
    @Published private var failAlert: FailAlert?
    private struct FailAlert: Identifiable { let id = UUID(); let message: String }

    public init(poi: POI, resolver: Resolver? = nil) {
        let r = resolver ?? DIContainer.shared.resolver
        guard let vm = r.resolve(POIDetailViewModel.self, argument: poi) else {
            preconditionFailure("Swinject: POIDetailViewModel –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω –¥–ª—è \(POI.self)")
        }

        self.viewModel = vm
        self.router    = POIDetailRouter(viewModel: vm)
        self.model     = vm.model

        router.routes
            .sink { [weak self] route in
                switch route {
                case .share(let url):       self?.sheetRoute = .share(url)
                case .openInMaps(let item): item.openInMaps(launchOptions: nil)
                case .close:                self?.sheetRoute = nil
                }
            }
            .store(in: &cancellables)

        // —Ü–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π –ø–æ–∫–∞–∑ –æ—à–∏–±–æ–∫
        router.uiErrors
            .sink { [weak self] uiError in
                self?.failAlert = .init(message: uiError.localizedMessage)
            }
            .store(in: &cancellables)

        vm.modelPublisher
            .sink { [weak self] newModel in self?.model = newModel }
            .store(in: &cancellables)
    }

    @ViewBuilder
    public func rootView() -> some View {
        let binding = Binding<POIDetailRoute?>(
            get: { self.sheetRoute },
            set: { self.sheetRoute = $0 }
        )
        POIDetailView(viewModel: viewModel, sheetRoute: binding)
            .alert(item: Binding(
                get: { self.failAlert },
                set: { _ in self.failAlert = nil }
            )) { alert in
                Alert(
                    title: Text(L10n.alertErrorTitle),
                    message: Text(alert.message),
                    dismissButton: .default(Text(L10n.alertOk))
                )
            }
    }
}
//
//  POIDetailModel.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/11/25.
//


import Foundation

public struct POIDetailModel {
  public let poi: POI
  public let address: String?
  public let imageData: Data?

  public init(
    poi: POI,
    address: String?,
    imageData: Data?
  ) {
    self.poi = poi
    self.address = address
    self.imageData = imageData
  }
}
//
//  POIDetailView.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/11/25.
//


import SwiftUI
import MapKit

public struct POIDetailView: View {
  @ObservedObject private var vm: POIDetailViewModel
  @Binding private var sheetRoute: POIDetailRoute?

  public init(
    viewModel: POIDetailViewModel,
    sheetRoute: Binding<POIDetailRoute?>
  ) {
    self.vm = viewModel
    self._sheetRoute = sheetRoute
  }

  public var body: some View {
    VStack(spacing: 16) {
      HStack { Spacer()
        Button(action: vm.didTapClose) {
          Image(systemName: "xmark.circle.fill")
            .font(.title2)
        }
      }

      Text(vm.model.poi.name).font(.largeTitle)

      if vm.isLoadingAddress {
        ProgressView(L10n.detailLoadingAddress)
      } else if let addr = vm.address {
        Text(addr).italic()
      } else if let err = vm.errorMessage {
        // –≠–∫—Ä–∞–Ω–Ω–∞—è –ø–æ–¥—Å–≤–µ—Ç–∫–∞ + route-–∞–ª–µ—Ä—Ç –ø—Ä–∏–ª–µ—Ç–∏—Ç –∏–∑ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–æ—Ä–∞
        Text(err).foregroundColor(.red)
      }

      Button(L10n.detailShare,        action: vm.didTapShare)
      Button(L10n.detailOpenInMaps,   action: vm.didTapOpenInMaps)
      Spacer()
    }
    .padding()
    .onAppear(perform: vm.onAppear)
    .navigationTitle(vm.model.poi.name)
    .sheet(item: $sheetRoute) { route in
      switch route {
      case .share(let url):
        ActivityViewController(activityItems: [url])
      default:
        EmptyView()
      }
    }
  }
}


// UIKit wrapper
struct ActivityViewController: UIViewControllerRepresentable {
  let activityItems: [Any]

  func makeUIViewController(
    context: Context
  ) -> UIActivityViewController {
    UIActivityViewController(
      activityItems: activityItems,
      applicationActivities: nil
    )
  }

  func updateUIViewController(
    _ vc: UIActivityViewController,
    context: Context
  ) {}
}
//
//  POIMapViewModelProtocol.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/7/25.
//


import Combine
import MapKit

public protocol POIMapViewModelProtocol: ObservableObject {
    var annotations: [POIAnnotation] { get }
    var selectedPOI: POI? { get }
    func fetch()
    func select(annotation: POIAnnotation)
}

public final class POIMapViewModel: POIMapViewModelProtocol {
    // Output
    @Published public private(set) var annotations: [POIAnnotation] = []
    @Published public private(set) var selectedPOI: POI?

    // Deps
    private let service: POIServiceProtocol
    private let factory: AnnotationFactory
    private var bag = Set<AnyCancellable>()

    init(service: POIServiceProtocol,
                factory: AnnotationFactory = DefaultAnnotationFactory()) {
        self.service  = service
        self.factory  = factory
    }

    public func fetch() {
        service.fetchPOIs()
            .map(factory.makeAnnotations)
            .receive(on: DispatchQueue.main)
            .sink(receiveCompletion: { _ in },
                  receiveValue: { [weak self] in self?.annotations = $0 })
            .store(in: &bag)
    }

    public func select(annotation: POIAnnotation) {
        selectedPOI = annotation.poi
    }
}
//
//  AnyPOIMapViewModel.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/7/25.
//


import Combine
import SwiftUI

public final class AnyPOIMapViewModel: ObservableObject {
    // -------- SwiftUI bindings --------
    @Published public var annotations: [POIAnnotation] = []
    @Published public var selectedPOI: POI?            = nil

    // -------- Internals --------
    private let wrapped: any POIMapViewModelProtocol
    private var bag = Set<AnyCancellable>()

    // MARK: ‚Äì init
    public init(_ wrapped: any POIMapViewModelProtocol) {
        self.wrapped      = wrapped
        self.annotations  = wrapped.annotations
        self.selectedPOI  = wrapped.selectedPOI

        // –ï—Å–ª–∏ —ç—Ç–æ –∏–º–µ–Ω–Ω–æ POIMapViewModel, –ø–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ –µ–≥–æ @Published-–ø–æ–ª—è
        if let concrete = wrapped as? POIMapViewModel {
            concrete.$annotations
                .receive(on: DispatchQueue.main)
                .assign(to: &$annotations)

            concrete.$selectedPOI
                .receive(on: DispatchQueue.main)
                .assign(to: &$selectedPOI)
        }
    }

    // MARK: ‚Äì Facade
    public func fetch()                           { wrapped.fetch() }
    public func select(annotation: POIAnnotation) { wrapped.select(annotation: annotation) }
}
//
//  MapRoute.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/11/25.
//

import SwiftUI
import Combine
import CoreLocation

enum MapRoute: Hashable {
    case detail(POI)
}

enum MapUIError: Equatable {
    case poiNotFound(Int)
    case plain(String)

    var localizedMessage: String {
        switch self {
        case .poiNotFound(let id):
            return L10n.deeplinkPoiNotFound(id)
        case .plain(let message):
            return message
        }
    }
}

enum MapNavigationCommand {
    case detail(POI)
    case back
    case reset
    case center(CLLocationCoordinate2D)
    case focusPOI(Int)
    case showError(MapUIError)
}

@MainActor
final class MapRouter: ObservableObject {
    let routes = PassthroughSubject<MapNavigationCommand, Never>()
    private var pending: [MapNavigationCommand] = []

    private func emit(_ cmd: MapNavigationCommand) {
        pending.append(cmd)
        routes.send(cmd)
    }

    func consumePending() -> [MapNavigationCommand] {
        let items = pending
        pending.removeAll()
        return items
    }

    // MARK: High-level API
    func goDetail(_ poi: POI)                 { emit(.detail(poi)) }
    func goBack()                              { emit(.back) }
    func reset()                               { emit(.reset) }
    func center(on coord: CLLocationCoordinate2D) { emit(.center(coord)) }
    func focusPOI(_ id: Int)                   { emit(.focusPOI(id)) }

    // –ï–¥–∏–Ω—ã–π —Å–ø–æ—Å–æ–± –ø–æ–∫–∞–∑–∞—Ç—å –æ—à–∏–±–∫—É –Ω–∞ –∫–∞—Ä—Ç–µ
    func showError(_ error: MapUIError)        { emit(.showError(error)) }
}
//
//  MapCoordinator.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/10/25.
//


import SwiftUI
import Combine
import MapKit

@MainActor
final class MapCoordinator {
    private let vm: AnyPOIMapViewModel
    private let router: MapRouter
    private let defaultRegionMeters: CLLocationDistance
    private let makeDetail: (POI) -> AnyView
   
    
    init(vm: AnyPOIMapViewModel, router: MapRouter) {
        self.vm     = vm
        self.router = router
        
        let config = DIContainer.shared.resolver.resolve(AppConfig.self)!
        self.defaultRegionMeters = config.defaultRegionMeters
        let resolver = DIContainer.shared.resolver
        self.makeDetail = { poi in
            guard let coord = resolver.resolve(POIDetailCoordinator.self, argument: poi) else {
                return AnyView(EmptyView())
            }
            return AnyView(coord.rootView())
        }
    }
    
    func rootView() -> some View {
        MapContainer(vm: vm, router: router, defaultRegionMeters: defaultRegionMeters, makeDetail: makeDetail)
    }
}

//
//  POIAnnotation.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/7/25.
//


import MapKit

/// –ü—Ä–æ—Å—Ç–∞—è –æ–±—ë—Ä—Ç–∫–∞ –Ω–∞–¥ POI, —á—Ç–æ–±—ã —Å—Ç–∞—Ç—å MKAnnotation
public final class POIAnnotation: NSObject, MKAnnotation {
    let poi: POI

    // –ª–æ–∫–∞–ª—å–Ω–æ —Å–æ–±–∏—Ä–∞–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—É, –º–æ–¥–µ–ª—å POI –Ω–µ –º–µ–Ω—è–µ–º
    public var coordinate: CLLocationCoordinate2D {
        .init(latitude: poi.latitude, longitude: poi.longitude)
    }

    public var title: String?    { poi.name      }
    public var subtitle: String? { poi.category  }

    init(poi: POI) { self.poi = poi }
}

/// SRP-—Ñ–∞–±—Ä–∏–∫–∞ –¥–ª—è —Ç–µ—Å—Ç–æ–≤ –∏ —è–≤–Ω–æ–π –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
protocol AnnotationFactory {
    func makeAnnotations(from pois: [POI]) -> [POIAnnotation]
}

struct DefaultAnnotationFactory: AnnotationFactory {
    func makeAnnotations(from pois: [POI]) -> [POIAnnotation] {
        pois.map(POIAnnotation.init)
    }
}
//
//  POISnippetView.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/7/25.
//



import SwiftUI
import MapKit

struct POISnippetView: View {
    let poi: POI
    var onDetails: () -> Void
    var onRoute:   () -> Void

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text(poi.name).font(.title2).bold()
            if let cat = poi.category { Text(cat).foregroundColor(.secondary) }
            if let desc = poi.description { Text(desc).lineLimit(3) }

            HStack {
                Button("Details", action: onDetails)
                    .buttonStyle(.borderedProminent)

                Spacer()
                Button("Route", action: onRoute)
            }
        }
        .padding()
    }
}
//
//  MapViewRepresentable.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/7/25.
//

import SwiftUI
import MapKit

/// UIKit-–∫–∞—Ä—Ç–∞ —Å —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º:
/// - –¥–∏—Ñ—Ñ –∞–Ω–Ω–æ—Ç–∞—Ü–∏–π
/// - —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –≤—ã–¥–µ–ª–µ–Ω–∏—è –ø–æ `selectedId`
/// - –≤–Ω–µ—à–Ω—è—è –∫–æ–º–∞–Ω–¥–∞ —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏—è —á–µ—Ä–µ–∑ `centerRequest`
struct MapViewRepresentable: UIViewRepresentable {
    let annotations: [POIAnnotation]
    let defaultRegionMeters: CLLocationDistance

    /// –ï–¥–∏–Ω—ã–π –∏—Å—Ç–æ—á–Ω–∏–∫ –ø—Ä–∞–≤–¥—ã –¥–ª—è –≤—ã–¥–µ–ª–µ–Ω–∏—è –ø–∏–Ω–∞
    @Binding var selectedId: Int?

    /// –í–Ω–µ—à–Ω—è—è –∫–æ–º–∞–Ω–¥–∞ —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏—è –∫–∞—Ä—Ç—ã (–æ–¥–Ω–æ–∫—Ä–∞—Ç–Ω–∞—è) ‚Äî –ø–æ—Å–ª–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è —Å–±—Ä–∞—Å—ã–≤–∞–µ—Ç—Å—è –≤ nil
    @Binding var centerRequest: CLLocationCoordinate2D?

    /// –î–æ–ø. –∫–æ–ª–ª–±–µ–∫ (—Å–æ—Ö—Ä–∞–Ω—è–µ–º –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏; —á–∞—â–µ –≤—Å–µ–≥–æ noop)
    let onSelect: (POIAnnotation) -> Void

    func makeCoordinator() -> Coordinator { Coordinator(self) }

    func makeUIView(context: Context) -> MKMapView {
        let map = MKMapView()
        map.delegate = context.coordinator
        map.register(MKMarkerAnnotationView.self, forAnnotationViewWithReuseIdentifier: "marker")
        map.register(MKMarkerAnnotationView.self, forAnnotationViewWithReuseIdentifier: "cluster")
        map.showsUserLocation = true
        map.pointOfInterestFilter = .excludingAll
        return map
    }

    func updateUIView(_ map: MKMapView, context: Context) {
        // --- –¥–∏—Ñ—Ñ –∞–Ω–Ω–æ—Ç–∞—Ü–∏–π ---
        let existing = map.annotations.compactMap { $0 as? POIAnnotation }
        let existingIDs = Set(existing.map { $0.poi.id })
        let incomingIDs = Set(annotations.map { $0.poi.id })

        let toRemove = existing.filter { !incomingIDs.contains($0.poi.id) }
        if !toRemove.isEmpty { map.removeAnnotations(toRemove) }

        let toAdd = annotations.filter { !existingIDs.contains($0.poi.id) }
        if !toAdd.isEmpty { map.addAnnotations(toAdd) }

        // --- –ø–µ—Ä–≤–∏—á–Ω–∞—è —É—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ä–µ–≥–∏–æ–Ω–∞ ---
        if !context.coordinator.hasSetInitialRegion, !map.annotations.isEmpty {
            context.coordinator.hasSetInitialRegion = true
            let poiAnnos = map.annotations.compactMap { $0 as? POIAnnotation }
            if poiAnnos.count == 1, let only = poiAnnos.first {
                let region = MKCoordinateRegion(
                    center: only.coordinate,
                    latitudinalMeters: defaultRegionMeters,
                    longitudinalMeters: defaultRegionMeters
                )
                map.setRegion(region, animated: false)
            } else {
                map.showAnnotations(poiAnnos, animated: false)
                let insets = UIEdgeInsets(top: 80, left: 40, bottom: 160, right: 40)
                map.setVisibleMapRect(map.visibleMapRect, edgePadding: insets, animated: false)
            }
        }

        // --- —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –≤—ã–¥–µ–ª–µ–Ω–∏—è ---
        if let id = selectedId {
            if let anno = map.annotations
                .compactMap({ $0 as? POIAnnotation })
                .first(where: { $0.poi.id == id }) {
                let already = map.selectedAnnotations.contains {
                    guard let a = $0 as? POIAnnotation else { return false }
                    return a.poi.id == id
                }
                if !already { map.selectAnnotation(anno, animated: true) }
            }
        } else {
            if !map.selectedAnnotations.isEmpty {
                map.selectedAnnotations.forEach { map.deselectAnnotation($0, animated: true) }
            }
        }

        // --- –≤–Ω–µ—à–Ω—è—è –∫–æ–º–∞–Ω–¥–∞ —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏—è (deeplink) ---
        if let center = centerRequest {
            // —ç—Ç–æ –∏ –µ—Å—Ç—å ¬´–Ω–∞—à¬ª —Å—Ç–∞—Ä—Ç–æ–≤—ã–π —Ä–µ–≥–∏–æ–Ω ‚Äî –∑–∞–ø—Ä–µ—Ç–∏–º –∞–≤—Ç–æ-–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é –ø–æ–∑–∂–µ
            context.coordinator.hasSetInitialRegion = true
            let region = MKCoordinateRegion(
                center: center,
                latitudinalMeters: defaultRegionMeters,
                longitudinalMeters: defaultRegionMeters
            )
            map.setRegion(region, animated: true)
            // –æ–¥–Ω–æ–∫—Ä–∞—Ç–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ ‚Äî —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –∑–∞–ø—Ä–æ—Å –≤ nil
            DispatchQueue.main.async {
                self.centerRequest = nil
            }
        }
    }

    // MARK: - Coordinator

    final class Coordinator: NSObject, MKMapViewDelegate {
        var hasSetInitialRegion = false
        let parent: MapViewRepresentable
        private var lastSelectedId: Int?

        init(_ parent: MapViewRepresentable) { self.parent = parent }

        func mapView(_ mapView: MKMapView, didSelect view: MKAnnotationView) {
            guard let anno = view.annotation as? POIAnnotation else { return }
            guard lastSelectedId != anno.poi.id else { return }
            lastSelectedId = anno.poi.id

            parent.selectedId = anno.poi.id
            parent.onSelect(anno)
        }

        func mapView(_ mapView: MKMapView, didDeselect view: MKAnnotationView) {
            guard let anno = view.annotation as? POIAnnotation else { return }
            if lastSelectedId == anno.poi.id { lastSelectedId = nil }
            if parent.selectedId == anno.poi.id { parent.selectedId = nil }
        }

        func mapView(_ mapView: MKMapView, viewFor annotation: MKAnnotation) -> MKAnnotationView? {
            if let cluster = annotation as? MKClusterAnnotation {
                let v = mapView.dequeueReusableAnnotationView(withIdentifier: "cluster", for: annotation) as! MKMarkerAnnotationView
                v.displayPriority = .required
                v.markerTintColor = .systemBlue
                v.glyphText = "\(cluster.memberAnnotations.count)"
                v.titleVisibility = .hidden
                v.subtitleVisibility = .hidden
                v.canShowCallout = false
                return v
            }
            guard annotation is POIAnnotation else { return nil }
            let v = mapView.dequeueReusableAnnotationView(withIdentifier: "marker", for: annotation) as! MKMarkerAnnotationView
            v.displayPriority      = .defaultHigh
            v.clusteringIdentifier = "poi"
            v.markerTintColor      = .systemBlue
            v.glyphImage           = UIImage(systemName: "mappin")
            v.canShowCallout       = false
            return v
        }
    }
}
//
//  POIMapView.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/7/25.
//

import SwiftUI
import MapKit

/// –í–ª–∞–¥–µ–µ—Ç `AnyPOIMapViewModel`, –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –∫–∞—Ä—Ç—É –∏ —Å–Ω–∏–ø–ø–µ—Ç.
/// –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ñ–æ–∫—É—Å–æ–º –∏ —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ–º –ø—Ä–∏—Ö–æ–¥–∏—Ç —Å–≤–µ—Ä—Ö—É —á–µ—Ä–µ–∑ –±–∏–Ω–¥–∏–Ω–≥–∏.
public struct POIMapView: View {
    @StateObject private var vm: AnyPOIMapViewModel
    @EnvironmentObject private var router: MapRouter
    private let defaultRegionMeters: CLLocationDistance

    /// –ü—Ä–æ–∫–∏–¥—ã–≤–∞–µ–º –∏–∑ `MapContainer` –∑–∞–ø—Ä–æ—Å—ã —Ü–µ–Ω—Ç—Ä–∞/—Ñ–æ–∫—É—Å–∞
    @Binding private var centerRequest: CLLocationCoordinate2D?

    public init(
        viewModel: AnyPOIMapViewModel,
        defaultRegionMeters: CLLocationDistance,
        centerRequest: Binding<CLLocationCoordinate2D?>
    ) {
        _vm = StateObject(wrappedValue: viewModel)
        self.defaultRegionMeters = defaultRegionMeters
        self._centerRequest = centerRequest
    }

    public var body: some View {
        MapViewRepresentable(
            annotations: vm.annotations,
            defaultRegionMeters: defaultRegionMeters,
            selectedId: Binding(
                get: { vm.selectedPOI?.id },
                set: { newId in
                    vm.selectedPOI = newId.flatMap { id in
                        vm.annotations.first(where: { $0.poi.id == id })?.poi
                    }
                }
            ),
            centerRequest: $centerRequest,
            onSelect: { _ in }
        )
        .ignoresSafeArea()
        .onAppear { vm.fetch() }
        .sheet(item: Binding(
            get: { vm.selectedPOI },
            set: { vm.selectedPOI = $0 }
        ), onDismiss: {
            vm.selectedPOI = nil
        }) { poi in
            POISnippetView(
                poi: poi,
                onDetails: {
                    vm.selectedPOI = nil
                    DispatchQueue.main.async { router.goDetail(poi) }
                },
                onRoute: {
                    let coord = CLLocationCoordinate2D(latitude: poi.latitude, longitude: poi.longitude)
                    let item = MKMapItem(placemark: MKPlacemark(coordinate: coord))
                    item.name = poi.name
                    item.openInMaps()
                }
            )
            .presentationDetents([.height(200), .medium])
        }
    }
}
//
//  MapContainer.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/17/25.
//


import SwiftUI
import Combine
import Swinject
import MapKit

struct MapContainer: View {
    @State private var path: [MapRoute] = []
    @State private var prevPathCount: Int = 0

    @State private var lastPushedPOIId: Int?
    @State private var isNavigating = false

    @StateObject private var router: MapRouter
    @StateObject private var vm: AnyPOIMapViewModel

    private let defaultRegionMeters: CLLocationDistance
    private let makeDetail: (POI) -> AnyView

    @State private var centerRequest: CLLocationCoordinate2D? = nil

    @State private var pendingFocusId: Int? = nil
    @State private var focusTimeoutWorkItem: DispatchWorkItem? = nil
    @State private var failAlert: FailAlert? = nil

    private struct FailAlert: Identifiable {
        let id = UUID()
        let message: String
    }

    init(
        vm: AnyPOIMapViewModel,
        router: MapRouter,
        defaultRegionMeters: CLLocationDistance,
        makeDetail: @escaping (POI) -> AnyView
    ) {
        _vm = StateObject(wrappedValue: vm)
        _router = StateObject(wrappedValue: router)
        self.defaultRegionMeters = defaultRegionMeters
        self.makeDetail = makeDetail
    }

    var body: some View {
        NavigationStack(path: $path) {
            POIMapView(
                viewModel: vm,
                defaultRegionMeters: defaultRegionMeters,
                centerRequest: $centerRequest
            )
            .navigationDestination(for: MapRoute.self) { route in
                switch route {
                case .detail(let poi):
                    makeDetail(poi)
                }
            }
        }
        .onReceive(router.routes) { command in
            handle(command)
        }
        .onAppear {
            router.consumePending().forEach { handle($0) }
        }
        .onChange(of: path) { newValue in
            if newValue.count < prevPathCount {
                lastPushedPOIId = nil
                isNavigating = false
            }
            prevPathCount = newValue.count
        }
        .onChange(of: vm.annotations) { _ in
            if let id = pendingFocusId,
               let poi = vm.annotations.first(where: { $0.poi.id == id })?.poi {
                pendingFocusId = nil
                cancelFocusTimeout()
                vm.selectedPOI = poi
            }
        }
        .alert(item: $failAlert) { alert in
            Alert(
                title: Text(L10n.alertErrorTitle),
                message: Text(alert.message),
                dismissButton: .default(Text(L10n.alertOk))
            )
        }
        .environmentObject(router)
    }

    // MARK: - Helpers

    private func scheduleFocusTimeout(for id: Int, seconds: Double = 2.5) {
        cancelFocusTimeout()
        let work = DispatchWorkItem {
            if pendingFocusId == id, vm.selectedPOI?.id != id {
                // –µ–¥–∏–Ω—ã–π –ø—É—Ç—å –ø–æ–∫–∞–∑–∞ –æ—à–∏–±–∫–∏ ‚Äî —á–µ—Ä–µ–∑ Router
                router.showError(.poiNotFound(id))

                // –ø–æ–¥–≤–∏–Ω–µ–º –∫–∞—Ä—Ç—É, —á—Ç–æ–±—ã –Ω–µ –æ—Å—Ç–∞–≤–ª—è—Ç—å ¬´–Ω–∏–∫—É–¥–∞¬ª
                if let anyAnno = vm.annotations.first {
                    centerRequest = anyAnno.coordinate
                }

                // (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ) –º–µ—Ç—Ä–∏–∫–∞
                DIContainer.shared.resolver
                    .resolve(AnalyticsServiceProtocol.self)?
                    .logEvent(name: "deeplink_poi_not_found", parameters: ["id": id])

                pendingFocusId = nil
            }
        }
        focusTimeoutWorkItem = work
        DispatchQueue.main.asyncAfter(deadline: .now() + seconds, execute: work)
    }

    private func cancelFocusTimeout() {
        focusTimeoutWorkItem?.cancel()
        focusTimeoutWorkItem = nil
    }

    private func handle(_ command: MapNavigationCommand) {
        switch command {
        case .detail(let poi):
            guard !isNavigating, lastPushedPOIId != poi.id else { return }
            isNavigating = true
            path.append(.detail(poi))
            lastPushedPOIId = poi.id
            DispatchQueue.main.async { isNavigating = false }

        case .back:
            if !path.isEmpty { path.removeLast() }
            lastPushedPOIId = nil
            isNavigating = false

        case .reset:
            path.removeAll()
            lastPushedPOIId = nil
            isNavigating = false

        case .center(let coord):
            centerRequest = coord

        case .focusPOI(let id):
            if let poi = vm.annotations.first(where: { $0.poi.id == id })?.poi {
                vm.selectedPOI = poi
                cancelFocusTimeout()
            } else {
                pendingFocusId = id
                vm.fetch()
                scheduleFocusTimeout(for: id)
            }

        case .showError(let uiError):
            // –í—Å–µ–≥–¥–∞ –ª–æ–∫–∞–ª–∏–∑–æ–≤–∞–Ω–æ –∑–¥–µ—Å—å, –≤ UI-—Å–ª–æ–µ
            failAlert = .init(message: uiError.localizedMessage)
        }
    }
}
//
//  POIListViewModel.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/20/25.
//



import Combine
import CoreLocation
import MapKit

public protocol POIListViewModelProtocol: AnyObject {
    // Inputs
    var filter: POICategoryFilter { get set }
    func fetchPOIs()
    func openInMaps(poi: POI)
    
    // Outputs
    var pois: [POI] { get }
    var isLoading: Bool { get }
    var errorMessage: String? { get }
}

public final class POIListViewModel: ObservableObject, POIListViewModelProtocol {
    // MARK: Inputs
    @Published public var filter: POICategoryFilter = .all
    
    // MARK: Internal state
    private var allPois: [POI] = []
    
    // MARK: Outputs
    @Published public private(set) var pois: [POI] = []
    @Published public private(set) var isLoading: Bool = false
    @Published public private(set) var errorMessage: String? = nil
    
    private let repository: POIServiceProtocol
    private var cancellables = Set<AnyCancellable>()
    
    public init(repository: POIServiceProtocol) {
        self.repository = repository
        
        // –õ–æ–∫–∞–ª—å–Ω–∞—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø—Ä–∏ —Å–º–µ–Ω–µ filter
        $filter
            .dropFirst()
            .receive(on: DispatchQueue.main)
            .sink { [weak self] newFilter in
                self?.applyFilter(using: newFilter)
            }
            .store(in: &cancellables)
    }
    
    public func fetchPOIs() {
        if pois.isEmpty { isLoading = true }
        errorMessage = nil
        
        repository.fetchPOIs()
            .receive(on: DispatchQueue.main)
            .sink { [weak self] completion in
                guard let self = self else { return }
                self.isLoading = false
                if case let .failure(err) = completion {
                    self.errorMessage = err.localizedDescription
                }
            } receiveValue: { [weak self] list in
                guard let self = self else { return }
                self.allPois = list
                self.applyFilter()
            }
            .store(in: &cancellables)
    }
    
    private func applyFilter(using filter: POICategoryFilter? = nil) {
        let effective = filter ?? self.filter
        pois = (effective == .all)
        ? allPois
        : allPois.filter { $0.category == effective.rawValue }
    }
    
    public func openInMaps(poi: POI) {
        let coord = CLLocationCoordinate2D(latitude: poi.latitude,
                                           longitude: poi.longitude)
        let item = MKMapItem(placemark: MKPlacemark(coordinate: coord))
        item.name = poi.name
        item.openInMaps(launchOptions: nil)
    }
}
//
//  AnyPOIListViewModel.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/1/25.
//

import Foundation
import Combine

public final class AnyPOIListViewModel: ObservableObject {
    @Published public var filter: POICategoryFilter = .all
    @Published public var pois: [POI] = []
    @Published public var isLoading: Bool = false
    @Published public var errorMessage: String? = nil

    private let wrapped: POIListViewModelProtocol
    private var cancellables = Set<AnyCancellable>()

    public init(_ wrapped: POIListViewModelProtocol) {
        self.wrapped = wrapped
        self.filter = wrapped.filter

        // 1. –ü—Ä–æ–±—Ä–∞—Å—ã–≤–∞–µ–º filter –∏–∑ wrapper –≤ wrapped
        $filter
            .dropFirst()
            .sink { [weak self] newFilter in
                guard let self else { return }
                if self.wrapped.filter != newFilter {
                    self.wrapped.filter = newFilter
                }
            }
            .store(in: &cancellables)

        // 2. –ü—Ä–æ–±—Ä–∞—Å—ã–≤–∞–µ–º filter –∏–∑ wrapped –Ω–∞—Ä—É–∂—É (–µ—Å–ª–∏ –≤–¥—Ä—É–≥ –æ–Ω –º–µ–Ω—è–µ—Ç—Å—è)
        if let vm = wrapped as? POIListViewModel {
            vm.$filter
                .receive(on: DispatchQueue.main)
                .sink { [weak self] newFilter in
                    guard let self else { return }
                    if self.filter != newFilter {
                        self.filter = newFilter
                    }
                }
                .store(in: &cancellables)

            vm.$pois
                .receive(on: DispatchQueue.main)
                .assign(to: &$pois)
            vm.$isLoading
                .receive(on: DispatchQueue.main)
                .assign(to: &$isLoading)
            vm.$errorMessage
                .receive(on: DispatchQueue.main)
                .assign(to: &$errorMessage)
        }
    }

    public func fetchPOIs() { wrapped.fetchPOIs() }
    public func openInMaps(poi: POI) { wrapped.openInMaps(poi: poi) }
}
//
//  POIListRoute.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/11/25.
//



import SwiftUI
import Combine

enum POIListRoute: Hashable {
    case detail(POI)
}

enum POIListUIError: Hashable {
    case plain(String)
    var localizedMessage: String {
        switch self {
        case .plain(let m): return m
        }
    }
}

enum POIListNavigationCommand {
    case detail(POI)
    case back
    case reset
    case showError(POIListUIError)
}

@MainActor
final class POIListRouter: ObservableObject {
    let routes = PassthroughSubject<POIListNavigationCommand, Never>()
    var cancellables = Set<AnyCancellable>()

    func goDetail(_ poi: POI) { routes.send(.detail(poi)) }
    func goBack() { routes.send(.back) }
    func reset() { routes.send(.reset) }

    func showError(_ error: POIListUIError) { routes.send(.showError(error)) }
}
//
//  POIListRoute.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/10/25.
//


import SwiftUI

@MainActor
final class POIListCoordinator {
    private let viewModel: AnyPOIListViewModel
    private let router: POIListRouter
    private let makeDetail: (POI) -> AnyView
    
    init(viewModel: AnyPOIListViewModel, router: POIListRouter) {
        self.viewModel = viewModel
        self.router = router
        let resolver = DIContainer.shared.resolver
        self.makeDetail = { poi in
            guard let coord = resolver.resolve(POIDetailCoordinator.self, argument: poi) else {
                return AnyView(EmptyView())
            }
            return AnyView(coord.rootView())
        }
    }
    
    @ViewBuilder
    func rootView() -> some View {
        POIListContainer(vm: viewModel, router: router, makeDetail: makeDetail)
    }
}
//
//  POIImageView.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/2/25.
//


import SwiftUI

public struct POIImageView: View {
    let imagePath: String?

    public init(imagePath: String?) { self.imagePath = imagePath }

    public var body: some View {
        VStack {
            if let imagePath,
               let imageName = imagePath.split(separator: "/").last {
                let components = imageName.split(separator: ".")
                if components.count == 2 {
                    let name = String(components[0])
                    let ext = String(components[1])
                    if let url = Bundle.main.url(forResource: name, withExtension: ext),
                       let uiImage = UIImage(contentsOfFile: url.path) {
                        Image(uiImage: uiImage).resizable().scaledToFit()
                    } else {
                        Text("‚ùå \(name).\(ext)")
                            .foregroundColor(.red)
                        Text(L10n.imageInvalidPath(imagePath))
                            .font(.caption)
                    }
                } else {
                    Text(L10n.imageInvalidPath(imagePath))
                }
            } else {
                Text(L10n.imageNoImage)
            }
        }
    }
}
//
//  POIListContainer.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 9/11/25.
//



import SwiftUI
import Combine

struct POIListContainer: View {
    @State private var path = NavigationPath()
    @StateObject private var vm: AnyPOIListViewModel
    @StateObject private var router: POIListRouter
    private let makeDetail: (POI) -> AnyView

    // –µ–¥–∏–Ω—ã–π –∞–ª–µ—Ä—Ç
    @State private var failAlert: FailAlert?
    private struct FailAlert: Identifiable { let id = UUID(); let message: String }

    private var bag = Set<AnyCancellable>() // –Ω–µ @State ‚Äî –Ω–æ –Ω–∞–º —Ö–≤–∞—Ç–∏—Ç onAppear/Disappear

    init(vm: AnyPOIListViewModel, router: POIListRouter, makeDetail: @escaping (POI) -> AnyView) {
        _vm = StateObject(wrappedValue: vm)
        _router = StateObject(wrappedValue: router)
        self.makeDetail = makeDetail
    }

    var body: some View {
        NavigationStack(path: $path) {
            POIListView(viewModel: vm)
                .navigationDestination(for: POIListRoute.self) { route in
                    switch route {
                    case .detail(let poi):
                        makeDetail(poi)
                    }
                }
        }
        .onReceive(router.routes) { cmd in
            switch cmd {
            case .detail(let poi): path.append(POIListRoute.detail(poi))
            case .back: if !path.isEmpty { path.removeLast() }
            case .reset: if !path.isEmpty { path.removeLast(path.count) }
            case .showError(let e):
                failAlert = .init(message: e.localizedMessage)
            }
        }
        .onAppear {
            // –¢—Ä–∞–Ω—Å–ª–∏—Ä—É–µ–º VM.errorMessage -> —Ä–æ—É—Ç–µ—Ä
            vm.$errorMessage
                .compactMap { $0 }
                .sink { msg in router.showError(.plain(msg)) }
                .store(in: &router.cancellables)
        }
        .alert(item: $failAlert) { alert in
            Alert(
                title: Text(L10n.alertErrorTitle),
                message: Text(alert.message),
                dismissButton: .default(Text(L10n.alertOk))
            )
        }
        .environmentObject(router)
    }
}
//
//  POIListView.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 7/1/25.
//


import SwiftUI

public struct POIListView: View {
    @ObservedObject var viewModel: AnyPOIListViewModel
    @EnvironmentObject var router: POIListRouter

    public init(viewModel: AnyPOIListViewModel) {
        self.viewModel = viewModel
    }

    public var body: some View {
        ZStack {
            content
            if viewModel.isLoading {
                if viewModel.pois.isEmpty {
                    ProgressView().scaleEffect(1.2)
                } else {
                    VStack { Spacer() }
                        .overlay(
                            ProgressView()
                                .padding(12)
                                .background(.ultraThinMaterial)
                                .clipShape(RoundedRectangle(cornerRadius: 12))
                                .padding(.bottom, 24),
                            alignment: .bottom
                        )
                }
            }
        }
        .navigationTitle(L10n.navPlacesTitle)
        .onAppear { viewModel.fetchPOIs() }
    }

    @ViewBuilder
    private var content: some View {
        if let err = viewModel.errorMessage {
            VStack(spacing: 16) {
                Text(err).multilineTextAlignment(.center)
                Button(L10n.listRetry) { viewModel.fetchPOIs() }
            }
            .padding()
        } else {
            VStack {
                Picker(L10n.listCategoryTitle, selection: $viewModel.filter) {
                    ForEach(POICategoryFilter.allCases) { Text($0.localizedTitle).tag($0) }
                }
                .pickerStyle(.segmented)
                .padding(.vertical)

                // –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è plural (–µ—Å–ª–∏ —Ö–æ—á–µ—à—å ‚Äî –ø–æ–∫–∞–∂–µ–º –Ω–∞–¥ —Å–ø–∏—Å–∫–æ–º)
                if !viewModel.pois.isEmpty {
                    Text(L10n.listPlacesCount(viewModel.pois.count))
                        .font(.footnote).foregroundColor(.secondary)
                }

                List(viewModel.pois) { poi in
                    Button { router.goDetail(poi) } label: {
                        HStack {
                            POIImageView(imagePath: poi.imageURL?.path)
                                .frame(width: 48, height: 48)
                                .clipShape(RoundedRectangle(cornerRadius: 8))
                                .padding(.trailing, 4)
                            VStack(alignment: .leading) {
                                Text(poi.name).font(.headline)
                                if let c = poi.category {
                                    Text(c).font(.subheadline).foregroundColor(.secondary)
                                }
                            }
                        }
                        .padding(.vertical, 4)
                    }
                }
                .listStyle(.plain)
            }
        }
    }
}
//
//  AnyOnboardingViewModel.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/26/25.
//

import Combine

/// –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π Any-ViewModel –¥–ª—è Onboarding, —Å–∫—Ä—ã–≤–∞–µ—Ç –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π —Ç–∏–ø
public final class AnyOnboardingViewModel: OnboardingViewModelProtocol {
    // MARK: ‚Äî ObservableObject conformance
    public let objectWillChange = ObservableObjectPublisher()
    private var cancellables = Set<AnyCancellable>()
    
    // MARK: ‚Äî Outputs
    @Published public private(set) var pages: [OnboardingPage]
    @Published public private(set) var currentPage: Int
    @Published public private(set) var hasCompletedOnboarding: Bool
    
    
    // MARK: ‚Äî Wrapped instance
    private let wrapped: any OnboardingViewModelProtocol
    
    /// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Ç–∏–ø-—Å—Ç–∏—Ä–∞—é—â—É—é ¬´–æ–±—ë—Ä—Ç–∫—É¬ª
    public init(_ wrapped: any OnboardingViewModelProtocol) {
        self.wrapped = wrapped
        // –∫–æ–ø–∏—Ä—É–µ–º –Ω–∞—á–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
        self.pages               = wrapped.pages
        self.currentPage         = wrapped.currentPage
        self.hasCompletedOnboarding = wrapped.hasCompletedOnboarding
        
        // –ø–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è –Ω–∞ objectWillChange wrapped-VM,
        // —á—Ç–æ–±—ã –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å —Å–æ–±—ã—Ç–∏—è —Å—É–±—ä–µ–∫—Ç–∏–≤–Ω–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∏ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Å–≤–æ–π—Å—Ç–≤–∞
        wrapped.objectWillChange
            .sink { [weak self] _ in
                guard let self = self else { return }
                self.pages               = self.wrapped.pages
                self.currentPage         = self.wrapped.currentPage
                self.hasCompletedOnboarding = self.wrapped.hasCompletedOnboarding
                self.objectWillChange.send()
            }
            .store(in: &cancellables)
    }
    
    // MARK: ‚Äî Inputs: –ø—Ä–æ—Å—Ç–æ –¥–µ–ª–µ–≥–∏—Ä—É–µ–º –≤—ã–∑–æ–≤—ã
    public func next() {
        wrapped.next()
    }
    public func previous() {
        wrapped.previous()
    }
    public func skip() {
        wrapped.skip()
    }
}
//
//  OnboardingViewModel.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/26/25.
//


import Combine
import Foundation

public protocol OnboardingViewModelProtocol: ObservableObject {
    /// –ß—Ç–æ–±—ã View –º–æ–≥–ª–∞ –ø–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ –ª—é–±—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è
    var objectWillChange: ObservableObjectPublisher { get }
    
    // MARK: ‚Äî Outputs
    var pages: [OnboardingPage] { get }
    var currentPage: Int { get }
    var hasCompletedOnboarding: Bool { get }
    
    // MARK: ‚Äî Inputs
    func next()
    func previous()
    func skip()
}

public final class OnboardingViewModel: OnboardingViewModelProtocol {
    // MARK: ‚Äî ObservableObject conformance
    public let objectWillChange = ObservableObjectPublisher()
    
    // MARK: ‚Äî Outputs
    @Published public private(set) var currentPage: Int = 0
    @Published public private(set) var hasCompletedOnboarding: Bool
    
    public let pages: [OnboardingPage]
    private var cancellables = Set<AnyCancellable>()
    
    public init() {
        // –°—Ç—Ä–∞–Ω–∏—Ü—ã –æ–Ω–±–æ—Ä–¥–∏–Ω–≥–∞
        self.pages = [
                   OnboardingPage(id: 0, imageName: "onb1",
                                  title: L10n.onbPage1Title, description: L10n.onbPage1Desc),
                   OnboardingPage(id: 1, imageName: "onb2",
                                  title: L10n.onbPage2Title, description: L10n.onbPage2Desc),
                   OnboardingPage(id: 2, imageName: "onb3",
                                  title: L10n.onbPage3Title, description: L10n.onbPage3Desc)
               ]
        self.hasCompletedOnboarding = UserDefaults.standard.hasCompletedOnboarding
    }
    
    // MARK: ‚Äî Inputs
    
    public func next() {
        guard currentPage < pages.count - 1 else {
            skip()
            return
        }
        currentPage += 1
        objectWillChange.send()                 // <-- —É–≤–µ–¥–æ–º–ª—è–µ–º SwiftUI –∑–∞—Ä–∞–Ω–µ–µ
    }
    
    public func previous() {
        guard currentPage > 0 else { return }
        currentPage -= 1
        objectWillChange.send()
    }
    
    public func skip() {
        hasCompletedOnboarding = true
        UserDefaults.standard.hasCompletedOnboarding = true
        objectWillChange.send()
    }
}
//
//  OnboardingPage.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/26/25.
//


import Foundation

public struct OnboardingPage: Identifiable {
  public let id: Int
  public let imageName: String
  public let title: String
  public let description: String

  public init(
    id: Int,
    imageName: String,
    title: String,
    description: String
  ) {
    self.id = id
    self.imageName = imageName
    self.title = title
    self.description = description
  }
}
//
//  OnboardingView.swift
//  TravelBuddy
//
//  Created by Niiaz Khasanov on 6/26/25.
//

import SwiftUI

public struct OnboardingView<VM: OnboardingViewModelProtocol>: View {
    @ObservedObject private var vm: VM
    @Namespace private var imageNamespace
    
    public init(vm: VM) {
        self.vm = vm
    }
    
    public var body: some View {
        ZStack {
            Color(DesignTokens.colorBackground)
                .ignoresSafeArea()
            
            VStack(spacing: DesignTokens.spacingMedium) {
                Spacer()
                
                // –∫–∞—Ä—Ç–∏–Ω–∫–∞
                ForEach(vm.pages, id: \.id) { page in
                    if page.id == vm.currentPage {
                        Image(page.imageName)
                            .resizable()
                            .scaledToFit()
                            .frame(maxHeight: 300.scale)
                            .padding(.horizontal, DesignTokens.spacingMedium)
                            .transition(
                                .asymmetric(
                                    insertion: .scale.combined(with: .opacity),
                                    removal: .scale.combined(with: .opacity)
                                )
                            )
                    }
                }
                
                Text(vm.pages[vm.currentPage].title)
                    .font(.headline)
                    .multilineTextAlignment(.center)
                    .padding(.horizontal, DesignTokens.spacingMedium)
                
                Text(vm.pages[vm.currentPage].description)
                    .font(.body)
                    .multilineTextAlignment(.center)
                    .padding(.horizontal, DesignTokens.spacingMedium)
                
                Spacer()
                
                HStack(spacing: 5.scale) {
                    ForEach(vm.pages.indices, id: \.self) { idx in
                        Circle()
                            .fill(idx == vm.currentPage
                                  ? Color(DesignTokens.colorPrimary)
                                  : Color.gray.opacity(0.4))
                            .frame(width: 5.scale, height: 5.scale)
                            .scaleEffect(idx == vm.currentPage ? 1.2 : 1.0)
                    }
                }
                
                HStack {
                    if vm.currentPage > 0 {
                        Button("Back") {
                            withAnimation(.easeInOut) {
                                vm.previous()
                            }
                        }
                        .font(.body)
                        .padding(.trailing, DesignTokens.spacingMedium)
                    }
                    
                    Spacer()
                    
                    Button(vm.currentPage == vm.pages.count - 1 ? L10n.onbGetStarted : L10n.onbNext) {
                        withAnimation(.easeInOut) { vm.next()
                        }
                    }.font(.body)
                }
                .padding(.horizontal, DesignTokens.spacingMedium)
            }
            .foregroundColor(.primary)
        }
        .animation(.spring(response: 0.5, dampingFraction: 0.7), value: vm.currentPage)
    }
    
}
# Autogenerated by fastlane
#
# Ensure this file is checked in to source control!

gem 'fastlane-plugin-appicon'
app_identifier("niiazkhasanov.TravelBuddy") # –ø–æ–º–µ–Ω—è–π –Ω–∞ —Å–≤–æ–π bundle id –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏
apple_id("niyaz.khasanov@gmail.com")     # –Ω–µ –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω, –µ—Å–ª–∏ –Ω–µ –≤—ã–≥—Ä—É–∂–∞–µ—à—å –≤ TestFlight
default_platform(:ios)

platform :ios do
  desc "Run SwiftLint"
  lane :lint do
    sh "swiftlint --strict"
  end

  desc "Build Debug (simulator)"
  lane :build_debug do
    xcbuild = "xcodebuild -scheme TravelBuddy -sdk iphonesimulator -configuration Debug -destination 'platform=iOS Simulator,name=iPhone 15' -skipPackagePluginValidation -skipMacroValidation clean build"
    sh "#{xcbuild} | xcpretty"
  end

  desc "Archive Release (device)"
  lane :archive_release do
    sh "xcodebuild -scheme TravelBuddy -configuration Release -sdk iphoneos -archivePath build/TravelBuddy.xcarchive -skipPackagePluginValidation -skipMacroValidation archive | xcpretty"
  end

  desc "Export IPA (ad-hoc)"
  lane :export_ipa do
    export_plist = "ExportOptions.plist"
    File.write(export_plist, <<~PLIST)
      <?xml version="1.0" encoding="UTF-8"?>
      <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
      <plist version="1.0"><dict>
        <key>method</key><string>ad-hoc</string>
        <key>signingStyle</key><string>automatic</string>
        <key>compileBitcode</key><false/>
        <key>destination</key><string>export</string>
        <key>stripSwiftSymbols</key><true/>
      </dict></plist>
    PLIST
    sh "xcodebuild -exportArchive -archivePath build/TravelBuddy.xcarchive -exportOptionsPlist #{export_plist} -exportPath build/export | xcpretty"
  end

  # -------- SNAPSHOT (–ª–æ–∫–∞–ª–∏–∑–∞—Ü–∏—è) ----------
  desc "Run UI snapshots via fastlane snapshot"
  lane :snapshots do
    # clear_derived_data
    snapshot(
      scheme: "TravelBuddy",
      workspace: nil, # —É–∫–∞–∂–∏, –µ—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—à—å .xcworkspace
      devices: ["iPhone 16 Pro", "iPhone 16 Pro Max"],
      languages: ["en-US", "ru-RU"],
      stop_after_first_error: true,
      output_directory: "fastlane/screenshots",
      clean: false
    )
  end

  desc "CI lane"
  lane :ci do
    lint
    build_debug
    archive_release
    export_ipa
  ensure
    sh "mkdir -p fastlane/logs"
  end
end
fastlane documentation
----

# Installation

Make sure you have the latest version of the Xcode command line tools installed:

```sh
xcode-select --install
```

For _fastlane_ installation instructions, see [Installing _fastlane_](https://docs.fastlane.tools/#installing-fastlane)

# Available Actions

## iOS

### ios lint

```sh
[bundle exec] fastlane ios lint
```

Run SwiftLint

### ios build_debug

```sh
[bundle exec] fastlane ios build_debug
```

Build Debug (simulator)

### ios archive_release

```sh
[bundle exec] fastlane ios archive_release
```

Archive Release (device)

### ios export_ipa

```sh
[bundle exec] fastlane ios export_ipa
```

Export IPA (ad-hoc)

### ios snapshots

```sh
[bundle exec] fastlane ios snapshots
```

Run UI snapshots via fastlane snapshot

### ios ci

```sh
[bundle exec] fastlane ios ci
```

CI lane

----

This README.md is auto-generated and will be re-generated every time [_fastlane_](https://fastlane.tools) is run.

More information about _fastlane_ can be found on [fastlane.tools](https://fastlane.tools).

The documentation of _fastlane_ can be found on [docs.fastlane.tools](https://docs.fastlane.tools).
<?xml version="1.0" encoding="UTF-8"?>
<testsuites>
  <testsuite name="fastlane.lanes">
    
    
    
      
      <testcase classname="fastlane.lanes" name="0: default_platform" time="0.000187">
        
      </testcase>
    
      
      <testcase classname="fastlane.lanes" name="1: clear_derived_data" time="6.327153">
        
      </testcase>
    
      
      <testcase classname="fastlane.lanes" name="2: snapshot" time="148.061438">
        
          <failure message="/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/fastlane-2.228.0/fastlane/lib/fastlane/actions/actions_helper.rb:67:in `execute_action&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/fastlane-2.228.0/fastlane/lib/fastlane/runner.rb:255:in `block in execute_action&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/fastlane-2.228.0/fastlane/lib/fastlane/runner.rb:229:in `chdir&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/fastlane-2.228.0/fastlane/lib/fastlane/runner.rb:229:in `execute_action&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/fastlane-2.228.0/fastlane/lib/fastlane/runner.rb:157:in `trigger_action_by_name&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/fastlane-2.228.0/fastlane/lib/fastlane/fast_file.rb:159:in `method_missing&apos;&#10;Fastfile:41:in `block (2 levels) in parsing_binding&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/fastlane-2.228.0/fastlane/lib/fastlane/lane.rb:41:in `call&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/fastlane-2.228.0/fastlane/lib/fastlane/runner.rb:49:in `block in execute&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/fastlane-2.228.0/fastlane/lib/fastlane/runner.rb:45:in `chdir&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/fastlane-2.228.0/fastlane/lib/fastlane/runner.rb:45:in `execute&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/fastlane-2.228.0/fastlane/lib/fastlane/lane_manager.rb:46:in `cruise_lane&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/fastlane-2.228.0/fastlane/lib/fastlane/command_line_handler.rb:34:in `handle&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/fastlane-2.228.0/fastlane/lib/fastlane/commands_generator.rb:110:in `block (2 levels) in run&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/commander-4.6.0/lib/commander/command.rb:187:in `call&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/commander-4.6.0/lib/commander/command.rb:157:in `run&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/commander-4.6.0/lib/commander/runner.rb:444:in `run_active_command&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/fastlane-2.228.0/fastlane_core/lib/fastlane_core/ui/fastlane_runner.rb:124:in `run!&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/commander-4.6.0/lib/commander/delegates.rb:18:in `run!&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/fastlane-2.228.0/fastlane/lib/fastlane/commands_generator.rb:363:in `run&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/fastlane-2.228.0/fastlane/lib/fastlane/commands_generator.rb:43:in `start&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/fastlane-2.228.0/fastlane/lib/fastlane/cli_tools_distributor.rb:123:in `take_off&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/fastlane-2.228.0/bin/fastlane:23:in `&lt;top (required)&gt;&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/bin/fastlane:25:in `load&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/bin/fastlane:25:in `&lt;top (required)&gt;&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/bundler-2.6.9/lib/bundler/cli/exec.rb:59:in `load&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/bundler-2.6.9/lib/bundler/cli/exec.rb:59:in `kernel_load&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/bundler-2.6.9/lib/bundler/cli/exec.rb:23:in `run&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/bundler-2.6.9/lib/bundler/cli.rb:452:in `exec&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/bundler-2.6.9/lib/bundler/vendor/thor/lib/thor/command.rb:28:in `run&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/bundler-2.6.9/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/bundler-2.6.9/lib/bundler/vendor/thor/lib/thor.rb:538:in `dispatch&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/bundler-2.6.9/lib/bundler/cli.rb:35:in `dispatch&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/bundler-2.6.9/lib/bundler/vendor/thor/lib/thor/base.rb:584:in `start&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/bundler-2.6.9/lib/bundler/cli.rb:29:in `start&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/bundler-2.6.9/exe/bundle:28:in `block in &lt;top (required)&gt;&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/bundler-2.6.9/lib/bundler/friendly_errors.rb:117:in `with_friendly_errors&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/lib/ruby/gems/3.2.0/gems/bundler-2.6.9/exe/bundle:20:in `&lt;top (required)&gt;&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/bin/bundle:25:in `load&apos;&#10;/Users/nkhsnv/.rbenv/versions/3.2.2/bin/bundle:25:in `&lt;main&gt;&apos;&#10;&#10;Exit status: 74" />
        
      </testcase>
    
  </testsuite>
</testsuites>
# Snapfile ‚Äî –∫–æ–Ω—Ñ–∏–≥ –¥–ª—è fastlane snapshot

scheme("TravelBuddy")
# workspace("TravelBuddy.xcworkspace")

devices(["iPhone 16 Pro", "iPhone 16 Pro Max"])
languages(["en-US", "ru-RU"])

output_directory("fastlane/screenshots")
stop_after_first_error(true)
clear_previous_screenshots(true)

# –í–∞–∂–Ω–æ:
clean(false)
xcargs("-disableAutomaticPackageResolution")
name: iOS CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

permissions:
  contents: read

concurrency:
  group: ios-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # build:
  #   name: Build + Lint
  #   runs-on: macos-15
  #   timeout-minutes: 60
  #   steps:
  #     - name: Checkout
  #       uses: actions/checkout@v4
  #     - name: Select Xcode
  #       run: |
  #         XCODE="/Applications/Xcode.app"
  #         sudo xcode-select -s "$XCODE"
  #         xcodebuild -version
  #     - name: Cache Ruby gems
  #       uses: actions/cache@v4
  #       with:
  #         path: vendor/bundle
  #         key: ${{ runner.os }}-gems-${{ hashFiles('**/Gemfile.lock') }}
  #         restore-keys: |
  #           ${{ runner.os }}-gems-
  #     - name: Setup Ruby
  #       uses: ruby/setup-ruby@v1
  #       with:
  #         ruby-version: '3.2'
  #         bundler-cache: true
  #     - name: Install Bundler deps
  #       run: bundle install --path vendor/bundle
  #     - name: Install SwiftLint
  #       run: brew install swiftlint || true
  #     - name: Install xcpretty
  #       run: gem install xcpretty
  #     - name: Lint
  #       run: swiftlint
  #     - name: Build (Debug, simulator)
  #       run: |
  #         set -e
  #         xcodebuild \
  #           -scheme TravelBuddy \
  #           -sdk iphonesimulator \
  #           -configuration Debug \
  #           -destination 'platform=iOS Simulator,name=iPhone 16 Pro' \
  #           -skipPackagePluginValidation \
  #           -skipMacroValidation \
  #           clean build | xcpretty
  #       env:
  #         NSUnbufferedIO: YES
  #     - name: Archive (Release, device)
  #       run: |
  #         xcodebuild \
  #           -scheme TravelBuddy \
  #           -configuration Release \
  #           -sdk iphoneos \
  #           -archivePath build/TravelBuddy.xcarchive \
  #           -skipPackagePluginValidation \
  #           -skipMacroValidation \
  #           archive | xcpretty
  #     - name: Export .ipa (ad-hoc)
  #       if: ${{ always() }}
  #       run: |
  #         cat > ExportOptions.plist <<'PLIST'
  #         <?xml version="1.0" encoding="UTF-8"?>
  #         <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
  #         <plist version="1.0">
  #         <dict>
  #           <key>method</key><string>ad-hoc</string>
  #           <key>signingStyle</key><string>automatic</string>
  #           <key>compileBitcode</key><false/>
  #           <key>destination</key><string>export</string>
  #           <key>stripSwiftSymbols</key><true/>
  #         </dict>
  #         </plist>
  #         PLIST
  #         if [ -d "build/TravelBuddy.xcarchive" ]; then
  #           xcodebuild -exportArchive \
  #             -archivePath build/TravelBuddy.xcarchive \
  #             -exportOptionsPlist ExportOptions.plist \
  #             -exportPath build/export | xcpretty
  #         else
  #           echo "Archive not found, skipping export."
  #         fi
  #       continue-on-error: true
  #     - name: Upload artifacts
  #       if: ${{ always() }}
  #       uses: actions/upload-artifact@v4
  #       with:
  #         name: build-artifacts
  #         path: |
  #           build/TravelBuddy.xcarchive
  #           build/export/*.ipa
  #           fastlane/logs

  snapshots:
    name: UI Snapshots (fastlane)
    runs-on: macos-15
    timeout-minutes: 60
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Select Xcode
        run: |
          XCODE="/Applications/Xcode.app"
          sudo xcode-select -s "$XCODE"
          xcodebuild -version

      - name: Cache Ruby gems
        uses: actions/cache@v4
        with:
          path: vendor/bundle
          key: ${{ runner.os }}-gems-${{ hashFiles('**/Gemfile.lock') }}
          restore-keys: |
            ${{ runner.os }}-gems-

      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2'
          bundler-cache: true

      - name: Install Bundler deps
        run: bundle install --path vendor/bundle

      - name: List simulators (debug)
        run: xcrun simctl list devices

      - name: Resolve SPM
        run: xcodebuild -resolvePackageDependencies -scheme TravelBuddy -project ./TravelBuddy.xcodeproj

      - name: Run fastlane snapshots
        env:
          FASTLANE_SNAPSHOT: "YES"
          LC_ALL: en_US.UTF-8
          LANG: en_US.UTF-8
          FASTLANE_XCODEBUILD_SETTINGS_TIMEOUT: "30"
          FASTLANE_XCODEBUILD_SETTINGS_RETRIES: "8"
        run: bundle exec fastlane snapshots

      - name: Upload screenshots
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: ui-screenshots
          path: fastlane/screenshots
source "https://rubygems.org"

gem "fastlane"
gem "xcpretty"
GEM
  remote: https://rubygems.org/
  specs:
    CFPropertyList (3.0.7)
      base64
      nkf
      rexml
    addressable (2.8.7)
      public_suffix (>= 2.0.2, < 7.0)
    artifactory (3.0.17)
    atomos (0.1.3)
    aws-eventstream (1.4.0)
    aws-partitions (1.1120.0)
    aws-sdk-core (3.226.1)
      aws-eventstream (~> 1, >= 1.3.0)
      aws-partitions (~> 1, >= 1.992.0)
      aws-sigv4 (~> 1.9)
      base64
      jmespath (~> 1, >= 1.6.1)
      logger
    aws-sdk-kms (1.105.0)
      aws-sdk-core (~> 3, >= 3.225.0)
      aws-sigv4 (~> 1.5)
    aws-sdk-s3 (1.191.0)
      aws-sdk-core (~> 3, >= 3.225.0)
      aws-sdk-kms (~> 1)
      aws-sigv4 (~> 1.5)
    aws-sigv4 (1.12.1)
      aws-eventstream (~> 1, >= 1.0.2)
    babosa (1.0.4)
    base64 (0.3.0)
    claide (1.1.0)
    colored (1.2)
    colored2 (3.1.2)
    commander (4.6.0)
      highline (~> 2.0.0)
    declarative (0.0.20)
    digest-crc (0.7.0)
      rake (>= 12.0.0, < 14.0.0)
    domain_name (0.6.20240107)
    dotenv (2.8.1)
    emoji_regex (3.2.3)
    excon (0.112.0)
    faraday (1.10.4)
      faraday-em_http (~> 1.0)
      faraday-em_synchrony (~> 1.0)
      faraday-excon (~> 1.1)
      faraday-httpclient (~> 1.0)
      faraday-multipart (~> 1.0)
      faraday-net_http (~> 1.0)
      faraday-net_http_persistent (~> 1.0)
      faraday-patron (~> 1.0)
      faraday-rack (~> 1.0)
      faraday-retry (~> 1.0)
      ruby2_keywords (>= 0.0.4)
    faraday-cookie_jar (0.0.7)
      faraday (>= 0.8.0)
      http-cookie (~> 1.0.0)
    faraday-em_http (1.0.0)
    faraday-em_synchrony (1.0.1)
    faraday-excon (1.1.0)
    faraday-httpclient (1.0.1)
    faraday-multipart (1.1.1)
      multipart-post (~> 2.0)
    faraday-net_http (1.0.2)
    faraday-net_http_persistent (1.2.0)
    faraday-patron (1.0.0)
    faraday-rack (1.0.0)
    faraday-retry (1.0.3)
    faraday_middleware (1.2.1)
      faraday (~> 1.0)
    fastimage (2.4.0)
    fastlane (2.228.0)
      CFPropertyList (>= 2.3, < 4.0.0)
      addressable (>= 2.8, < 3.0.0)
      artifactory (~> 3.0)
      aws-sdk-s3 (~> 1.0)
      babosa (>= 1.0.3, < 2.0.0)
      bundler (>= 1.12.0, < 3.0.0)
      colored (~> 1.2)
      commander (~> 4.6)
      dotenv (>= 2.1.1, < 3.0.0)
      emoji_regex (>= 0.1, < 4.0)
      excon (>= 0.71.0, < 1.0.0)
      faraday (~> 1.0)
      faraday-cookie_jar (~> 0.0.6)
      faraday_middleware (~> 1.0)
      fastimage (>= 2.1.0, < 3.0.0)
      fastlane-sirp (>= 1.0.0)
      gh_inspector (>= 1.1.2, < 2.0.0)
      google-apis-androidpublisher_v3 (~> 0.3)
      google-apis-playcustomapp_v1 (~> 0.1)
      google-cloud-env (>= 1.6.0, < 2.0.0)
      google-cloud-storage (~> 1.31)
      highline (~> 2.0)
      http-cookie (~> 1.0.5)
      json (< 3.0.0)
      jwt (>= 2.1.0, < 3)
      mini_magick (>= 4.9.4, < 5.0.0)
      multipart-post (>= 2.0.0, < 3.0.0)
      naturally (~> 2.2)
      optparse (>= 0.1.1, < 1.0.0)
      plist (>= 3.1.0, < 4.0.0)
      rubyzip (>= 2.0.0, < 3.0.0)
      security (= 0.1.5)
      simctl (~> 1.6.3)
      terminal-notifier (>= 2.0.0, < 3.0.0)
      terminal-table (~> 3)
      tty-screen (>= 0.6.3, < 1.0.0)
      tty-spinner (>= 0.8.0, < 1.0.0)
      word_wrap (~> 1.0.0)
      xcodeproj (>= 1.13.0, < 2.0.0)
      xcpretty (~> 0.4.1)
      xcpretty-travis-formatter (>= 0.0.3, < 2.0.0)
    fastlane-sirp (1.0.0)
      sysrandom (~> 1.0)
    gh_inspector (1.1.3)
    google-apis-androidpublisher_v3 (0.54.0)
      google-apis-core (>= 0.11.0, < 2.a)
    google-apis-core (0.11.3)
      addressable (~> 2.5, >= 2.5.1)
      googleauth (>= 0.16.2, < 2.a)
      httpclient (>= 2.8.1, < 3.a)
      mini_mime (~> 1.0)
      representable (~> 3.0)
      retriable (>= 2.0, < 4.a)
      rexml
    google-apis-iamcredentials_v1 (0.17.0)
      google-apis-core (>= 0.11.0, < 2.a)
    google-apis-playcustomapp_v1 (0.13.0)
      google-apis-core (>= 0.11.0, < 2.a)
    google-apis-storage_v1 (0.31.0)
      google-apis-core (>= 0.11.0, < 2.a)
    google-cloud-core (1.8.0)
      google-cloud-env (>= 1.0, < 3.a)
      google-cloud-errors (~> 1.0)
    google-cloud-env (1.6.0)
      faraday (>= 0.17.3, < 3.0)
    google-cloud-errors (1.5.0)
    google-cloud-storage (1.47.0)
      addressable (~> 2.8)
      digest-crc (~> 0.4)
      google-apis-iamcredentials_v1 (~> 0.1)
      google-apis-storage_v1 (~> 0.31.0)
      google-cloud-core (~> 1.6)
      googleauth (>= 0.16.2, < 2.a)
      mini_mime (~> 1.0)
    googleauth (1.8.1)
      faraday (>= 0.17.3, < 3.a)
      jwt (>= 1.4, < 3.0)
      multi_json (~> 1.11)
      os (>= 0.9, < 2.0)
      signet (>= 0.16, < 2.a)
    highline (2.0.3)
    http-cookie (1.0.8)
      domain_name (~> 0.5)
    httpclient (2.9.0)
      mutex_m
    jmespath (1.6.2)
    json (2.12.2)
    jwt (2.10.1)
      base64
    logger (1.7.0)
    mini_magick (4.13.2)
    mini_mime (1.1.5)
    multi_json (1.15.0)
    multipart-post (2.4.1)
    mutex_m (0.3.0)
    nanaimo (0.4.0)
    naturally (2.3.0)
    nkf (0.2.0)
    optparse (0.6.0)
    os (1.1.4)
    plist (3.7.2)
    public_suffix (6.0.2)
    rake (13.3.0)
    representable (3.2.0)
      declarative (< 0.1.0)
      trailblazer-option (>= 0.1.1, < 0.2.0)
      uber (< 0.2.0)
    retriable (3.1.2)
    rexml (3.4.1)
    rouge (3.28.0)
    ruby2_keywords (0.0.5)
    rubyzip (2.4.1)
    security (0.1.5)
    signet (0.20.0)
      addressable (~> 2.8)
      faraday (>= 0.17.5, < 3.a)
      jwt (>= 1.5, < 3.0)
      multi_json (~> 1.10)
    simctl (1.6.10)
      CFPropertyList
      naturally
    sysrandom (1.0.5)
    terminal-notifier (2.0.0)
    terminal-table (3.0.2)
      unicode-display_width (>= 1.1.1, < 3)
    trailblazer-option (0.1.2)
    tty-cursor (0.7.1)
    tty-screen (0.8.2)
    tty-spinner (0.9.3)
      tty-cursor (~> 0.7)
    uber (0.1.0)
    unicode-display_width (2.6.0)
    word_wrap (1.0.0)
    xcodeproj (1.27.0)
      CFPropertyList (>= 2.3.3, < 4.0)
      atomos (~> 0.1.3)
      claide (>= 1.0.2, < 2.0)
      colored2 (~> 3.1)
      nanaimo (~> 0.4.0)
      rexml (>= 3.3.6, < 4.0)
    xcpretty (0.4.1)
      rouge (~> 3.28.0)
    xcpretty-travis-formatter (1.0.1)
      xcpretty (~> 0.2, >= 0.0.7)

PLATFORMS
  arm64-darwin-24
  ruby

DEPENDENCIES
  fastlane
  xcpretty

BUNDLED WITH
   2.6.9
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleURLTypes</key>
	<array>
		<dict>
			<key>CFBundleTypeRole</key>
			<string>Editor</string>
			<key>CFBundleURLName</key>
			<string>com.niiaz.travelbuddy</string>
			<key>CFBundleURLSchemes</key>
			<array>
				<string>travelbuddy</string>
			</array>
		</dict>
	</array>
	<key>UIApplicationSceneManifest</key>
	<dict>
		<key>UIApplicationSupportsMultipleScenes</key>
		<false/>
		<key>UISceneConfigurations</key>
		<dict>
			<key>UIWindowSceneSessionRoleApplication</key>
			<array>
				<dict>
					<key>UISceneConfigurationName</key>
					<string>Default Configuration</string>
					<key>UISceneDelegateClassName</key>
					<string>$(PRODUCT_MODULE_NAME).SceneDelegate</string>
					<key>UISceneStoryboardFile</key>
					<string>Main</string>
				</dict>
			</array>
		</dict>
	</dict>
</dict>
</plist>
